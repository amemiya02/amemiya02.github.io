<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>算法 | 个人技术博客</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/categories/%E7%AE%97%E6%B3%95/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/categories/%E7%AE%97%E6%B3%95/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/categories/%E7%AE%97%E6%B3%95/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/categories/%E7%AE%97%E6%B3%95/">
  <meta property="og:site_name" content="个人技术博客">
  <meta property="og:title" content="算法">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法">
<meta name="twitter:description" content="">

</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="个人技术博客 (Alt + H)">个人技术博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    算法
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/快慢指针】LeetCode 283. 移动零
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
示例 1:
输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0]
核心思路：快慢指针（一次遍历） 这道题有两个核心要求：
将所有 0 移动到末尾。 保持所有非零元素的相对顺序不变。 第二个要求&#34;保持相对顺序&#34;是解题的关键。它告诉我们，不能简单地像&#34;移除元素&#34;那样，用头尾指针交换元素，因为那样会打乱非零元素的原有顺序。
这个问题的本质可以看作是：将所有非零元素，按原有的顺序，紧凑地移动到数组的前面，然后将剩余的位置全部填上零。
这正是快慢指针擅长的场景：
定义指针：
慢指针 p (或 slow): 这个指针用于标记&#34;下一个非零元素应该被放置的位置&#34;。在 p 左边的所有元素（不含 p）都是已经处理好的、按序排列的非零元素。 快指针 q (或 fast): 这个指针负责遍历整个数组，去寻找非零元素。 执行过程：
初始化 p 和 q 都指向数组的起始位置 0。 快指针 q 开始向后遍历数组。 当 q 遇到一个非零元素时，说明这个元素需要被保留并放到前面。于是，我们执行两个操作： 将这个非零元素 nums[q] 赋值给慢指针 p 所在的位置 nums[p]。 将慢指针 p 向后移动一位 (p&#43;&#43;)，为下一个非零元素腾出位置。 如果 q 遇到的是 0，则慢指针 p 保持不动，只有快指针 q 继续向后移动。 填充末尾的零：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-20 14:55:00 +0900 JST'>September 20, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/快慢指针】LeetCode 283. 移动零" href="http://localhost:1313/posts/2025-09-20-283-move-zeroes/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/哈希表】LeetCode 1. 两数之和
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入： nums = [2,7,11,15], target = 9 输出： [0,1] 解释： 因为 nums[0] &#43; nums[1] == 9 ，返回 [0, 1] 。
核心思路：用空间换时间 作为 LeetCode 的开篇之作，这道题完美地诠释了如何通过&#34;空间换时间&#34;的思想来优化算法。
暴力解法的瓶颈在于&#34;寻找另一个数&#34;的过程太慢。对于每个 nums[i]，我们都需要在数组中寻找是否存在一个数 target - nums[i]。这个寻找过程能否被加速呢？
答案是肯定的，哈希表提供了近乎 $O(1)$ 的查找效率。
我们可以使用一个哈希表（HashMap）来存储已经遍历过的数字及其对应的索引，即 Map&lt;数值, 索引&gt;。
具体的算法流程如下：
创建一个空的哈希表 map。 遍历 nums 数组，对于当前的元素 nums[i]： a. 计算我们需要寻找的&#34;另一半&#34;：complement = target - nums[i]。 b. 在哈希表中查找 complement 是否存在。 * 如果存在，说明我们找到了解！complement 的索引已经存在 map 中，当前元素的索引是 i。我们立即返回 [map.get(complement), i]。 * 如果不存在，说明到目前为止还没遇到能和 nums[i] 配对的数。我们将当前数字和它的索引存入哈希表 map.put(nums[i], i)，以便后续的元素能用它来配对。 遍历结束。由于题目保证有唯一解，所以在循环中一定会找到答案。 这个&#34;一边遍历，一边查找，一边插入&#34;的单遍哈希表解法，非常巧妙地在一次循环中完成了所有工作。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-20 14:50:00 +0900 JST'>September 20, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/哈希表】LeetCode 1. 两数之和" href="http://localhost:1313/posts/2025-09-20-1-two-sum/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/哈希表】LeetCode 49. 字母异位词分组
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
字母异位词 是由相同字母按不同顺序排列组成的单词。
示例 1:
输入: strs = [&#34;eat&#34;, &#34;tea&#34;, &#34;tan&#34;, &#34;ate&#34;, &#34;nat&#34;, &#34;bat&#34;] 输出: [[&#34;bat&#34;],[&#34;nat&#34;,&#34;tan&#34;],[&#34;ate&#34;,&#34;eat&#34;,&#34;tea&#34;]]
核心思路：寻找唯一标识 除了字母完全相同，字母异位词的另一个充要条件是每个字母出现的频率完全相同。因此，我们也可以根据一个单词的字符频率来生成 key。
例如，对于 &#34;aab&#34;，其字符频率可以表示为一个长度为 26 的数组 [2, 1, 0, 0, ...]。为了把这个数组用作哈希表的 key，我们需要将它转换成一个不可变的字符串。
我们可以简单地将计数拼接起来，例如用 &#34;#&#34; 分隔：&#34;2#1#0#0#...&#34;。这样，所有异位词（如 &#34;aba&#34;, &#34;baa&#34;）都会生成这个完全相同的字符串 key。
你提供的答案正是采用了这种思路，通过一个辅助函数 strToCount 将频率数组转换成一个固定格式的字符串，同样起到了唯一标识的作用。
代码实现 (Java) class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str : strs) { // 1. 将每个字符串的字符计数转换为唯一的 key String key = generateCountKey(str); // 2. 从 map 中获取该 key 对应的列表，若不存在则创建新列表 List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;&gt;()); // 3. 将当前字符串加入列表 list.add(str); // 4. 将更新后的列表放回 map map.put(key, list); } // 返回 map 中所有的值（即分组后的列表） return new ArrayList&lt;&gt;(map.values()); } // 将字符串转换为基于字符计数的 key private String generateCountKey(String str) { int[] counts = new int[26]; for (char c : str.toCharArray()) { counts[c - &#39;a&#39;]&#43;&#43;; } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 26; i&#43;&#43;) { // 用特殊字符分隔，防止歧义，例如 &#34;b1c2&#34; vs &#34;bc12&#34; sb.append((char)(&#39;a&#39; &#43; i)); sb.append(counts[i]); } return sb.toString(); } } 复杂度分析 设 N 是字符串数组 strs 的长度，K 是数组中字符串的最大长度。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-20 14:45:00 +0900 JST'>September 20, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/哈希表】LeetCode 49. 字母异位词分组" href="http://localhost:1313/posts/2025-09-20-49-group-anagrams/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/哈希表 / 数组】LeetCode 383. 赎金信
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。
magazine 中的每个字符只能在 ransomNote 中使用一次。
示例 1：
输入： ransomNote = &#34;a&#34;, magazine = &#34;b&#34; 输出： false
示例 2：
输入： ransomNote = &#34;aa&#34;, magazine = &#34;aab&#34; 输出： true
核心思路：字符计数 这道题的本质是判断 magazine 字符串中的字符数量，是否足够&#34;支付&#34; ransomNote 中所需的字符数量。字符的顺序无关紧要，我们只关心每个字符的可用频率。
这是一个典型的哈希表或频率统计问题。
统计资源：首先，我们需要清点我们拥有的&#34;资源&#34;，即 magazine 中每个字符的数量。
我们可以遍历 magazine 字符串。 由于题目中只包含小写英文字母，我们可以使用一个长度为 26 的整型数组 counts 来充当哈希表，这比使用 HashMap 更高效。数组的索引 c - &#39;a&#39; 对应字符 c。 遍历 magazine 时，将对应字符的计数值加 1。 消耗资源：统计完 magazine 的字符后，我们再遍历 ransomNote，看看我们的资源是否足够。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-18 18:18:00 +0900 JST'>September 18, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/哈希表 / 数组】LeetCode 383. 赎金信" href="http://localhost:1313/posts/2025-09-18-383-ransom-note/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/双指针】LeetCode 392. 判断子序列
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&#34;ace&#34;是&#34;abcde&#34;的一个子序列，而&#34;aec&#34;不是）。
示例：
输入： s = &#34;abc&#34;, t = &#34;ahbgdc&#34; 输出： true
输入： s = &#34;axc&#34;, t = &#34;ahbgdc&#34; 输出： false
核心思路：双指针 这道题的核心是匹配字符，同时要保持相对顺序。这种&#34;按顺序查找&#34;的场景，是双指针大显身手的地方。我们可以使用两个指针，一个指向子序列 s，一个指向主串 t，然后同步向前扫描。
初始化指针：
定义指针 p 指向 s 的起始位置 0。 定义指针 q 指向 t 的起始位置 0。 贪心匹配：
我们使用指针 q 遍历主串 t，同时用指针 p 来标记我们当前正在 s 中寻找的字符。 当 p 和 q 都在各自的字符串范围内时，进行循环比较： 如果 s.charAt(p) 与 t.charAt(q) 相等，意味着我们在 t 中找到了 s 的一个字符。接下来我们应该去寻找 s 的下一个字符了，所以将 p 和 q 都向后移动一位 (p&#43;&#43;, q&#43;&#43;)。 如果 s.charAt(p) 与 t.charAt(q) 不相等，说明当前 t 中的这个字符不是我们想要的。我们应该继续在 t 的后续部分寻找 s.charAt(p)，所以只将 q 向后移动一位 (q&#43;&#43;)。 判断结果：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-17 20:13:00 +0900 JST'>September 17, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/双指针】LeetCode 392. 判断子序列" href="http://localhost:1313/posts/2025-09-17-392-is-subsequence/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/双指针】LeetCode 125. 验证回文串
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。
字母和数字都属于字母数字字符。
给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。
示例：
输入： s = &#34;A man, a plan, a canal: Panama&#34; 输出： true 解释： &#34;amanaplanacanalpanama&#34; 是回文串。
核心思路：相向双指针 “回文&#34;这个特性，天然就适合使用相向双指针来解决。我们可以设置一个指针从字符串头部开始，另一个指针从尾部开始，同时向中间移动并进行比较。
对于这道题，我们需要在比较之前，先对字符进行&#34;清洗”，即忽略非字母数字字符和大小写。
初始化指针：
定义左指针 left 指向字符串的起始位置 0。 定义右指针 right 指向字符串的末尾位置 s.length() - 1。 循环与过滤：
当 left &lt; right 时，循环继续。 在循环内部，首先要找到左右两边有效的、可用于比较的字符。 移动 left 指针：如果 left 指向的字符不是字母或数字，就将 left 右移 (left&#43;&#43;)，跳过该字符。 移动 right 指针：如果 right 指向的字符不是字母或数字，就将 right 左移 (right--)，跳过该字符。 比较字符：
当左右指针都停留在有效的字母数字字符上时，将它们统一转换为小写进行比较。 如果 Character.toLowerCase(s.charAt(left)) 不等于 Character.toLowerCase(s.charAt(right))，说明字符串不是回文串，可以直接返回 false。 向中心移动：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-16 21:02:00 +0900 JST'>September 16, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/双指针】LeetCode 125. 验证回文串" href="http://localhost:1313/posts/2025-09-16-125-valid-palindrome/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/哈希表 / 摩尔投票】LeetCode 169. 多数元素
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例：
输入： nums = [2,2,1,1,1,2,2] 输出： 2
核心思路 这道题旨在寻找数组中数量过半的元素。我们介绍两种主流的思路。
思路一：哈希表计数 这是最直观、最容易想到的方法。我们可以利用一个哈希表（HashMap）来记录数组中每个元素出现的次数。
定义哈希表：创建一个 Map&lt;Integer, Integer&gt; 用于存储 元素 -&gt; 出现次数 的映射。 遍历数组：遍历 nums 数组，对于每个元素 num： 将其在哈希表中的计数值加 1。 每次更新计数后，立即检查该元素的计数值是否已经大于 n/2。 如果超过 n/2，那么这个元素就是我们要找的多数元素，直接返回它。 返回结果：由于题目保证多数元素总是存在，所以在遍历过程中必然会找到答案。 这个方法用空间换时间，思路简单清晰，易于实现。
思路二：摩尔投票算法 (Boyer-Moore Voting Algorithm) 这是一种非常巧妙的算法，可以在线性的时间和常数的空间内解决问题。
它的核心思想是对拼消耗。可以想象成在数组中进行一场选举，不同阵营的候选人进行投票。
定义候选者和票数：我们维护一个候选者 candidate 和一个计数器 count。 遍历数组：遍历 nums 数组，对于每个元素 num： 如果 count 为 0，表示之前的候选者已经被&#34;淘汰&#34;了，我们将当前元素 num 设为新的 candidate，并将 count 设为 1。 如果 num 与 candidate 相同，就给候选者&#34;投一票&#34;，count 加 1。 如果 num 与 candidate 不同，就让候选者的票数&#34;抵消&#34;一张，count 减 1。 返回结果：遍历结束后，留下的 candidate 就是最终的多数元素。 为什么这个方法可行？ 因为多数元素的数量超过了数组长度的一半，这意味着它的数量比所有其他元素数量的总和还要多。所以在对拼消耗的过程中，它的票数 count 最终不可能被减到 0 或以下，它必然是笑到最后的那个。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-15 10:05:00 +0900 JST'>September 15, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/哈希表 / 摩尔投票】LeetCode 169. 多数元素" href="http://localhost:1313/posts/2025-09-15-169-majority-element/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/快慢指针】LeetCode 80. 删除有序数组中的重复项 II
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例：
输入： nums = [1,1,1,2,2,3] 输出： 5, nums = [1,1,2,2,3,_] 解释： 函数应返回 k = 5，并且 nums 的前五个元素为 1, 1, 2, 2, 3。
核心思路：快慢指针的通用解法 这道题是 LeetCode 26 的进阶版，规则从&#34;只保留 1 个&#34;变成了&#34;最多保留 2 个&#34;。快慢指针的思路依然适用，我们只需要对写入条件稍作修改。
我们可以定义一个更通用的解法来处理&#34;最多保留 k 个重复项&#34;这类问题。
定义指针：
慢指针 slow: 指向下一个可以被覆盖的位置。[0...slow-1] 是已处理好的区域。 快指针 fast: 遍历整个数组，寻找符合条件的元素。 执行过程：
我们遍历数组，对于快指针 fast 指向的当前元素 nums[fast]，思考一个问题：在什么情况下，这个元素应该被保留下来？ 保留的条件是：当前处理好的数组长度 slow 小于 2，或者 nums[fast] 不等于 nums[slow - 2]。 slow &lt; 2：表示当前是数组最开头的两个位置，无论如何都应该被填充，因为题目允许最多两个重复项。 nums[fast] &gt; nums[slow - 2]：这是本算法的核心。nums[slow - 1] 和 nums[slow - 2] 是已处理好的数组的最后两个元素。如果当前快指针的元素 nums[fast] 和 nums[slow - 2] 相同，说明 nums[slow-2], nums[slow-1], nums[fast] 将构成三个或以上的连续重复，此时 nums[fast] 不应被保留。反之，则可以保留。 返回结果：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-14 16:55:00 +0900 JST'>September 14, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/快慢指针】LeetCode 80. 删除有序数组中的重复项 II" href="http://localhost:1313/posts/2025-09-14-80-remove-duplicates-from-sorted-array-ii/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/动态规划】LeetCode 70.爬楼梯
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例：
输入： n = 3 输出： 3 解释： 有三种方法可以爬到楼顶。
1 阶 &#43; 1 阶 &#43; 1 阶 1 阶 &#43; 2 阶 2 阶 &#43; 1 阶 核心思路：寻找递推关系 直接计算 n 阶楼梯的所有方法可能很复杂，我们不妨从小问题入手，寻找规律。
爬 1 阶楼梯 (n=1): 只有 1 种方法 (1)。 -&gt; $f(1) = 1$ 爬 2 阶楼梯 (n=2): 有 2 种方法 (1&#43;1, 2)。 -&gt; $f(2) = 2$ 爬 3 阶楼梯 (n=3): 有 3 种方法 (1&#43;1&#43;1, 1&#43;2, 2&#43;1)。 -&gt; $f(3) = 3$ 我们思考一下，要想到达第 n 阶，我们的最后一步是怎么迈出去的？
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-13 10:40:00 +0900 JST'>September 13, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/动态规划】LeetCode 70.爬楼梯" href="http://localhost:1313/posts/2025-09-13-70-climbing-stairs/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">【HOT100/快慢指针】LeetCode 26.删除有序数组中的重复项
    </h2>
  </header>
  <div class="entry-content">
    <p>题目回顾 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。
返回 k 。
示例：
输入： nums = [0,0,1,1,1,2,2,3,3,4] 输出： 5, nums = [0,1,2,3,4,_,_,_,_,_] 解释： 函数应该返回 k = 5，并且 nums 的前五个元素为 0, 1, 2, 3, 4。
核心思路：快慢指针 题目的关键在于&#34;数组有序&#34;和&#34;保持相对顺序&#34;。因为数组是有序的，所以所有重复的元素必然是相邻的。这让我们不必进行复杂的查找，只需向后遍历即可。
我们可以使用快慢指针来解决这个问题：
定义指针：
慢指针 p: 指向当前已处理好的、不重复数组的最后一个位置。它也代表了下一个唯一元素应该被放置的位置。 快指针 q: 负责向前探索，遍历整个数组，寻找与慢指针所指元素不同的新元素。 执行过程：
初始化 p = 0, q = 1。 快指针 q 向后遍历数组。 若 nums[q] 与 nums[p] 相同，说明是重复元素，则 p 不动，q 继续向后移动以跳过所有重复项。 若 nums[q] 与 nums[p] 不同，说明 q 找到了一个新的唯一元素。此时，先将慢指针 p 向后移动一位 (&#43;&#43;p)，然后将 nums[q] 的值赋给 nums[p]，完成新元素的&#34;入队&#34;。 返回结果：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-09-13 10:35:00 +0900 JST'>September 13, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 【HOT100/快慢指针】LeetCode 26.删除有序数组中的重复项" href="http://localhost:1313/posts/2025-09-13-26-remove-duplicates-from-sorted-array/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/categories/%E7%AE%97%E6%B3%95/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/categories/%E7%AE%97%E6%B3%95/page/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">个人技术博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
