<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LeetCode on 个人技术博客</title>
    <link>https://amemiya02.github.io/categories/leetcode/</link>
    <description>Recent content in LeetCode on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 03 Feb 2026 09:01:00 +0900</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Golang] LeetCode 热题 100 - 回溯</title>
      <link>https://amemiya02.github.io/posts/2026-02-03-backtracking/</link>
      <pubDate>Tue, 03 Feb 2026 09:01:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-02-03-backtracking/</guid>
      <description>&lt;h1 id=&#34;回溯&#34;&gt;回溯&lt;/h1&gt;
&lt;h2 id=&#34;46-全排列---medium&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/permutations/&#34;&gt;46. 全排列 - Medium&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;核心思路&#34;&gt;核心思路&lt;/h3&gt;
&lt;p&gt;回溯算法可以抽象为一个决策树的遍历过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路径与选择列表
路径 (Path)：已经做出的选择（代码中的 path）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;终止条件
当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;撤销选择 (Backtrack)
这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;permute&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) [][]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt; [][]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;used&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;backtrack&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;backtrack&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 终止条件：路径长度等于数组长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 注意：Go 中切片是引用传递，必须进行拷贝&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;temp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            copy(&lt;span style=&#34;color:#a6e22e&#34;&gt;temp&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;temp&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果该数字已经用过，跳过&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;used&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 做选择&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;used&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 递归进入下一层&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;backtrack&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 撤销选择（回溯）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;[:len(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;used&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] = &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;backtrack&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(n * n!)$，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(n)$，用于存储递归栈和路径。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 图论</title>
      <link>https://amemiya02.github.io/posts/2026-02-03-graph/</link>
      <pubDate>Tue, 03 Feb 2026 09:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-02-03-graph/</guid>
      <description>&lt;h1 id=&#34;图论&#34;&gt;图论&lt;/h1&gt;
&lt;h2 id=&#34;200-岛屿数量---mid&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/number-of-islands/&#34;&gt;200. 岛屿数量 - Mid&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和竖直方向上相邻的陆地连接形成。你可以假设网格的四个边均被水包围。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;核心思路&#34;&gt;核心思路&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;扫描：像扫描仪一样遍历每一个格点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触发搜索：遇到 &amp;lsquo;1&amp;rsquo; 时，说明找到了一个岛屿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消除影响：为了不重复计算同一个岛屿，必须在发现它的瞬间，通过 DFS 把这个岛屿所有的土地全部标记为 &amp;lsquo;0&amp;rsquo;。这就像是在地图上把发现的岛屿“涂黑”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数：触发 DFS 的次数，就是岛屿的总数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;numIslands&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt; [][]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;), len(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历整个网格&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果发现陆地&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;][&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 发现一个岛屿，计数加 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt; [][]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;), len(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 越界检查或遇到水（&amp;#39;0&amp;#39;），直接返回&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;][&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 标记当前陆地已被访问（淹没），防止死循环&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;][&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;] = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 向四个方向扩散&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 右&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;grid&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 左&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(M * N)$，其中 M 和 N 分别是网格的行数和列数。每个格点最多被访问一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(M * N)$，在最坏情况下，递归栈的深度可能达到 M * N。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;994-腐烂的橘子---mid&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/rotting-oranges/&#34;&gt;994. 腐烂的橘子 - Mid&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾-1&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 二叉树</title>
      <link>https://amemiya02.github.io/posts/2026-01-31-binary-tree/</link>
      <pubDate>Sat, 31 Jan 2026 09:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-31-binary-tree/</guid>
      <description>&lt;h1 id=&#34;二叉树&#34;&gt;二叉树&lt;/h1&gt;
&lt;h2 id=&#34;94-二叉树的中序遍历---easy&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/binary-tree-inorder-traversal/&#34;&gt;94. 二叉树的中序遍历 - Easy&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它的 &lt;strong&gt;中序&lt;/strong&gt; 遍历。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;核心思路&#34;&gt;核心思路&lt;/h3&gt;
&lt;p&gt;递归或者迭代&lt;/p&gt;
&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Definition for a binary tree node.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * type TreeNode struct {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Val int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Left *TreeNode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Right *TreeNode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;inorderTraversal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TreeNode&lt;/span&gt;) []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TreeNode&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 一路向左，把所有左孩子入栈&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Left&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 弹出栈顶（当前最左的节点）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;[len(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;[:len(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 记录结果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Val&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 转向右子树&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;curr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Right&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(H)$，其中 H 是二叉树的高度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;104-二叉树的最大深度---easy&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/maximum-depth-of-binary-tree/&#34;&gt;104. 二叉树的最大深度 - Easy&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾-1&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 链表</title>
      <link>https://amemiya02.github.io/posts/2026-01-28-linked-list/</link>
      <pubDate>Wed, 28 Jan 2026 09:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-28-linked-list/</guid>
      <description>&lt;h1 id=&#34;链表&#34;&gt;链表&lt;/h1&gt;
&lt;h2 id=&#34;160-相交链表---easy&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/intersection-of-two-linked-lists/&#34;&gt;160. 相交链表 - Easy&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个单链表的头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点, 返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;题目数据 &lt;strong&gt;保证&lt;/strong&gt; 整个链式结构中不存在环，并且函数返回结果后，链表必须 &lt;strong&gt;保持其原始结构&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;核心思路&#34;&gt;核心思路&lt;/h3&gt;
&lt;h4 id=&#34;思路0hashset去重&#34;&gt;思路0：HashSet去重&lt;/h4&gt;
&lt;h4 id=&#34;思路一双指针--长度对齐&#34;&gt;思路一：双指针 + 长度对齐&lt;/h4&gt;
&lt;p&gt;这是最直观的解法。既然相交前的部分长度可能不同，导致我们无法直接同步遍历，那我们想办法让它们变得一样长就可以了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算长度&lt;/strong&gt;：首先，分别遍历两个链表，得到它们的长度 &lt;code&gt;lenA&lt;/code&gt; 和 &lt;code&gt;lenB&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对齐指针&lt;/strong&gt;：计算出长度差 &lt;code&gt;diff = |lenA - lenB|&lt;/code&gt;。让&lt;strong&gt;较长&lt;/strong&gt;的那个链表的指针先走 &lt;code&gt;diff&lt;/code&gt; 步。这样操作之后，两个指针距离各自链表的末尾就有了相同的距离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步遍历&lt;/strong&gt;：现在两个指针位于同一起跑线（相对终点而言），我们让它们同步向后移动，一次一步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寻找交点&lt;/strong&gt;：在同步移动的过程中，第一次出现两个指针相等 (&lt;code&gt;headA == headB&lt;/code&gt;) 的地方，就是它们的第一个相交节点。如果一直走到末尾 (&lt;code&gt;null&lt;/code&gt;) 都没有相遇，则说明两个链表不相交。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个方法就像两个人去同一个终点，路程长的人先出发一段距离，然后两个人再同时出发，这样他们就能同时到达终点。&lt;/p&gt;
&lt;h4 id=&#34;思路二双指针浪漫相遇法&#34;&gt;思路二：双指针&amp;quot;浪漫&amp;quot;相遇法&lt;/h4&gt;
&lt;p&gt;这是一个更巧妙，代码也更简洁的解法，它避免了显式地计算长度。&lt;/p&gt;
&lt;p&gt;想象有两个指针 &lt;code&gt;pA&lt;/code&gt; 和 &lt;code&gt;pB&lt;/code&gt;，分别从 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; 出发。它们同时前进，当任何一个指针走到自己链表的末尾时，就&lt;strong&gt;跳到对方链表的头节点&lt;/strong&gt;继续前进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么这个方法可行？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路径长度相等&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pA&lt;/code&gt; 走过的路径：&lt;code&gt;链表A的长度&lt;/code&gt; + &lt;code&gt;链表B的长度&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pB&lt;/code&gt; 走过的路径：&lt;code&gt;链表B的长度&lt;/code&gt; + &lt;code&gt;链表A的长度&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;两个指针走过的总路程是完全相同的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;相遇点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果相交&lt;/strong&gt;：设 A 不相交部分长 &lt;code&gt;a&lt;/code&gt;，B 不相交部分长 &lt;code&gt;b&lt;/code&gt;，相交部分长 &lt;code&gt;c&lt;/code&gt;。&lt;code&gt;pA&lt;/code&gt; 走 &lt;code&gt;a+c&lt;/code&gt; 到达终点，然后从 B 的头部走 &lt;code&gt;b&lt;/code&gt; 步。&lt;code&gt;pB&lt;/code&gt; 走 &lt;code&gt;b+c&lt;/code&gt; 到达终点，然后从 A 的头部走 &lt;code&gt;a&lt;/code&gt; 步。当它们都走了 &lt;code&gt;a+b+c&lt;/code&gt; 的路程时，会在相交点相遇。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不相交&lt;/strong&gt;：&lt;code&gt;pA&lt;/code&gt; 走完 A 再走完 B，&lt;code&gt;pB&lt;/code&gt; 走完 B 再走完 A。它们会同时到达终点 &lt;code&gt;null&lt;/code&gt;，此时 &lt;code&gt;pA == pB == null&lt;/code&gt;，循环结束，正确返回 &lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个方法可以理解为，通过让两个指针都走一遍 &lt;code&gt;A+B&lt;/code&gt; 和 &lt;code&gt;B+A&lt;/code&gt; 的路程，从而消除了长度差，使得它们能够在终点前相遇。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 矩阵</title>
      <link>https://amemiya02.github.io/posts/2026-01-27-matrix/</link>
      <pubDate>Tue, 27 Jan 2026 09:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-27-matrix/</guid>
      <description>&lt;h1 id=&#34;矩阵&#34;&gt;矩阵&lt;/h1&gt;
&lt;h2 id=&#34;73-矩阵置零---mid&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/set-matrix-zeroes/&#34;&gt;73. 矩阵置零 - Mid&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵，如果一个元素为 &lt;code&gt;0&lt;/code&gt; ，则将其所在行和列的所有元素都设为 &lt;code&gt;0&lt;/code&gt; 。请使用 &lt;strong&gt;原地&lt;/strong&gt; 算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,1,1],[1,0,1],[1,1,1]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[1,0,1],[0,0,0],[1,0,1]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[0,0,0,0],[0,4,5,0],[0,3,1,0]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个直观的解决方案是使用 $O(mn)$ 的额外空间，但这并不是一个好的解决方案。&lt;/li&gt;
&lt;li&gt;一个简单的改进方案是使用 $O(m + n)$ 的额外空间，但这仍然不是最好的解决方案。&lt;/li&gt;
&lt;li&gt;你能想出一个仅使用常量空间的解决方案吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;核心思路利用首行首列做标记&#34;&gt;核心思路：利用首行首列做标记&lt;/h3&gt;
&lt;p&gt;这道题的难点在于&lt;strong&gt;污染&lt;/strong&gt;问题：如果我们一边遍历一边将 0 所在的行列置零，那么修改后的 0 会干扰后续的遍历，导致整个矩阵最后全变成了 0。&lt;/p&gt;
&lt;h4 id=&#34;空间复杂度优化路径&#34;&gt;空间复杂度优化路径&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;$O(MN)$ 空间&lt;/strong&gt;：新建一个同样的矩阵做标记。太浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$O(M+N)$ 空间&lt;/strong&gt;：使用两个布尔数组 &lt;code&gt;row[]&lt;/code&gt; 和 &lt;code&gt;col[]&lt;/code&gt;，分别记录哪一行、哪一列需要置零。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$O(1)$ 空间&lt;/strong&gt;：直接利用矩阵的第一行和第一列来替代上面的两个布尔数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;算法流程--方案&#34;&gt;算法流程 ($O(1)$ 方案)&lt;/h4&gt;
&lt;p&gt;既然我们要用第一行和第一列来记录&amp;quot;该行/列是否需要置零&amp;quot;，那么第一行和第一列原本的状态（是否包含 0）就需要先被保存下来，否则会被后续的标记覆盖。&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;记录首行首列状态&lt;/strong&gt;：
定义两个变量 &lt;code&gt;firstRowHasZero&lt;/code&gt; 和 &lt;code&gt;firstColHasZero&lt;/code&gt;，遍历第一行和第一列，如果发现 0，则将对应的变量置为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 普通数组</title>
      <link>https://amemiya02.github.io/posts/2026-01-26-array/</link>
      <pubDate>Mon, 26 Jan 2026 09:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-26-array/</guid>
      <description>&lt;h1 id=&#34;普通数组&#34;&gt;普通数组&lt;/h1&gt;
&lt;h2 id=&#34;53-最大子数组和---mid&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/maximum-subarray/&#34;&gt;53. 最大子数组和 - Mid&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;6&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 连续子数组 &lt;code&gt;[4,-1,2,1]&lt;/code&gt; 的和最大，为 &lt;code&gt;6&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [5,4,-1,7,8]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;23&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;核心思路动态规划与贪心&#34;&gt;核心思路：动态规划与贪心&lt;/h3&gt;
&lt;p&gt;这道题是&lt;strong&gt;动态规划&lt;/strong&gt;的经典入门题。&lt;/p&gt;
&lt;p&gt;如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 $O(N^2)$，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。&lt;/p&gt;
&lt;h4 id=&#34;状态定义&#34;&gt;状态定义&lt;/h4&gt;
&lt;p&gt;我们要思考：&lt;strong&gt;以当前数字 &lt;code&gt;nums[i]&lt;/code&gt; 结尾的子数组，它的最大和是多少？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;dp[i]&lt;/code&gt; 表示以 &lt;code&gt;nums[i]&lt;/code&gt; &lt;strong&gt;结尾&lt;/strong&gt;的连续子数组的最大和。那么对于 &lt;code&gt;nums[i]&lt;/code&gt; 来说，它面临两个选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;加入前面的队伍&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是正数，那么加上它肯定比自己单干强，即 &lt;code&gt;dp[i-1] + nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;另起炉灶&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 &lt;code&gt;nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;状态转移方程&#34;&gt;状态转移方程&lt;/h4&gt;
&lt;p&gt;根据上述分析，我们可以得到状态转移方程：&lt;/p&gt;
$$
dp[i] = \max(dp[i-1] + \text{nums}[i], \text{nums}[i])
$$&lt;h4 id=&#34;空间优化&#34;&gt;空间优化&lt;/h4&gt;
&lt;p&gt;观察转移方程发现，当前状态 &lt;code&gt;dp[i]&lt;/code&gt; 只与前一个状态 &lt;code&gt;dp[i-1]&lt;/code&gt; 有关。因此，我们不需要维护一个完整的 &lt;code&gt;dp&lt;/code&gt; 数组，只需要用一个变量 &lt;code&gt;pre&lt;/code&gt; 来记录&amp;quot;前一个位置的最大子数组和&amp;quot;即可。这也就是代码中 &lt;code&gt;pre&lt;/code&gt; 变量的作用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 子串</title>
      <link>https://amemiya02.github.io/posts/2026-01-25-substring/</link>
      <pubDate>Sun, 25 Jan 2026 10:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-25-substring/</guid>
      <description>&lt;h1 id=&#34;子串&#34;&gt;子串&lt;/h1&gt;
&lt;h2 id=&#34;560-和为-k-的子数组---mid&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/subarray-sum-equals-k/&#34;&gt;560. 和为 K 的子数组 - Mid&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你统计并返回 &lt;strong&gt;该数组中和为 &lt;code&gt;k&lt;/code&gt; 的子数组的个数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;子数组是数组中元素的连续非空序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,1,1], k = 2&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,2,3], k = 3&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;核心思路前缀和--哈希表优化&#34;&gt;核心思路：前缀和 + 哈希表优化&lt;/h3&gt;
&lt;p&gt;这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 $O(n^2)$ 甚至 $O(n^3)$，无法通过所有测试用例。我们需要利用&lt;strong&gt;前缀和&lt;/strong&gt;的性质进行优化。&lt;/p&gt;
&lt;h4 id=&#34;1-前缀和转化&#34;&gt;1. 前缀和转化&lt;/h4&gt;
&lt;p&gt;定义 &lt;code&gt;pre[i]&lt;/code&gt; 为 &lt;code&gt;[0..i]&lt;/code&gt; 里所有数的和。那么 &lt;code&gt;[j..i]&lt;/code&gt; 这个子数组的和可以表示为：
&lt;/p&gt;
$$
sum[j..i] = pre[i] - pre[j-1]
$$&lt;p&gt;
题目要求找到和为 &lt;code&gt;k&lt;/code&gt; 的子数组，即寻找满足以下条件的 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt;：
&lt;/p&gt;
$$
pre[i] - pre[j-1] == k
$$&lt;p&gt;
移项得：
&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 滑动窗口</title>
      <link>https://amemiya02.github.io/posts/2026-01-25-sliding-window/</link>
      <pubDate>Sun, 25 Jan 2026 09:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-25-sliding-window/</guid>
      <description>&lt;h1 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h1&gt;
&lt;h2 id=&#34;3-无重复字符的最长子串---mid&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/longest-substring-without-repeating-characters/&#34;&gt;3. 无重复字符的最长子串 - Mid&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;abcabcbb&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt; 因为无重复字符的最长子串是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;，所以其长度为 3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;pwwkew&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt; 因为无重复字符的最长子串是 &lt;code&gt;&amp;quot;wke&amp;quot;&lt;/code&gt;，所以其长度为 3。
请注意，你的答案必须是 &lt;strong&gt;子串&lt;/strong&gt; 的长度，&lt;code&gt;&amp;quot;pwke&amp;quot;&lt;/code&gt; 是一个子序列，不是子串。&lt;/p&gt;
&lt;h3 id=&#34;核心思路滑动窗口&#34;&gt;核心思路：滑动窗口&lt;/h3&gt;
&lt;p&gt;这道题要求我们找到一个&lt;strong&gt;连续&lt;/strong&gt;的子串，这个子串需要满足&amp;quot;无重复字符&amp;quot;的条件，并且长度要最长。这种在连续区间上求解的问题，非常适合使用&lt;strong&gt;滑动窗口&lt;/strong&gt;算法。&lt;/p&gt;
&lt;p&gt;我们可以想象有一个窗口在字符串 &lt;code&gt;s&lt;/code&gt; 上滑动，窗口的左右边界由两个指针 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 决定。这个窗口 &lt;code&gt;s[left...right]&lt;/code&gt; 就代表了我们正在考察的当前子串。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据结构选择&lt;/strong&gt;：我们需要一个数据结构来快速判断窗口内是否存在重复字符。&lt;strong&gt;哈希集合 (HashSet)&lt;/strong&gt; 是不二之选，它可以在 $O(1)$ 的时间内添加、删除和查找元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口的移动逻辑&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩大窗口&lt;/strong&gt;：我们不断地移动右指针 &lt;code&gt;right&lt;/code&gt;，将新的字符纳入窗口中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缩小窗口&lt;/strong&gt;：当新加入的字符 &lt;code&gt;s[right]&lt;/code&gt; 已经在哈希集合中存在时，说明窗口内出现了重复。此时，我们必须从左侧开始缩小窗口，即不断地移动左指针 &lt;code&gt;left&lt;/code&gt; 并从哈希集合中移除 &lt;code&gt;s[left]&lt;/code&gt;，直到窗口内不再包含重复的 &lt;code&gt;s[right]&lt;/code&gt; 为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化左指针 &lt;code&gt;left = 0&lt;/code&gt;，右指针 &lt;code&gt;right = 0&lt;/code&gt;，最大长度 &lt;code&gt;maxLength = 0&lt;/code&gt;，以及一个空的哈希集合 &lt;code&gt;set&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;右指针 &lt;code&gt;right&lt;/code&gt; 开始遍历整个字符串：
a.  获取当前右指针的字符 &lt;code&gt;c = s.charAt(right)&lt;/code&gt;。
b.  &lt;strong&gt;检查重复&lt;/strong&gt;：在 &lt;code&gt;set&lt;/code&gt; 中检查是否存在字符 &lt;code&gt;c&lt;/code&gt;。如果存在，就进入一个循环，不断从 &lt;code&gt;set&lt;/code&gt; 中移除左指针 &lt;code&gt;left&lt;/code&gt; 指向的字符，并递增 &lt;code&gt;left&lt;/code&gt;，直到 &lt;code&gt;set&lt;/code&gt; 中不再有 &lt;code&gt;c&lt;/code&gt;。
c.  &lt;strong&gt;添加新字符&lt;/strong&gt;：将当前字符 &lt;code&gt;c&lt;/code&gt; 添加到 &lt;code&gt;set&lt;/code&gt; 中。
d.  &lt;strong&gt;更新最大长度&lt;/strong&gt;：此时，从 &lt;code&gt;left&lt;/code&gt; 到 &lt;code&gt;right&lt;/code&gt; 的窗口内一定是无重复字符的。我们更新最大长度：&lt;code&gt;maxLength = Math.max(maxLength, right - left + 1)&lt;/code&gt;。
e.  将右指针 &lt;code&gt;right&lt;/code&gt; 右移一位，考察下一个字符。&lt;/li&gt;
&lt;li&gt;遍历结束后，&lt;code&gt;maxLength&lt;/code&gt; 就是最终答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种一扩一缩的动态调整，滑动窗口能够保证在一次遍历中就找到最优解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 双指针</title>
      <link>https://amemiya02.github.io/posts/2026-01-24-two-pointer/</link>
      <pubDate>Sat, 24 Jan 2026 21:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-24-two-pointer/</guid>
      <description>&lt;h1 id=&#34;双指针&#34;&gt;双指针&lt;/h1&gt;
&lt;h2 id=&#34;283-移动零---easy&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/move-zeroes/&#34;&gt;283. 移动零 - Easy&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt; ，必须在不复制数组的情况下&lt;strong&gt;原地&lt;/strong&gt;对数组进行操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;nums = [0,1,0,3,12]&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;[1,3,12,0,0]&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;核心思路快慢指针一次遍历&#34;&gt;核心思路：快慢指针（一次遍历）&lt;/h3&gt;
&lt;p&gt;这道题有两个核心要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将所有 &lt;code&gt;0&lt;/code&gt; 移动到末尾。&lt;/li&gt;
&lt;li&gt;保持所有&lt;strong&gt;非零&lt;/strong&gt;元素的相对顺序不变。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二个要求&amp;quot;保持相对顺序&amp;quot;是解题的关键。它告诉我们，不能简单地像&amp;quot;移除元素&amp;quot;那样，用头尾指针交换元素，因为那样会打乱非零元素的原有顺序。&lt;/p&gt;
&lt;p&gt;这个问题的本质可以看作是：&lt;strong&gt;将所有非零元素，按原有的顺序，紧凑地移动到数组的前面，然后将剩余的位置全部填上零&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这正是&lt;strong&gt;快慢指针&lt;/strong&gt;擅长的场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢指针 &lt;code&gt;p&lt;/code&gt; (或 &lt;code&gt;slow&lt;/code&gt;)&lt;/strong&gt;: 这个指针用于标记&amp;quot;下一个非零元素应该被放置的位置&amp;quot;。在 &lt;code&gt;p&lt;/code&gt; 左边的所有元素（不含 &lt;code&gt;p&lt;/code&gt;）都是已经处理好的、按序排列的非零元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快指针 &lt;code&gt;q&lt;/code&gt; (或 &lt;code&gt;fast&lt;/code&gt;)&lt;/strong&gt;: 这个指针负责遍历整个数组，去寻找非零元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 都指向数组的起始位置 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;快指针 &lt;code&gt;q&lt;/code&gt; 开始向后遍历数组。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;q&lt;/code&gt; 遇到一个&lt;strong&gt;非零&lt;/strong&gt;元素时，说明这个元素需要被保留并放到前面。于是，我们执行两个操作：
&lt;ol&gt;
&lt;li&gt;将这个非零元素 &lt;code&gt;nums[q]&lt;/code&gt; 赋值给慢指针 &lt;code&gt;p&lt;/code&gt; 所在的位置 &lt;code&gt;nums[p]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将慢指针 &lt;code&gt;p&lt;/code&gt; 向后移动一位 (&lt;code&gt;p++&lt;/code&gt;)，为下一个非零元素腾出位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;q&lt;/code&gt; 遇到的是 &lt;code&gt;0&lt;/code&gt;，则慢指针 &lt;code&gt;p&lt;/code&gt; 保持不动，只有快指针 &lt;code&gt;q&lt;/code&gt; 继续向后移动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;填充末尾的零&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Golang] LeetCode 热题 100 - 哈希</title>
      <link>https://amemiya02.github.io/posts/2026-01-24-hash/</link>
      <pubDate>Sat, 24 Jan 2026 19:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-24-hash/</guid>
      <description>&lt;h1 id=&#34;哈希&#34;&gt;哈希&lt;/h1&gt;
&lt;h2 id=&#34;1-两数之和---easy&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/two-sum/&#34;&gt;1. 两数之和 - Easy&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 &lt;strong&gt;和为目标值 &lt;code&gt;target&lt;/code&gt;&lt;/strong&gt; 的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [2,7,11,15]&lt;/code&gt;, &lt;code&gt;target = 9&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[0,1]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 因为 &lt;code&gt;nums[0] + nums[1] == 9&lt;/code&gt; ，返回 &lt;code&gt;[0, 1]&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;核心思路用空间换时间&#34;&gt;核心思路：用空间换时间&lt;/h3&gt;
&lt;p&gt;作为 LeetCode 的开篇之作，这道题完美地诠释了如何通过&amp;quot;空间换时间&amp;quot;的思想来优化算法。&lt;/p&gt;
&lt;p&gt;暴力解法的瓶颈在于&amp;quot;寻找另一个数&amp;quot;的过程太慢。对于每个 &lt;code&gt;nums[i]&lt;/code&gt;，我们都需要在数组中寻找是否存在一个数 &lt;code&gt;target - nums[i]&lt;/code&gt;。这个寻找过程能否被加速呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的，&lt;strong&gt;哈希表&lt;/strong&gt;提供了近乎 $O(1)$ 的查找效率。&lt;/p&gt;
&lt;p&gt;我们可以使用一个哈希表（HashMap）来存储已经遍历过的数字及其对应的索引，即 &lt;code&gt;Map&amp;lt;数值, 索引&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体的算法流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个空的哈希表 &lt;code&gt;map&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历 &lt;code&gt;nums&lt;/code&gt; 数组，对于当前的元素 &lt;code&gt;nums[i]&lt;/code&gt;：
a.  计算我们需要寻找的&amp;quot;另一半&amp;quot;：&lt;code&gt;complement = target - nums[i]&lt;/code&gt;。
b.  &lt;strong&gt;在哈希表中查找&lt;/strong&gt; &lt;code&gt;complement&lt;/code&gt; 是否存在。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果存在&lt;/strong&gt;，说明我们找到了解！&lt;code&gt;complement&lt;/code&gt; 的索引已经存在 &lt;code&gt;map&lt;/code&gt; 中，当前元素的索引是 &lt;code&gt;i&lt;/code&gt;。我们立即返回 &lt;code&gt;[map.get(complement), i]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不存在&lt;/strong&gt;，说明到目前为止还没遇到能和 &lt;code&gt;nums[i]&lt;/code&gt; 配对的数。我们将当前数字和它的索引存入哈希表 &lt;code&gt;map.put(nums[i], i)&lt;/code&gt;，以便后续的元素能用它来配对。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遍历结束。由于题目保证有唯一解，所以在循环中一定会找到答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个&amp;quot;一边遍历，一边查找，一边插入&amp;quot;的&lt;strong&gt;单遍哈希表&lt;/strong&gt;解法，非常巧妙地在一次循环中完成了所有工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希集合/Middle】LeetCode 128. 最长连续序列</title>
      <link>https://amemiya02.github.io/posts/2025-09-21-128-longest-consecutive-sequence/</link>
      <pubDate>Sun, 21 Sep 2025 11:03:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-21-128-longest-consecutive-sequence/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p&gt;
&lt;p&gt;请你设计并实现时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 的算法解决此问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [100,4,200,1,3,2]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;4&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 最长数字连续序列是 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;。它的长度为 4。&lt;/p&gt;
&lt;h2 id=&#34;核心思路哈希集合--智能枚举&#34;&gt;核心思路：哈希集合 + 智能枚举&lt;/h2&gt;
&lt;p&gt;这道题最核心的要求是 &lt;code&gt;O(n)&lt;/code&gt; 的时间复杂度，这意味着我们不能使用排序 $O(nlogn)$。&lt;/p&gt;
&lt;p&gt;要实现 &lt;code&gt;O(n)&lt;/code&gt;，关键在于&lt;strong&gt;快速查找&lt;/strong&gt;某个数是否存在。这让我们自然而然地想到了哈希表。我们可以用一个&lt;strong&gt;哈希集合 (HashSet)&lt;/strong&gt; 来优化查找过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这题的关键是找出序列起点来剪枝&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空间换时间，初始化哈希集合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个 &lt;code&gt;HashSet&lt;/code&gt;，并将数组 &lt;code&gt;nums&lt;/code&gt; 中的所有元素都添加进去。&lt;/li&gt;
&lt;li&gt;这一步有两个目的：一是方便后续以 $O(1)$ 的时间复杂度快速查找某个数是否存在；二是自动处理了数组中的重复元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;智能遍历，只从序列的起点开始计算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是整个算法最精妙的地方。如果我们遍历集合中的每一个数，都尝试计算以它开头的序列长度，会有大量重复计算。例如，对于序列 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;，我们从 &lt;code&gt;1&lt;/code&gt; 开始计算了一遍，又会从 &lt;code&gt;2&lt;/code&gt; 开始再计算一遍 &lt;code&gt;[2, 3, 4]&lt;/code&gt;，这是不必要的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何避免重复计算？&lt;/strong&gt; 答案是：&lt;strong&gt;只从一个连续序列的起点开始计算&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何判断一个数 &lt;code&gt;num&lt;/code&gt; 是不是起点？&lt;/strong&gt; 很简单，只要检查 &lt;code&gt;num - 1&lt;/code&gt; 是否存在于哈希集合中。如果 &lt;code&gt;num - 1&lt;/code&gt; &lt;strong&gt;不存在&lt;/strong&gt;，那么 &lt;code&gt;num&lt;/code&gt; 就是一个潜在的序列起点。如果 &lt;code&gt;num - 1&lt;/code&gt; &lt;strong&gt;存在&lt;/strong&gt;，那么 &lt;code&gt;num&lt;/code&gt; 肯定不是起点，我们可以直接跳过它，因为它一定会被 &lt;code&gt;num - 1&lt;/code&gt; 开始的计算所覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算长度并更新结果&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希表 / 数组】LeetCode 383. 赎金信</title>
      <link>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</link>
      <pubDate>Thu, 18 Sep 2025 18:18:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;aa&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路字符计数&#34;&gt;核心思路：字符计数&lt;/h2&gt;
&lt;p&gt;这道题的本质是判断 &lt;code&gt;magazine&lt;/code&gt; 字符串中的字符数量，是否足够&amp;quot;支付&amp;quot; &lt;code&gt;ransomNote&lt;/code&gt; 中所需的字符数量。字符的顺序无关紧要，我们只关心每个字符的可用频率。&lt;/p&gt;
&lt;p&gt;这是一个典型的&lt;strong&gt;哈希表&lt;/strong&gt;或&lt;strong&gt;频率统计&lt;/strong&gt;问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计资源&lt;/strong&gt;：首先，我们需要清点我们拥有的&amp;quot;资源&amp;quot;，即 &lt;code&gt;magazine&lt;/code&gt; 中每个字符的数量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以遍历 &lt;code&gt;magazine&lt;/code&gt; 字符串。&lt;/li&gt;
&lt;li&gt;由于题目中只包含小写英文字母，我们可以使用一个长度为 26 的整型数组 &lt;code&gt;counts&lt;/code&gt; 来充当哈希表，这比使用 &lt;code&gt;HashMap&lt;/code&gt; 更高效。数组的索引 &lt;code&gt;c - &#39;a&#39;&lt;/code&gt; 对应字符 &lt;code&gt;c&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历 &lt;code&gt;magazine&lt;/code&gt; 时，将对应字符的计数值加 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消耗资源&lt;/strong&gt;：统计完 &lt;code&gt;magazine&lt;/code&gt; 的字符后，我们再遍历 &lt;code&gt;ransomNote&lt;/code&gt;，看看我们的资源是否足够。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 392. 判断子序列</title>
      <link>https://amemiya02.github.io/posts/2025-09-17-392-is-subsequence/</link>
      <pubDate>Wed, 17 Sep 2025 20:13:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-17-392-is-subsequence/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，判断 &lt;code&gt;s&lt;/code&gt; 是否为 &lt;code&gt;t&lt;/code&gt; 的子序列。&lt;/p&gt;
&lt;p&gt;字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt;是&lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt;的一个子序列，而&lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt;不是）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; s = &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;, t = &lt;code&gt;&amp;quot;ahbgdc&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; s = &lt;code&gt;&amp;quot;axc&amp;quot;&lt;/code&gt;, t = &lt;code&gt;&amp;quot;ahbgdc&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路双指针&#34;&gt;核心思路：双指针&lt;/h2&gt;
&lt;p&gt;这道题的核心是匹配字符，同时要保持&lt;strong&gt;相对顺序&lt;/strong&gt;。这种&amp;quot;按顺序查找&amp;quot;的场景，是双指针大显身手的地方。我们可以使用两个指针，一个指向子序列 &lt;code&gt;s&lt;/code&gt;，一个指向主串 &lt;code&gt;t&lt;/code&gt;，然后同步向前扫描。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义指针 &lt;code&gt;p&lt;/code&gt; 指向 &lt;code&gt;s&lt;/code&gt; 的起始位置 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义指针 &lt;code&gt;q&lt;/code&gt; 指向 &lt;code&gt;t&lt;/code&gt; 的起始位置 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;贪心匹配&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们使用指针 &lt;code&gt;q&lt;/code&gt; 遍历主串 &lt;code&gt;t&lt;/code&gt;，同时用指针 &lt;code&gt;p&lt;/code&gt; 来标记我们&lt;strong&gt;当前正在 &lt;code&gt;s&lt;/code&gt; 中寻找的字符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 都在各自的字符串范围内时，进行循环比较：
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;s.charAt(p)&lt;/code&gt; 与 &lt;code&gt;t.charAt(q)&lt;/code&gt; &lt;strong&gt;相等&lt;/strong&gt;，意味着我们在 &lt;code&gt;t&lt;/code&gt; 中找到了 &lt;code&gt;s&lt;/code&gt; 的一个字符。接下来我们应该去寻找 &lt;code&gt;s&lt;/code&gt; 的下一个字符了，所以将 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; &lt;strong&gt;都&lt;/strong&gt;向后移动一位 (&lt;code&gt;p++&lt;/code&gt;, &lt;code&gt;q++&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;s.charAt(p)&lt;/code&gt; 与 &lt;code&gt;t.charAt(q)&lt;/code&gt; &lt;strong&gt;不相等&lt;/strong&gt;，说明当前 &lt;code&gt;t&lt;/code&gt; 中的这个字符不是我们想要的。我们应该继续在 &lt;code&gt;t&lt;/code&gt; 的后续部分寻找 &lt;code&gt;s.charAt(p)&lt;/code&gt;，所以只将 &lt;code&gt;q&lt;/code&gt; 向后移动一位 (&lt;code&gt;q++&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;判断结果&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 125. 验证回文串</title>
      <link>https://amemiya02.github.io/posts/2025-09-16-125-valid-palindrome/</link>
      <pubDate>Tue, 16 Sep 2025 21:02:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-16-125-valid-palindrome/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 &lt;strong&gt;回文串&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;字母和数字都属于字母数字字符。&lt;/p&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，如果它是 &lt;strong&gt;回文串&lt;/strong&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; s = &lt;code&gt;&amp;quot;A man, a plan, a canal: Panama&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; &lt;code&gt;&amp;quot;amanaplanacanalpanama&amp;quot;&lt;/code&gt; 是回文串。&lt;/p&gt;
&lt;h2 id=&#34;核心思路相向双指针&#34;&gt;核心思路：相向双指针&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;回文&amp;quot;这个特性，天然就适合使用&lt;strong&gt;相向双指针&lt;/strong&gt;来解决。我们可以设置一个指针从字符串头部开始，另一个指针从尾部开始，同时向中间移动并进行比较。&lt;/p&gt;
&lt;p&gt;对于这道题，我们需要在比较之前，先对字符进行&amp;quot;清洗&amp;rdquo;，即忽略非字母数字字符和大小写。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义左指针 &lt;code&gt;left&lt;/code&gt; 指向字符串的起始位置 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义右指针 &lt;code&gt;right&lt;/code&gt; 指向字符串的末尾位置 &lt;code&gt;s.length() - 1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;循环与过滤&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;left &amp;lt; right&lt;/code&gt; 时，循环继续。&lt;/li&gt;
&lt;li&gt;在循环内部，首先要找到左右两边有效的、可用于比较的字符。
&lt;ul&gt;
&lt;li&gt;移动 &lt;code&gt;left&lt;/code&gt; 指针：如果 &lt;code&gt;left&lt;/code&gt; 指向的字符&lt;strong&gt;不是&lt;/strong&gt;字母或数字，就将 &lt;code&gt;left&lt;/code&gt; 右移 (&lt;code&gt;left++&lt;/code&gt;)，跳过该字符。&lt;/li&gt;
&lt;li&gt;移动 &lt;code&gt;right&lt;/code&gt; 指针：如果 &lt;code&gt;right&lt;/code&gt; 指向的字符&lt;strong&gt;不是&lt;/strong&gt;字母或数字，就将 &lt;code&gt;right&lt;/code&gt; 左移 (&lt;code&gt;right--&lt;/code&gt;)，跳过该字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;比较字符&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当左右指针都停留在有效的字母数字字符上时，将它们统一转换为小写进行比较。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;Character.toLowerCase(s.charAt(left))&lt;/code&gt; &lt;strong&gt;不等于&lt;/strong&gt; &lt;code&gt;Character.toLowerCase(s.charAt(right))&lt;/code&gt;，说明字符串不是回文串，可以直接返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;向中心移动&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希表 / 摩尔投票】LeetCode 169. 多数元素</title>
      <link>https://amemiya02.github.io/posts/2025-09-15-169-majority-element/</link>
      <pubDate>Mon, 15 Sep 2025 10:05:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-15-169-majority-element/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中的多数元素。多数元素是指在数组中出现次数 &lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/code&gt; 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[2,2,1,1,1,2,2]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路&#34;&gt;核心思路&lt;/h2&gt;
&lt;p&gt;这道题旨在寻找数组中数量过半的元素。我们介绍两种主流的思路。&lt;/p&gt;
&lt;h3 id=&#34;思路一哈希表计数&#34;&gt;思路一：哈希表计数&lt;/h3&gt;
&lt;p&gt;这是最直观、最容易想到的方法。我们可以利用一个哈希表（HashMap）来记录数组中每个元素出现的次数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义哈希表&lt;/strong&gt;：创建一个 &lt;code&gt;Map&amp;lt;Integer, Integer&amp;gt;&lt;/code&gt; 用于存储 &lt;code&gt;元素 -&amp;gt; 出现次数&lt;/code&gt; 的映射。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;：遍历 &lt;code&gt;nums&lt;/code&gt; 数组，对于每个元素 &lt;code&gt;num&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;将其在哈希表中的计数值加 1。&lt;/li&gt;
&lt;li&gt;每次更新计数后，立即检查该元素的计数值是否已经大于 &lt;code&gt;n/2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果超过 &lt;code&gt;n/2&lt;/code&gt;，那么这个元素就是我们要找的多数元素，直接返回它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：由于题目保证多数元素总是存在，所以在遍历过程中必然会找到答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个方法用空间换时间，思路简单清晰，易于实现。&lt;/p&gt;
&lt;h3 id=&#34;思路二摩尔投票算法-boyer-moore-voting-algorithm&#34;&gt;思路二：摩尔投票算法 (Boyer-Moore Voting Algorithm)&lt;/h3&gt;
&lt;p&gt;这是一种非常巧妙的算法，可以在线性的时间和常数的空间内解决问题。&lt;/p&gt;
&lt;p&gt;它的核心思想是&lt;strong&gt;对拼消耗&lt;/strong&gt;。可以想象成在数组中进行一场选举，不同阵营的候选人进行投票。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义候选者和票数&lt;/strong&gt;：我们维护一个候选者 &lt;code&gt;candidate&lt;/code&gt; 和一个计数器 &lt;code&gt;count&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;：遍历 &lt;code&gt;nums&lt;/code&gt; 数组，对于每个元素 &lt;code&gt;num&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt;，表示之前的候选者已经被&amp;quot;淘汰&amp;quot;了，我们将当前元素 &lt;code&gt;num&lt;/code&gt; 设为新的 &lt;code&gt;candidate&lt;/code&gt;，并将 &lt;code&gt;count&lt;/code&gt; 设为 1。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;num&lt;/code&gt; 与 &lt;code&gt;candidate&lt;/code&gt; &lt;strong&gt;相同&lt;/strong&gt;，就给候选者&amp;quot;投一票&amp;quot;，&lt;code&gt;count&lt;/code&gt; 加 1。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;num&lt;/code&gt; 与 &lt;code&gt;candidate&lt;/code&gt; &lt;strong&gt;不同&lt;/strong&gt;，就让候选者的票数&amp;quot;抵消&amp;quot;一张，&lt;code&gt;count&lt;/code&gt; 减 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：遍历结束后，留下的 &lt;code&gt;candidate&lt;/code&gt; 就是最终的多数元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;为什么这个方法可行？&lt;/strong&gt; 因为多数元素的数量超过了数组长度的一半，这意味着它的数量比所有其他元素数量的总和还要多。所以在对拼消耗的过程中，它的票数 &lt;code&gt;count&lt;/code&gt; 最终不可能被减到 0 或以下，它必然是笑到最后的那个。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/快慢指针】LeetCode 80. 删除有序数组中的重复项 II</title>
      <link>https://amemiya02.github.io/posts/2025-09-14-80-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Sun, 14 Sep 2025 16:55:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-14-80-remove-duplicates-from-sorted-array-ii/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个有序数组 &lt;code&gt;nums&lt;/code&gt; ，请你 &lt;strong&gt;原地&lt;/strong&gt; 删除重复出现的元素，使得出现次数超过两次的元素&lt;strong&gt;只出现两次&lt;/strong&gt; ，返回删除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在 &lt;strong&gt;原地&lt;/strong&gt; 修改输入数组 并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[1,1,1,2,2,3]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;5&lt;/code&gt;, nums = &lt;code&gt;[1,1,2,2,3,_]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 函数应返回 &lt;code&gt;k = 5&lt;/code&gt;，并且 &lt;code&gt;nums&lt;/code&gt; 的前五个元素为 &lt;code&gt;1, 1, 2, 2, 3&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;核心思路快慢指针的通用解法&#34;&gt;核心思路：快慢指针的通用解法&lt;/h2&gt;
&lt;p&gt;这道题是 LeetCode 26 的进阶版，规则从&amp;quot;只保留 1 个&amp;quot;变成了&amp;quot;最多保留 2 个&amp;quot;。快慢指针的思路依然适用，我们只需要对写入条件稍作修改。&lt;/p&gt;
&lt;p&gt;我们可以定义一个更通用的解法来处理&amp;quot;最多保留 k 个重复项&amp;quot;这类问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢指针 &lt;code&gt;slow&lt;/code&gt;&lt;/strong&gt;: 指向下一个可以被覆盖的位置。&lt;code&gt;[0...slow-1]&lt;/code&gt; 是已处理好的区域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快指针 &lt;code&gt;fast&lt;/code&gt;&lt;/strong&gt;: 遍历整个数组，寻找符合条件的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们遍历数组，对于快指针 &lt;code&gt;fast&lt;/code&gt; 指向的当前元素 &lt;code&gt;nums[fast]&lt;/code&gt;，思考一个问题：&lt;strong&gt;在什么情况下，这个元素应该被保留下来？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;保留的条件是：当前处理好的数组长度 &lt;code&gt;slow&lt;/code&gt; 小于 2，或者 &lt;code&gt;nums[fast]&lt;/code&gt; 不等于 &lt;code&gt;nums[slow - 2]&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slow &amp;lt; 2&lt;/code&gt;：表示当前是数组最开头的两个位置，无论如何都应该被填充，因为题目允许最多两个重复项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[fast] &amp;gt; nums[slow - 2]&lt;/code&gt;：这是本算法的核心。&lt;code&gt;nums[slow - 1]&lt;/code&gt; 和 &lt;code&gt;nums[slow - 2]&lt;/code&gt; 是已处理好的数组的最后两个元素。如果当前快指针的元素 &lt;code&gt;nums[fast]&lt;/code&gt; 和 &lt;code&gt;nums[slow - 2]&lt;/code&gt; 相同，说明 &lt;code&gt;nums[slow-2]&lt;/code&gt;, &lt;code&gt;nums[slow-1]&lt;/code&gt;, &lt;code&gt;nums[fast]&lt;/code&gt; 将构成三个或以上的连续重复，此时 &lt;code&gt;nums[fast]&lt;/code&gt; 不应被保留。反之，则可以保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/动态规划】LeetCode 70.爬楼梯</title>
      <link>https://amemiya02.github.io/posts/2025-09-13-70-climbing-stairs/</link>
      <pubDate>Sat, 13 Sep 2025 10:40:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-13-70-climbing-stairs/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; n = 3
&lt;strong&gt;输出：&lt;/strong&gt; 3
&lt;strong&gt;解释：&lt;/strong&gt; 有三种方法可以爬到楼顶。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1 阶 + 1 阶 + 1 阶&lt;/li&gt;
&lt;li&gt;1 阶 + 2 阶&lt;/li&gt;
&lt;li&gt;2 阶 + 1 阶&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;核心思路寻找递推关系&#34;&gt;核心思路：寻找递推关系&lt;/h2&gt;
&lt;p&gt;直接计算 &lt;code&gt;n&lt;/code&gt; 阶楼梯的所有方法可能很复杂，我们不妨从小问题入手，寻找规律。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;爬 1 阶楼梯 (n=1)&lt;/strong&gt;: 只有 1 种方法 (1)。 -&amp;gt; $f(1) = 1$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;爬 2 阶楼梯 (n=2)&lt;/strong&gt;: 有 2 种方法 (1+1, 2)。 -&amp;gt; $f(2) = 2$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;爬 3 阶楼梯 (n=3)&lt;/strong&gt;: 有 3 种方法 (1+1+1, 1+2, 2+1)。 -&amp;gt; $f(3) = 3$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们思考一下，要想到达第 &lt;code&gt;n&lt;/code&gt; 阶，我们的&lt;strong&gt;最后一步&lt;/strong&gt;是怎么迈出去的？&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/快慢指针】LeetCode 26.删除有序数组中的重复项</title>
      <link>https://amemiya02.github.io/posts/2025-09-13-26-remove-duplicates-from-sorted-array/</link>
      <pubDate>Sat, 13 Sep 2025 10:35:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-13-26-remove-duplicates-from-sorted-array/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你 &lt;strong&gt;原地&lt;/strong&gt; 删除重复出现的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; ，返回删除后数组的新长度。元素的 &lt;strong&gt;相对顺序&lt;/strong&gt; 应该保持 &lt;strong&gt;一致&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;更改数组 &lt;code&gt;nums&lt;/code&gt; ，使 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素包含唯一元素，并按照它们最初在 &lt;code&gt;nums&lt;/code&gt; 中出现的顺序排列。&lt;/p&gt;
&lt;p&gt;返回 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[0,0,1,1,1,2,2,3,3,4]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;5&lt;/code&gt;, nums = &lt;code&gt;[0,1,2,3,4,_,_,_,_,_]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 函数应该返回 &lt;code&gt;k = 5&lt;/code&gt;，并且 &lt;code&gt;nums&lt;/code&gt; 的前五个元素为 &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;核心思路快慢指针&#34;&gt;核心思路：快慢指针&lt;/h2&gt;
&lt;p&gt;题目的关键在于&amp;quot;数组有序&amp;quot;和&amp;quot;保持相对顺序&amp;quot;。因为数组是有序的，所以所有重复的元素必然是相邻的。这让我们不必进行复杂的查找，只需向后遍历即可。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;strong&gt;快慢指针&lt;/strong&gt;来解决这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢指针 &lt;code&gt;p&lt;/code&gt;&lt;/strong&gt;: 指向当前已处理好的、不重复数组的最后一个位置。它也代表了下一个唯一元素应该被放置的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快指针 &lt;code&gt;q&lt;/code&gt;&lt;/strong&gt;: 负责向前探索，遍历整个数组，寻找与慢指针所指元素不同的新元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 &lt;code&gt;p = 0&lt;/code&gt;, &lt;code&gt;q = 1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;快指针 &lt;code&gt;q&lt;/code&gt; 向后遍历数组。&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;nums[q]&lt;/code&gt; 与 &lt;code&gt;nums[p]&lt;/code&gt; &lt;strong&gt;相同&lt;/strong&gt;，说明是重复元素，则 &lt;code&gt;p&lt;/code&gt; 不动，&lt;code&gt;q&lt;/code&gt; 继续向后移动以跳过所有重复项。&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;nums[q]&lt;/code&gt; 与 &lt;code&gt;nums[p]&lt;/code&gt; &lt;strong&gt;不同&lt;/strong&gt;，说明 &lt;code&gt;q&lt;/code&gt; 找到了一个新的唯一元素。此时，先将慢指针 &lt;code&gt;p&lt;/code&gt; 向后移动一位 (&lt;code&gt;++p&lt;/code&gt;)，然后将 &lt;code&gt;nums[q]&lt;/code&gt; 的值赋给 &lt;code&gt;nums[p]&lt;/code&gt;，完成新元素的&amp;quot;入队&amp;quot;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 27. 原地移除数组元素</title>
      <link>https://amemiya02.github.io/posts/2025-09-12-27-remove-element/</link>
      <pubDate>Fri, 12 Sep 2025 21:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-12-27-remove-element/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;原地&lt;/strong&gt; 移除所有数值等于 &lt;code&gt;val&lt;/code&gt; 的元素。元素的顺序可能发生改变。然后返回 &lt;code&gt;nums&lt;/code&gt; 中与 &lt;code&gt;val&lt;/code&gt; 不同的元素的数量。&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;nums&lt;/code&gt; 中不等于 &lt;code&gt;val&lt;/code&gt; 的元素数量为 &lt;code&gt;k&lt;/code&gt;，要通过此题，您需要执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改 &lt;code&gt;nums&lt;/code&gt; 数组，使 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素包含不等于 &lt;code&gt;val&lt;/code&gt; 的元素。&lt;code&gt;nums&lt;/code&gt; 的其余元素和 &lt;code&gt;nums&lt;/code&gt; 的大小并不重要。&lt;/li&gt;
&lt;li&gt;返回 &lt;code&gt;k&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[3,2,2,3]&lt;/code&gt;, val = &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;, nums = &lt;code&gt;[2,2,_,_]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 函数应该返回 &lt;code&gt;k = 2&lt;/code&gt;, 并且 &lt;code&gt;nums&lt;/code&gt; 中的前两个元素均为 &lt;code&gt;2&lt;/code&gt;。你的函数可以返回 &lt;code&gt;k&lt;/code&gt;，并且 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素可以包含任何顺序的 &lt;code&gt;2&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;核心思路相向双指针头尾指针&#34;&gt;核心思路：相向双指针（头尾指针）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义头尾指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 指针从数组头部 &lt;code&gt;0&lt;/code&gt; 开始，向后移动。它的任务是&lt;strong&gt;寻找值为 &lt;code&gt;val&lt;/code&gt; 的元素&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q&lt;/code&gt; 指针从数组尾部 &lt;code&gt;n-1&lt;/code&gt; 开始，向前移动。它的任务是&lt;strong&gt;寻找值不为 &lt;code&gt;val&lt;/code&gt; 的元素&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交换与移动&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 88. 合并两个有序数组</title>
      <link>https://amemiya02.github.io/posts/2025-09-11-88-merge-sorted-array/</link>
      <pubDate>Thu, 11 Sep 2025 18:46:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-11-88-merge-sorted-array/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排列的整数数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;，另有两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; ，分别表示 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; 中的元素数目。&lt;/p&gt;
&lt;p&gt;请你 &lt;strong&gt;合并&lt;/strong&gt; &lt;code&gt;nums2&lt;/code&gt; 到 &lt;code&gt;nums1&lt;/code&gt; 中，使合并后的数组同样按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：最终，合并后数组不应由函数返回，而是存储在数组 &lt;code&gt;nums1&lt;/code&gt; 中。为了应对这种情况，&lt;code&gt;nums1&lt;/code&gt; 的初始长度为 &lt;code&gt;m + n&lt;/code&gt;，其中前 &lt;code&gt;m&lt;/code&gt; 个元素表示应合并的元素，后 &lt;code&gt;n&lt;/code&gt; 个元素为 &lt;code&gt;0&lt;/code&gt; ，应忽略。&lt;code&gt;nums2&lt;/code&gt; 的长度为 &lt;code&gt;n&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums1 = &lt;code&gt;[1,2,3,0,0,0]&lt;/code&gt;, m = &lt;code&gt;3&lt;/code&gt;, nums2 = &lt;code&gt;[2,5,6]&lt;/code&gt;, n = &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[1,2,2,3,5,6]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 需要合并 &lt;code&gt;[1,2,3]&lt;/code&gt; 和 &lt;code&gt;[2,5,6]&lt;/code&gt; 。合并结果是 &lt;code&gt;[1,2,2,3,5,6]&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最初的思考为何从前往后走不通&#34;&gt;最初的思考：为何从前往后走不通？&lt;/h2&gt;
&lt;p&gt;看到这道题，我的第一反应非常直接：创建一个新的指针 &lt;code&gt;i&lt;/code&gt; 指向 &lt;code&gt;nums1&lt;/code&gt; 的开头，一个指针 &lt;code&gt;j&lt;/code&gt; 指向 &lt;code&gt;nums2&lt;/code&gt; 的开头，然后比较 &lt;code&gt;nums1[i]&lt;/code&gt; 和 &lt;code&gt;nums2[j]&lt;/code&gt; 的大小，把较小的那个放到一个新数组里。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
