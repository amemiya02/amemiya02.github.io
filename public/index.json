[{"categories":["算法","LeetCode"],"collections":null,"content":"多维动态规划 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:0:0","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#多维动态规划"},{"categories":["算法","LeetCode"],"collections":null,"content":"62. 不同路径 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:1:0","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#62-不同路径---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:1:1","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 机器人只能向下 / 向右移动，因此到达网格中 (i,j) 位置的路径数 = 到达上方 (i-1,j) 的路径数 + 到达左方 (i,j-1) 的路径数（核心递推关系）： 基础动态规划思路： 状态定义：dp[i][j] 表示到达 (i,j) 位置的不同路径数； 初始条件：第一行所有位置 dp[0][j] = 1（只能从左向右走），第一列所有位置 dp[i][0] = 1（只能从上向下走）； 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]（从上方或左方到达当前位置）。 空间优化思路： 观察到 dp[i][j] 仅依赖「上一行的 dp[i-1][j]」和「当前行的 dp[i][j-1]」，因此无需维护二维数组，只需用一维数组 dp[j] 替代； 初始：dp[j] = 1（对应第一行）； 递推：遍历每行时，dp[j] = dp[j]（上一行的 j 位置） + dp[j-1]（当前行的 j-1 位置）。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:1:2","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func uniquePaths(m int, n int) int { // 初始化二维dp数组：dp[i][j]表示到达(i,j)的路径数 dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 // 第一列所有位置路径数为1 } // 第一行所有位置路径数为1 for j := 0; j \u0026lt; n; j++ { dp[0][j] = 1 } // 递推计算其余位置 for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[m-1][n-1] }","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:1:3","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(m∗n)O(m*n)O(m∗n)，需要填充整个 dp 数组。 空间复杂度：O(m∗n)O(m*n)O(m∗n)，需要一个二维数组存储路径数。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:1:4","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"64. 最小路径和 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:2:0","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#64-最小路径和---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:2:1","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 与 “不同路径” 问题核心逻辑一致（仅能向下 / 向右移动），但目标从 “统计路径数” 变为 “找最小路径和”，递推关系调整为 “取上方 / 左方的最小路径和 + 当前格子值”： 基础二维动态规划思路： 状态定义：dp[i][j] 表示到达 (i,j) 位置的最小路径和； 初始条件： 第一行：dp[0][j] = dp[0][j-1] + grid[0][j]（只能从左向右走，累加前一个位置的最小和）； 第一列：dp[i][0] = dp[i-1][0] + grid[i][0]（只能从上向下走，累加前一个位置的最小和）； 递推公式：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]（选上方 / 左方更小的路径和，加上当前格子值）。 空间优化思路： 观察到 dp[i][j] 仅依赖「上一行的 dp[i-1][j]」和「当前行的 dp[i][j-1]」，无需维护二维数组，仅用一维数组 dp[j] 即可； 初始：dp[j] 累加第一行的和（对应第一行的最小路径和）； 递推：遍历每行时，dp[j] = min(dp[j]（上一行 j 位置）, dp[j-1]（当前行 j-1 位置）) + grid[i][j]。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:2:2","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func minPathSum(grid [][]int) int { m := len(grid) if m == 0 { return 0 } n := len(grid[0]) if n == 0 { return 0 } // 初始化二维dp数组：dp[i][j]表示到达(i,j)的最小路径和 dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) } // 初始化起点 dp[0][0] = grid[0][0] // 初始化第一列（只能从上向下走） for i := 1; i \u0026lt; m; i++ { dp[i][0] = dp[i-1][0] + grid[i][0] } // 初始化第一行（只能从左向右走） for j := 1; j \u0026lt; n; j++ { dp[0][j] = dp[0][j-1] + grid[0][j] } // 递推计算其余位置的最小路径和 for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { // 选上方或左方中更小的路径和，加上当前格子值 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] } } return dp[m-1][n-1] } // 辅助函数：返回两个整数的最小值 func min(a, b int) int { if a \u0026lt; b { return a } return b }","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:2:3","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(m∗n)O(m*n)O(m∗n)，需要填充整个 dp 数组。 空间复杂度：O(m∗n)O(m*n)O(m∗n)，需要一个二维数组存储最小路径和。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:2:4","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"5. 最长回文子串 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:3:0","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#5-最长回文子串---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个字符串 s，找到 s 中最长的回文子串。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:3:1","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 状态定义：dp[i][j] 表示字符串 s 中从下标 i 到 j 的子串是否为回文； 初始条件： dp[i][i] = true（单个字符一定是回文）； dp[i][i+1] = (s[i] == s[i+1])（两个字符需相等才是回文）； 递推公式：dp[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; dp[i+1][j-1]（首尾字符相等，且中间子串也是回文）； 遍历顺序：按子串长度从短到长遍历（长回文依赖短回文的结果）。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:3:2","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func longestPalindrome(s string) string { n := len(s) if n \u0026lt; 2 { return s } // dp[i][j]：s[i..j]是否为回文子串 dp := make([][]bool, n) for i := range dp { dp[i] = make([]bool, n) dp[i][i] = true // 单个字符是回文 } start, maxLen := 0, 1 // 初始最长回文是第一个字符 // 按子串长度遍历（从2到n） for length := 2; length \u0026lt;= n; length++ { // 遍历所有起始下标i for i := 0; i + length \u0026lt;= n; i++ { j := i + length - 1 // 子串结束下标 if s[i] != s[j] { dp[i][j] = false } else { // 子串长度为2时，无需检查中间（没有中间字符） if length == 2 { dp[i][j] = true } else { dp[i][j] = dp[i+1][j-1] } } // 更新最长回文信息 if dp[i][j] \u0026amp;\u0026amp; length \u0026gt; maxLen { maxLen = length start = i } } } return s[start : start+maxLen] }","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:3:3","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n2)O(n^2)O(n2)，需要填充整个 dp 数组。 空间复杂度：O(n2)O(n^2)O(n2)，需要一个二维数组存储回文状态。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:3:4","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"1143. 最长公共子序列 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:4:0","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#1143-最长公共子序列---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，\u0026ldquo;ace\u0026rdquo; 是 \u0026ldquo;abcde\u0026rdquo; 的子序列，但 \u0026ldquo;aec\u0026rdquo; 不是 \u0026ldquo;abcde\u0026rdquo; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:4:1","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 最长公共子序列（LCS）是经典动态规划问题，核心逻辑是 “字符匹配则累加长度，不匹配则取两种删除方式的最大值”： 基础二维动态规划思路： 状态定义：dp[i][j] 表示 text1 前 i 个字符（text1[0:i-1]）和 text2 前 j 个字符（text2[0:j-1]）的最长公共子序列长度； 初始条件：dp[0][j] = 0（text1 为空）、dp[i][0] = 0（text2 为空），空字符串与任何字符串的公共子序列长度为 0； 递推公式： 若 text1[i-1] == text2[j-1]（当前字符匹配）：dp[i][j] = dp[i-1][j-1] + 1； 若不匹配：dp[i][j] = max(dp[i-1][j], dp[i][j-1])（取 “删 text1 第 i 个字符” 或 “删 text2 第 j 个字符” 的最大 LCS 长度）。 空间优化思路： 观察到 dp[i][j] 仅依赖 dp[i-1][j-1]、dp[i-1][j]、dp[i][j-1]，无需维护二维数组，仅用一维数组 dp[j] 即可； 遍历 text1 时，从后往前遍历 text2（避免覆盖未计算的 dp[j-1]），并用临时变量保存 dp[i-1][j-1]。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:4:2","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func longestCommonSubsequence(text1 string, text2 string) int { m, n := len(text1), len(text2) // dp[i][j]：text1前i个字符 \u0026amp; text2前j个字符的LCS长度 dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { // 当前字符匹配，LCS长度+1 if text1[i-1] == text2[j-1] { dp[i][j] = dp[i-1][j-1] + 1 } else { // 不匹配，取“删text1第i个”或“删text2第j个”的最大值 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) } } } return dp[m][n] } // 辅助函数：返回两个整数的最大值 func max(a, b int) int { if a \u0026gt; b { return a } return b }","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:4:3","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(m∗n)O(m*n)O(m∗n)，需要填充整个 dp 数组。 空间复杂度：O(m∗n)O(m*n)O(m∗n)，需要一个二维数组存储 LCS 长度。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:4:4","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"72. 编辑距离 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:5:0","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#72-编辑距离---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:5:1","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 编辑距离是经典动态规划问题，核心逻辑是 “字符匹配则无需操作，不匹配则取插入 / 删除 / 替换的最小操作数 + 1”： 状态定义： dp[i][j] 表示将 word1 前 i 个字符（word1[0:i-1]）转换为 word2 前 j 个字符（word2[0:j-1]）的最少操作数； 初始条件： dp[i][0] = i：将 word1 前 i 个字符转为空串，需要删除 i 次； dp[0][j] = j：将空串转为 word2 前 j 个字符，需要插入 j 次； 递推公式： 若 word1[i-1] == word2[j-1]（当前字符匹配）：dp[i][j] = dp[i-1][j-1]（无需任何操作）； 若不匹配：dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1，其中： dp[i-1][j]：删除 word1 的第 i 个字符； dp[i][j-1]：向 word1 插入一个字符（匹配 word2 的第 j 个字符）； dp[i-1][j-1]：将 word1 的第 i 个字符替换为 word2 的第 j 个字符。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:5:2","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#核心思路-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func minDistance(word1 string, word2 string) int { m, n := len(word1), len(word2) // dp[i][j]：word1前i个字符 → word2前j个字符的最少操作数 dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) dp[i][0] = i // 初始条件：转空串需要删除i次 } // 初始条件：空串转word2前j个字符需要插入j次 for j := 0; j \u0026lt;= n; j++ { dp[0][j] = j } // 递推计算所有dp[i][j] for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { if word1[i-1] == word2[j-1] { // 字符匹配，无需操作，继承上一个状态 dp[i][j] = dp[i-1][j-1] } else { // 不匹配，取插入/删除/替换的最小值+1 dp[i][j] = minThree(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 } } } return dp[m][n] } // 辅助函数：返回三个整数的最小值 func minThree(a, b, c int) int { return min(min(a, b), c) } func min(a, b int) int { if a \u0026lt; b { return a } return b }","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:5:3","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(m∗n)O(m*n)O(m∗n)，需要填充整个 dp 数组。 空间复杂度：O(m∗n)O(m*n)O(m∗n)，需要一个二维数组存储最少操作数。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-mddp/:5:4","tags":["Go","多维动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 多维动态规划","uri":"/posts/2026-02-11-mddp/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"技巧 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:0:0","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#技巧"},{"categories":["算法","LeetCode"],"collections":null,"content":"136. 只出现一次的数字 - Easy ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:1:0","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#136-只出现一次的数字---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:1:1","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 异或运算有三个核心性质，恰好适配这道题的场景： 任何数和 0 异或，结果为自身：a ^ 0 = a； 任何数和自身异或，结果为 0：a ^ a = 0； 异或满足交换律和结合律：a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b。 基于这些性质，遍历数组并将所有元素依次异或： 成对出现的元素会相互抵消（异或结果为 0）； 最终剩下的结果就是唯一只出现一次的元素。 该思路的时间复杂度为 O (n)（仅一次遍历），空间复杂度为 O (1)（仅用一个变量存储结果），完全满足题目要求。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:1:2","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func singleNumber(nums []int) int { // 初始化结果为0，因为0异或任何数不改变其值 result := 0 // 遍历数组，所有元素依次异或 for _, num := range nums { result ^= num } // 最终结果即为唯一出现一次的元素 return result }","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:1:3","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，其中 n 是数组 nums 的长度。 空间复杂度：O(1)O (1)O(1)，我们只使用了一个变量 result。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:1:4","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"169. 多数元素 - Easy ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:2:0","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#169-多数元素---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:2:1","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 摩尔投票法（最优） 核心思想是 抵消：由于多数元素出现次数超过一半，遍历数组时用 “计数” 来抵消不同元素，最终剩下的候选元素必然是多数元素： 初始化：candidate（候选元素）为任意值，count（计数）为 0； 遍历逻辑： 若 count = 0，将当前元素设为 candidate； 若当前元素 == candidate，count += 1；否则 count -= 1； 结果：遍历结束后，candidate 即为多数元素（题目保证存在，无需额外验证）。 哈希表法（易理解） 核心思想是统计频次：遍历数组用哈希表记录每个元素的出现次数，再遍历哈希表找到次数 \u0026gt; n/2 的元素。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:2:2","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func majorityElement(nums []int) int { // 初始化候选元素和计数 candidate := 0 count := 0 for _, num := range nums { // 计数为0时，更新候选元素为当前元素 if count == 0 { candidate = num } // 相同元素计数+1，不同则-1 if num == candidate { count++ } else { count-- } } // 题目保证存在多数元素，直接返回候选 return candidate }","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:2:3","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，其中 n 是数组 nums 的长度。 空间复杂度：O(1)O (1)O(1)，我们只使用了两个变量 candidate 和 count。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:2:4","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"75. 颜色分类 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:3:0","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#75-颜色分类---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 必须在不使用库内置的 sort 函数的情况下解决这个问题。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:3:1","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 三路快排法（最优，一次遍历） 核心思想是用三个指针划分数组区域： left：0 的右边界（left 左侧所有元素都是 0）； cur：当前遍历的指针（从左到右扫描）； right：2 的左边界（right 右侧所有元素都是 2）。 遍历规则： 若 nums[cur] == 0：交换 nums[cur] 和 nums[left]，left++、cur++（left 右移扩大 0 区域，cur 继续遍历）； 若 nums[cur] == 1：cur++（1 是中间值，无需交换，直接遍历下一个）； 若 nums[cur] == 2：交换 nums[cur] 和 nums[right]，right\u0026ndash;（right 左移扩大 2 区域，cur 不 ++，因为交换后 cur 位置可能是 0/1，需重新检查）。 终止条件：cur \u0026gt; right（right 右侧已全是 2，无需继续遍历）。 计数排序法（易理解，两次遍历） 核心思想是 “统计频次 + 原地填充”： 第一步：遍历数组，统计 0、1、2 的出现次数； 第二步：按 “先填 0、再填 1、最后填 2” 的顺序，覆盖原数组（原地操作）。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:3:2","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func sortColors(nums []int) { n := len(nums) if n \u0026lt;= 1 { return // 空数组或单元素无需排序 } left := 0 // 0的右边界 cur := 0 // 当前遍历指针 right := n - 1 // 2的左边界 // 遍历直到cur超过right（right右侧全是2） for cur \u0026lt;= right { switch nums[cur] { case 0: // 交换cur和left位置的元素，扩大0的区域 nums[cur], nums[left] = nums[left], nums[cur] left++ cur++ // 交换后cur位置是1，可继续遍历 case 1: // 1在中间，无需交换，直接下一个 cur++ case 2: // 交换cur和right位置的元素，扩大2的区域 nums[cur], nums[right] = nums[right], nums[cur] right-- // 交换后cur位置可能是0/1，需重新检查，cur不++ } } }","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:3:3","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，其中 n 是数组 nums 的长度（仅一次遍历）。 空间复杂度：O(1)O (1)O(1)，我们只使用了常数级别的额外空间（left、cur、right 三个指针）。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:3:4","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"31. 下一个排列 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:4:0","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#31-下一个排列---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。 必须 原地 修改，只允许使用额外常数空间。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:4:1","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 下一个排列的本质是 “找到最小的增大”，核心逻辑分为 4 步（保证原地操作且字典序最小增大）： 找 “增大起点”：从后向前遍历，找到第一个满足 nums[i] \u0026lt; nums[i+1] 的下标 i（此时 i 之后的元素是降序，无法再增大，i 是唯一能增大的位置）； 找 “最小增大值”：若找到 i，再从后向前找第一个大于 nums[i] 的下标 j，交换 nums[i] 和 nums[j]（让 i 位置的数变大，且是 “最小的变大”，保证字典序增量最小）； 反转降序段：反转 i+1 到数组末尾的元素（i 之后原本是降序，反转后变为升序，这是该位置下最小的排列）； 无增大点处理：若未找到 i（数组整体降序），直接反转整个数组，得到字典序最小的升序排列。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:4:2","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func nextPermutation(nums []int) { n := len(nums) if n \u0026lt;= 1 { return } // 步骤1：从后向前找第一个 nums[i] \u0026lt; nums[i+1] 的下标i i := n - 2 for i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i+1] { i-- } // 步骤2：若找到i，从后向前找第一个大于nums[i]的j，交换i和j if i \u0026gt;= 0 { j := n - 1 for nums[j] \u0026lt;= nums[i] { j-- } nums[i], nums[j] = nums[j], nums[i] } // 步骤3：反转i+1到末尾的元素（若i=-1，反转整个数组） reverse(nums, i+1, n-1) } // 辅助函数：原地反转nums中[left, right]区间的元素 func reverse(nums []int, left, right int) { for left \u0026lt; right { nums[left], nums[right] = nums[right], nums[left] left++ right-- } }","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:4:3","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，其中 n 是数组 nums 的长度（最多三次遍历）。 空间复杂度：O(1)O (1)O(1)，我们只使用了常数级别的额外空间（几个变量和反转函数）。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:4:4","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"287. 寻找重复数 - Mid ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:5:0","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#287-寻找重复数---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:5:1","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 核心背景：数组→环形链表 数组长度为 n+1，元素范围是 [1,n]，可将数组视作索引→值的链表映射： 索引 i 的 “下一个节点” 是 nums[i]（比如 nums[0]=2，则 0 → 2；nums[2]=3，则 2 → 3）； 由于存在唯一重复数，这个链表必然形成环，且环的入口点就是重复的数（重复数对应多个索引指向它，是环的起点）。 快慢指针法（最优，O (n) 时间 + O (1) 空间） 核心逻辑（弗洛伊德龟兔赛跑算法，找环的入口）： 第一步（找相遇点）：慢指针（龟）每次走 1 步（slow = nums[slow]），快指针（兔）每次走 2 步（fast = nums[nums[fast]]），直到两者相遇（此时快指针走的步数是慢指针的 2 倍，且都在环内）； 第二步（找环入口）：重置慢指针到起点（slow=0），快慢指针均每次走 1 步，再次相遇的位置就是环的入口（即重复数）。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:5:2","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#核心思路-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func findDuplicate(nums []int) int { // 第一步：快慢指针找环内相遇点 slow, fast := 0, 0 for { slow = nums[slow] // 慢指针走1步 fast = nums[nums[fast]] // 快指针走2步 if slow == fast { break // 相遇，退出循环 } } // 第二步：重置慢指针到起点，同速找环入口（重复数） slow = 0 for slow != fast { slow = nums[slow] fast = nums[fast] } return slow // 相遇点即为重复数 }","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:5:3","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，快慢指针最多遍历两次数组。 空间复杂度：O(1)O (1)O(1)，仅使用了常数级别的额外空间（几个变量）。 ","date":"2026-02-11","objectID":"/posts/2026-02-11-trick/:5:4","tags":["Go","技巧","题解"],"title":"[Golang] LeetCode 热题 100 - 技巧","uri":"/posts/2026-02-11-trick/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"动态规划 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:0:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#动态规划"},{"categories":["算法","LeetCode"],"collections":null,"content":"70. 爬楼梯 - Easy ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:1:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#70-爬楼梯---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:1:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 递推公式： 爬到第 n 阶的方法数 = 爬到第 n-1 阶的方法数（最后一步爬 1 阶） + 爬到第 n-2 阶的方法数（最后一步爬 2 阶）； 即 dp[n] = dp[n-1] + dp[n-2]； 初始条件： dp[1] = 1（1 阶只有 1 种方法：爬 1 阶）； dp[2] = 2（2 阶有 2 种方法：1+1 或 2）； 空间优化：无需维护完整的 dp 数组，只需用两个变量记录 dp[n-1] 和 dp[n-2]，空间复杂度从 O (n) 降到 O (1)。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:1:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func climbStairs(n int) int { // 边界条件：n=1 或 n=2 直接返回结果 if n == 1 { return 1 } if n == 2 { return 2 } // 用两个变量代替dp数组，节省空间 prevPrev := 1 // 对应dp[n-2]，初始为dp[1] prev := 2 // 对应dp[n-1]，初始为dp[2] current := 0 // 对应dp[n] // 从3阶开始递推到n阶 for i := 3; i \u0026lt;= n; i++ { current = prevPrev + prev // dp[i] = dp[i-2] + dp[i-1] // 更新变量，为下一次循环准备 prevPrev = prev prev = current } return current }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:1:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，需要计算从 3 到 n 的每一阶的方法数； 空间复杂度：O(1)O (1)O(1)，只使用了常数个变量来存储状态。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:1:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"118. 杨辉三角 - Easy ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:2:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#118-杨辉三角---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:2:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 杨辉三角的核心规律： 第 i 行（从 0 开始）有 i+1 个元素； 每行的第一个和最后一个元素都是 1； 中间元素 row[j] = 上一行[j-1] + 上一行[j]（0 \u0026lt; j \u0026lt; len(row)-1）。 解题步骤： 初始化结果二维数组； 逐行生成： 第 0 行直接是 [1]； 从第 1 行开始，先初始化当前行为长度等于行号 + 1 的切片，首尾设为 1； 遍历中间位置，通过上一行的元素计算当前值； 将每行添加到结果数组中，最终返回。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:2:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func generate(numRows int) [][]int { // 初始化结果数组 res := make([][]int, numRows) if numRows == 0 { return res } // 生成第一行（索引0） res[0] = []int{1} // 从第二行开始逐行生成（索引从1到numRows-1） for i := 1; i \u0026lt; numRows; i++ { // 当前行的长度为 i+1 row := make([]int, i+1) // 首尾元素设为1 row[0], row[i] = 1, 1 // 计算中间元素：row[j] = 上一行[j-1] + 上一行[j] for j := 1; j \u0026lt; i; j++ { row[j] = res[i-1][j-1] + res[i-1][j] } // 将当前行加入结果数组 res[i] = row } return res }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:2:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(numRows2)O (numRows^2)O(numRows2)，需要生成 numRows 行，每行最多有 numRows 个元素； 空间复杂度：O(numRows2)O (numRows^2)O(numRows2)，结果数组存储了 numRows 行，每行最多 numRows 个元素。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:2:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"198. 打家劫舍 - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:3:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#198-打家劫舍---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:3:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 状态定义：dp[i] 表示前 i 间房屋能偷窃到的最高金额； 递推公式： 对于第 i 间房屋，有两种选择： 不偷：最高金额 = dp[i-1]（前 i-1 间的最高金额）； 偷：最高金额 = dp[i-2] + nums[i]（前 i-2 间的最高金额 + 当前房屋金额）； 因此 dp[i] = max(dp[i-1], dp[i-2] + nums[i])； 空间优化：无需维护完整的 dp 数组，只需用两个变量记录 dp[i-1] 和 dp[i-2]，空间复杂度从 O (n) 降至 O (1)。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:3:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 package main func rob(nums []int) int { n := len(nums) // 边界条件：空数组返回0 if n == 0 { return 0 } // 边界条件：只有1间房屋，直接返回该房屋金额 if n == 1 { return nums[0] } // 用两个变量替代dp数组，节省空间 prevPrev := nums[0] // 对应dp[i-2]，初始为dp[0] prev := max(nums[0], nums[1]) // 对应dp[i-1]，初始为dp[1] current := prev // 初始化当前最大值 // 从第3间房屋开始递推（索引2） for i := 2; i \u0026lt; n; i++ { // 递推公式：max(不偷当前房, 偷当前房) current = max(prev, prevPrev + nums[i]) // 更新变量，为下一次循环准备 prevPrev = prev prev = current } return current } // 辅助函数：返回两个整数的最大值（Go标准库无直接的int max函数） func max(a, b int) int { if a \u0026gt; b { return a } return b }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:3:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，需要遍历一次数组； 空间复杂度：O(1)O (1)O(1)，只使用了常数个变量来存储状态。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:3:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"279. 完全平方数 - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:4:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#279-完全平方数---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:4:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 状态定义：dp[i] 表示和为 i 的完全平方数的最少数量； 初始条件： dp[0] = 0（和为 0 无需任何数）； 其余 dp[i] 初始化为一个较大值（如 i，因为最坏情况是用 i 个 1 相加）； 递推公式： 对于每个 i，遍历所有小于等于 i 的完全平方数 j²，则 dp[i] = min(dp[i], dp[i-j²] + 1)； 含义：和为 i 的最少数量 = 「和为 i-j² 的最少数量 + 1 个 j²」的最小值。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:4:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func numSquares(n int) int { // 初始化dp数组，dp[i]表示和为i的完全平方数的最少数量 dp := make([]int, n+1) // 初始化：最坏情况是用i个1相加，所以dp[i] = i for i := 1; i \u0026lt;= n; i++ { dp[i] = i } // 动态规划递推 for i := 2; i \u0026lt;= n; i++ { // 遍历所有小于等于i的完全平方数j² for j := 1; j*j \u0026lt;= i; j++ { square := j * j // 状态转移：dp[i] = min(当前值, dp[i-square]+1) if dp[i] \u0026gt; dp[i-square]+1 { dp[i] = dp[i-square] + 1 } } } return dp[n] }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:4:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(nn)O (n \\sqrt{n})O(nn​)； 空间复杂度：O(n)O (n)O(n)，dp 数组存储了从 0 到 n 的结果。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:4:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"322. 零钱兑换 - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:5:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#322-零钱兑换---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:5:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 状态定义：dp[i] 表示凑成金额 i 所需的最少硬币个数； 初始条件： dp[0] = 0（凑成金额 0 无需任何硬币）； 其余 dp[i] 初始化为一个 “无穷大” 值（比如 amount+1，因为最多需要 amount 个 1 元硬币，超过这个值即表示无法凑出）； 递推公式： 对于每个金额 i，遍历所有硬币面额 coin，若 coin ≤ i，则 dp[i] = min(dp[i], dp[i-coin] + 1)； 含义：凑成 i 的最少硬币数 = 「凑成 i-coin 的最少硬币数 + 1 枚 coin 硬币」的最小值； 结果判断：若最终 dp[amount] \u0026gt; amount，说明无法凑出，返回 -1；否则返回 dp[amount]。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:5:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func coinChange(coins []int, amount int) int { // 初始化dp数组，dp[i]表示凑成金额i的最少硬币数 // 初始值设为amount+1（表示\u0026#34;无穷大\u0026#34;，因为最多需要amount个1元硬币） dp := make([]int, amount+1) for i := 1; i \u0026lt;= amount; i++ { dp[i] = amount + 1 } dp[0] = 0 // 金额0需要0个硬币 // 遍历每个金额，从1到amount for i := 1; i \u0026lt;= amount; i++ { // 遍历所有硬币面额 for _, coin := range coins { // 只有当前硬币面额≤当前金额时，才有可能用来凑数 if coin \u0026lt;= i { // 状态转移：取\u0026#34;当前值\u0026#34;和\u0026#34;dp[i-coin]+1\u0026#34;的最小值 if dp[i] \u0026gt; dp[i-coin]+1 { dp[i] = dp[i-coin] + 1 } } } } // 若dp[amount]仍大于amount，说明无法凑出，返回-1；否则返回dp[amount] if dp[amount] \u0026gt; amount { return -1 } return dp[amount] }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:5:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(amount×m)O (amount \\times m)O(amount×m)，其中 m 是 coins 数组的长度； 空间复杂度：O(amount)O (amount)O(amount)，dp 数组存储了从 0 到 amount 的结果。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:5:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"139. 单词拆分 - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:6:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#139-单词拆分---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:6:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 状态定义：dp[i] 表示字符串 s 的前 i 个字符（即 s[0:i]）能否被字典中的单词拼接而成； 初始条件：dp[0] = true（空字符串可以被拼接，作为递推的基础）； 递推逻辑： 遍历每个位置 i（表示前 i 个字符），再遍历每个分割点 j（0 ≤ j \u0026lt; i）； 若 dp[j] = true（前 j 个字符可拼接）且 s[j:i] 存在于字典中，则 dp[i] = true； 优化：将 wordDict 转为哈希集合，使 s[j:i] 的查询时间从 O (m)（m 为字典长度）降至 O (1)。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:6:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func wordBreak(s string, wordDict []string) bool { n := len(s) // 1. 将字典转为哈希集合，优化查询效率 wordSet := make(map[string]bool) for _, word := range wordDict { wordSet[word] = true } // 2. 初始化dp数组：dp[i]表示s[0:i]能否被拼接 dp := make([]bool, n+1) dp[0] = true // 空字符串可拼接 // 3. 动态规划递推 for i := 1; i \u0026lt;= n; i++ { // 遍历所有可能的分割点j for j := 0; j \u0026lt; i; j++ { // 若前j个字符可拼接，且s[j:i]在字典中 → 前i个字符可拼接 if dp[j] \u0026amp;\u0026amp; wordSet[s[j:i]] { dp[i] = true break // 找到一个分割方式即可，无需继续遍历 } } } return dp[n] }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:6:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n2)O (n^2)O(n2)，外层循环 O(n)O (n)O(n)，内层循环 O(n)O (n)O(n)，字典查询 O(1)O (1)O(1)； 空间复杂度：O(n+m)O (n + m)O(n+m)，dp 数组占 O(n)O (n)O(n)，字典集合占 O(m)O (m)O(m)。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:6:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"300. 最长递增子序列 - Mid 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:7:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#300-最长递增子序列---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 基础动态规划思路（入门首选） 状态定义：dp[i] 表示以 nums[i] 为结尾的最长严格递增子序列的长度； 初始条件：所有 dp[i] = 1（每个元素自身是长度为 1 的子序列）； 递推公式：对于每个 i，遍历 j \u0026lt; i，若 nums[j] \u0026lt; nums[i]，则 dp[i] = max(dp[i], dp[j]+1)； 结果：遍历 dp 数组取最大值。 贪心 + 二分优化思路（最优解法） 核心思想：维护一个 “最小末尾数组”tails，tails[k] 表示长度为 k+1 的严格递增子序列的最小末尾值； 贪心：要让子序列尽可能长，需让末尾值尽可能小，这样后续更容易接更大的数； 二分：遍历每个数，用二分查找确定其在 tails 中的位置，更新 tails； 结果：tails 数组的长度即为最长严格递增子序列的长度。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:7:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func lengthOfLIS(nums []int) int { n := len(nums) if n == 0 { return 0 } // dp[i] 表示以nums[i]结尾的最长严格递增子序列长度 dp := make([]int, n) // 初始化：每个元素自身是长度为1的子序列 for i := range dp { dp[i] = 1 } maxLen := 1 // 至少有一个元素，初始为1 // 递推计算dp数组 for i := 1; i \u0026lt; n; i++ { for j := 0; j \u0026lt; i; j++ { // 严格递增，nums[j] \u0026lt; nums[i] if nums[j] \u0026lt; nums[i] { if dp[j]+1 \u0026gt; dp[i] { dp[i] = dp[j] + 1 } } } // 更新最大长度 if dp[i] \u0026gt; maxLen { maxLen = dp[i] } } return maxLen }优化版 func lengthOfLIS(nums []int) int { n := len(nums) if n == 0 { return 0 } // tails：长度为k+1的严格递增子序列的最小末尾值 tails := make([]int, 0, n) tails = append(tails, nums[0]) for i := 1; i \u0026lt; n; i++ { num := nums[i] // 情况1：当前数大于tails最后一个元素，直接追加（子序列长度+1） if num \u0026gt; tails[len(tails)-1] { tails = append(tails, num) } else { // 情况2：二分查找找到第一个≥num的位置，替换为num（保持tails最小末尾特性） left, right := 0, len(tails)-1 for left \u0026lt; right { mid := left + (right-left)/2 if tails[mid] \u0026lt; num { left = mid + 1 } else { right = mid } } tails[left] = num } } // tails的长度即为最长严格递增子序列的长度 return len(tails) }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:7:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 基础动态规划解法： 时间复杂度：O(n2)O (n^2)O(n2)，双重循环； 空间复杂度：O(n)O (n)O(n)，dp 数组存储了每个位置的结果。 贪心 + 二分优化解法： 时间复杂度：O(nlog⁡n)O (n \\log n)O(nlogn)，外层循环 O(n)O (n)O(n)，内层二分查找 O(log⁡n)O (\\log n)O(logn)； 空间复杂度：O(n)O (n)O(n)，tails 数组在最坏情况下可能存储所有元素。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:7:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"152. 乘积最大子数组 - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:8:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#152-乘积最大子数组---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 请注意，一个只包含一个元素的数组的乘积是这个元素的值。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:8:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心难点是负数的存在：负数相乘会让小值变最大值、大值变最小值，因此不能只维护 “最大乘积”，还需维护 “最小乘积”： 状态定义： curMax：以当前元素结尾的连续子数组的最大乘积； curMin：以当前元素结尾的连续子数组的最小乘积； 递推逻辑： 遍历每个元素时，先临时保存当前 curMax（避免更新后被覆盖）； 新的 curMax = max (当前元素，原 curMax× 当前元素，原 curMin× 当前元素)； 新的 curMin = min (当前元素，原 curMax× 当前元素，原 curMin× 当前元素)； 同时维护全局 maxProduct，记录遍历过程中的最大乘积； 初始条件：curMax、curMin、maxProduct 均初始化为数组第一个元素。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:8:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func maxProduct(nums []int) int { n := len(nums) if n == 0 { return 0 } // 初始化：当前最大/最小乘积、全局最大乘积均为第一个元素 curMax := nums[0] curMin := nums[0] maxProduct := nums[0] // 从第二个元素开始遍历 for i := 1; i \u0026lt; n; i++ { num := nums[i] // 临时保存当前curMax，避免更新curMax后影响curMin的计算 tempMax := curMax // 更新当前最大乘积：三种选择→仅当前元素、当前元素×之前最大、当前元素×之前最小 curMax = max(num, max(tempMax*num, curMin*num)) // 更新当前最小乘积：三种选择→仅当前元素、当前元素×之前最大、当前元素×之前最小 curMin = min(num, min(tempMax*num, curMin*num)) // 更新全局最大乘积 if curMax \u0026gt; maxProduct { maxProduct = curMax } } return maxProduct } // 辅助函数：返回两个整数的最大值 func max(a, b int) int { if a \u0026gt; b { return a } return b } // 辅助函数：返回两个整数的最小值 func min(a, b int) int { if a \u0026lt; b { return a } return b }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:8:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，只需遍历一次数组； 空间复杂度：O(1)O (1)O(1)，只使用了常数个变量来存储状态。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:8:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"416. 分割等和子集 - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:9:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#416-分割等和子集---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:9:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题可转化为0-1 背包问题： 问题转化： 首先计算数组总和 sum，若 sum 为奇数，直接返回 false（无法拆分为两个和相等的子集）； 若 sum 为偶数，目标变为 “是否能从数组中选出若干元素，使其和等于 sum/2”（即背包容量为 target = sum/2，每个元素只能选一次）。 动态规划思路： 状态定义：dp[j] 表示能否凑出和为 j 的子集（dp[j] = true 表示可以）； 初始条件：dp[0] = true（和为 0 无需选任何元素，一定可以）； 递推逻辑：遍历每个元素 num，从后往前遍历背包容量 j（避免重复选元素），若 j ≥ num，则 dp[j] = dp[j] || dp[j-num]（不选当前元素 或 选当前元素）； 结果：最终判断 dp[target] 是否为 true。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:9:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func canPartition(nums []int) bool { // 1. 计算数组总和 sum := 0 for _, num := range nums { sum += num } // 总和为奇数，无法分割为两个和相等的子集 if sum%2 != 0 { return false } target := sum / 2 // 目标子集和 // 2. 初始化dp数组：dp[j]表示能否凑出和为j的子集 dp := make([]bool, target+1) dp[0] = true // 和为0一定可以凑出 // 3. 0-1背包：遍历每个元素，从后往前更新dp for _, num := range nums { // 逆序遍历：避免同一元素被重复选取 for j := target; j \u0026gt;= num; j-- { dp[j] = dp[j] || dp[j-num] } // 提前终止：已找到符合条件的子集，无需继续遍历 if dp[target] { return true } } return dp[target] }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:9:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n×target)O (n \\times target)O(n×target)，其中 n 是数组长度，target 是 sum/2； 空间复杂度：O(target)O (target)O(target)，dp 数组存储了从 0 到 target 的结果。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:9:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"32. 最长有效括号 - Hard ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:10:0","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#32-最长有效括号---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个只包含 \u0026lsquo;(\u0026rsquo; 和 \u0026lsquo;)\u0026rsquo; 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。 左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 \u0026ldquo;(()())\u0026quot;。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:10:1","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#题目回顾-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 有效括号的核心是 “匹配”，且要求子串连续，因此需要跟踪有效子串的起始位置： 栈解法（入门首选） 核心思路：用栈记录 “未匹配括号的下标”，初始时压入 -1 作为有效子串的 “虚拟起始前一位”； 遍历逻辑： 遇到 (：压入当前下标； 遇到 )：弹出栈顶，若栈空则压入当前下标（更新虚拟起始位），否则计算当前有效长度（当前下标 - 栈顶值），更新最大值。 动态规划解法（最优） 状态定义：dp[i] 表示以 s[i] 结尾的最长有效括号子串长度； 递推逻辑： 仅当 s[i] = \u0026lsquo;)\u0026rsquo; 时才可能有有效子串； 若 s[i-1] = \u0026lsquo;(\u0026rsquo;：dp[i] = dp[i-2] + 2（直接匹配前一个左括号）； 若 s[i-1] = \u0026lsquo;)\u0026rsquo; 且 s[i - dp[i-1] - 1] = \u0026lsquo;(\u0026rsquo;：dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]（匹配更前面的左括号，且拼接前面的有效子串）； 初始条件：dp 数组全初始化为 0。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:10:2","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#核心思路-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func longestValidParentheses(s string) int { maxLen := 0 // 栈：存储未匹配括号的下标，初始压入-1作为有效子串的起始前一位 stack := []int{-1} for i := range s { if s[i] == \u0026#39;(\u0026#39; { // 左括号：压入当前下标 stack = append(stack, i) } else { // 右括号：弹出栈顶（尝试匹配） stack = stack[:len(stack)-1] if len(stack) == 0 { // 栈空：当前右括号无匹配，压入当前下标作为新的起始前一位 stack = append(stack, i) } else { // 计算当前有效长度，更新最大值 currentLen := i - stack[len(stack)-1] if currentLen \u0026gt; maxLen { maxLen = currentLen } } } } return maxLen }优化版 func longestValidParentheses(s string) int { n := len(s) if n \u0026lt; 2 { return 0 } maxLen := 0 // dp[i]：以s[i]结尾的最长有效括号长度 dp := make([]int, n) for i := 1; i \u0026lt; n; i++ { // 仅当当前字符是\u0026#39;)\u0026#39;时，才可能有有效子串 if s[i] == \u0026#39;)\u0026#39; { // 情况1：前一个字符是\u0026#39;(\u0026#39;，直接匹配 if s[i-1] == \u0026#39;(\u0026#39; { dp[i] = 2 // 拼接前面的有效子串（i-2 \u0026gt;=0 时） if i-2 \u0026gt;= 0 { dp[i] += dp[i-2] } } else if dp[i-1] \u0026gt; 0 { // 情况2：前一个字符是\u0026#39;)\u0026#39;，且前一个位置有有效子串 // 找到当前\u0026#39;)\u0026#39;对应的\u0026#39;(\u0026#39;的位置：i - dp[i-1] - 1 matchIdx := i - dp[i-1] - 1 if matchIdx \u0026gt;= 0 \u0026amp;\u0026amp; s[matchIdx] == \u0026#39;(\u0026#39; { dp[i] = dp[i-1] + 2 // 拼接matchIdx前面的有效子串 if matchIdx-1 \u0026gt;= 0 { dp[i] += dp[matchIdx-1] } } } // 更新最大长度 if dp[i] \u0026gt; maxLen { maxLen = dp[i] } } } return maxLen }","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:10:3","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#代码实现-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O (n)O(n)，只需遍历一次字符串； 空间复杂度：O(n)O (n)O(n)，栈或 dp 数组在最坏情况下可能存储所有元素。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-dp/:10:4","tags":["Go","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 动态规划","uri":"/posts/2026-02-10-dp/#复杂度分析-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"贪心算法 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:0:0","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#贪心算法"},{"categories":["算法","LeetCode"],"collections":null,"content":"121. 买卖股票的最佳时机 - Easy ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:1:0","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#121-买卖股票的最佳时机---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:1:1","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是找到 “最低买入价” 和 “该价格之后的最高卖出价”，暴力解法（双层循环找所有买卖组合）时间复杂度 O (n²) 会超时，最优的贪心思路： 遍历价格数组时，维护两个变量： minPrice：记录遍历到当前位置时的最低买入价格； maxProfit：记录遍历到当前位置时能获得的最大利润； 遍历过程中： 先更新 minPrice（取当前价格和 minPrice 的较小值）； 再计算当前价格卖出能获得的利润（当前价格 - minPrice），并更新 maxProfit（取当前利润和 maxProfit 的较大值）； 遍历结束后，maxProfit 即为最大利润（若为负数则返回 0）。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:1:2","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func maxProfit(prices []int) int { // 边界条件：数组长度小于2，无法买卖，直接返回0 if len(prices) \u0026lt; 2 { return 0 } // 初始化最小价格为第一个元素，最大利润为0 minPrice := prices[0] maxProfit := 0 // 遍历从第二个元素开始的所有价格 for i := 1; i \u0026lt; len(prices); i++ { // 1. 更新当前遇到的最低价格 if prices[i] \u0026lt; minPrice { minPrice = prices[i] } else { // 2. 计算当前价格卖出的利润，更新最大利润 currentProfit := prices[i] - minPrice if currentProfit \u0026gt; maxProfit { maxProfit = currentProfit } } } return maxProfit }","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:1:3","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O(n)O(n)，只需遍历一次价格数组。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:1:4","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"55. 跳跃游戏 - Medium ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:2:0","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#55-跳跃游戏---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:2:1","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是通过贪心策略维护 “当前能到达的最远位置”，暴力递归会超时，贪心是最优解： 遍历数组时，维护变量 maxReach，表示当前能到达的最远下标； 对于每个下标 i： 若 i 超过 maxReach，说明该位置无法到达，直接返回 false； 否则，更新 maxReach 为 max(maxReach, i + nums[i])（当前位置能跳到的最远位置）； 若 maxReach 已覆盖最后一个下标，可提前返回 true（优化）； 遍历结束后，判断 maxReach 是否 ≥ 最后一个下标。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:2:2","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func canJump(nums []int) bool { n := len(nums) // 边界条件：数组只有一个元素，已在最后一个下标，直接返回true if n == 1 { return true } // maxReach：当前能到达的最远下标 maxReach := 0 for i := 0; i \u0026lt; n; i++ { // 若当前下标超过能到达的最远位置，说明无法继续前进，返回false if i \u0026gt; maxReach { return false } // 更新能到达的最远位置 currentReach := i + nums[i] if currentReach \u0026gt; maxReach { maxReach = currentReach } // 提前终止：已能到达最后一个下标，无需继续遍历 if maxReach \u0026gt;= n-1 { return true } } // 遍历结束仍未到达最后一个下标 return false }","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:2:3","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O(n)O(n)，只需遍历一次数组。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:2:4","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"45. 跳跃游戏 II - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:3:0","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#45-跳跃游戏-ii---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。 每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处： 0 \u0026lt;= j \u0026lt;= nums[i] 且 i + j \u0026lt; n 返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:3:1","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是 “每一步都选择能跳得最远的位置”，从而最小化跳跃次数，贪心思路拆解： 维护三个核心变量： step：已跳跃的次数； curEnd：当前跳跃能到达的最远下标（当前步数的边界）； maxReach：遍历过程中能到达的全局最远下标； 遍历数组（不包含最后一个元素，因为到达最后一个下标无需再跳）： 每次更新 maxReach 为 max(maxReach, i + nums[i])； 当遍历到 curEnd 时，说明需要进行一次新的跳跃： step++（跳跃次数 + 1）； curEnd = maxReach（更新当前步数的边界为新的最远可达位置）； 遍历结束后，step 即为最小跳跃次数。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:3:2","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func jump(nums []int) int { n := len(nums) // 边界条件：数组长度为1，无需跳跃 if n == 1 { return 0 } step := 0 // 已跳跃次数 curEnd := 0 // 当前跳跃能到达的最远下标（步数边界） maxReach := 0 // 全局最远可达下标 // 遍历数组（不包含最后一个元素，到达最后一个下标无需再跳） for i := 0; i \u0026lt; n-1; i++ { // 更新全局最远可达下标 currentReach := i + nums[i] if currentReach \u0026gt; maxReach { maxReach = currentReach } // 遍历到当前步数的边界，需要跳一次 if i == curEnd { step++ curEnd = maxReach // 更新下一步的边界 // 提前终止：已能到达最后一个下标 if curEnd \u0026gt;= n-1 { break } } } return step }","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:3:3","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O(n)O(n)，只需遍历一次数组。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:3:4","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"763. 划分字母区间 - Mid ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:4:0","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#763-划分字母区间---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 \u0026ldquo;ababcc\u0026rdquo; 能够被分为 [\u0026ldquo;abab\u0026rdquo;, \u0026ldquo;cc\u0026rdquo;]，但类似 [\u0026ldquo;aba\u0026rdquo;, \u0026ldquo;bcc\u0026rdquo;] 或 [\u0026ldquo;ab\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;cc\u0026rdquo;] 的划分是非法的。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:4:1","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是通过 “记录字母最后出现位置 + 贪心扩展片段边界” 来划分： 预处理字母最后出现位置：遍历字符串，用数组 / 哈希表记录每个字符最后一次出现的下标； 贪心划分片段： 维护两个变量：start（当前片段起始下标）、end（当前片段的最远边界）； 遍历字符串，每次更新 end 为 “当前字符最后出现位置” 和 “当前 end” 的较大值； 当遍历到 end 时，说明当前片段已到边界，记录片段长度（end - start + 1），并更新 start 为 end + 1； 最终收集所有片段长度即为结果。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:4:2","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func partitionLabels(s string) []int { // 1. 预处理：记录每个字符最后出现的下标（小写字母共26个，用数组更高效） lastPos := [26]int{} for i := range s { // 转换字符为数组索引（a→0, b→1...z→25） lastPos[s[i]-\u0026#39;a\u0026#39;] = i } // 2. 贪心划分片段 var res []int start := 0 // 当前片段起始下标 end := 0 // 当前片段的最远边界 for i := range s { // 更新当前片段的最远边界 if lastPos[s[i]-\u0026#39;a\u0026#39;] \u0026gt; end { end = lastPos[s[i]-\u0026#39;a\u0026#39;] } // 遍历到片段边界，记录长度并更新起始位置 if i == end { res = append(res, end-start+1) start = end + 1 } } return res }","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:4:3","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O(n)O(n)，其中 nnn 是字符串长度。预处理和划分片段都需要遍历字符串一次。 空间复杂度：O(1)O(1)O(1)，因为字符集固定为小写字母，使用了常数级别的额外空间。 ","date":"2026-02-10","objectID":"/posts/2026-02-10-greedy/:4:4","tags":["Go","贪心算法","题解"],"title":"[Golang] LeetCode 热题 100 - 贪心算法","uri":"/posts/2026-02-10-greedy/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"堆 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:0:0","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#堆"},{"categories":["算法","LeetCode"],"collections":null,"content":"215. 数组中的第 K 个最大元素 - Medium ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:1:0","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#215-数组中的第-k-个最大元素---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:1:1","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是用快速选择算法（快速排序的变种）在 O (n) 平均时间复杂度内找到第 k 大元素，核心思路： 第 k 大元素等价于数组升序排序后第 nums.length - k 小的元素，将问题转化为找第 nums.length - k 小的元素； 快速选择的核心是 partition（分区）：选择基准值，将数组分为 “小于基准” 和 “大于基准” 两部分，返回基准值的索引； 若基准索引等于目标索引 k，直接返回该值；若基准索引大于 k，递归左区间；否则递归右区间； 优化点：提前判断区间是否已有序，若有序则直接返回目标索引值，减少不必要的分区操作。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:1:2","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func findKthLargest(nums []int, k int) int { // 第k大元素 = 升序后第 len(nums)-k 小的元素 target := len(nums) - k return quickSelect(nums, 0, len(nums)-1, target) } // quickSelect 快速选择：找到 [left, right] 区间内第 k 小的元素 func quickSelect(nums []int, left, right, k int) int { // 区间只有一个元素，直接返回 if left == right { return nums[left] } // 优化：提前判断区间是否已有序，有序则直接返回目标值 ordered := true for i := left; i \u0026lt; right; i++ { if nums[i] \u0026gt; nums[i+1] { ordered = false break } } if ordered { return nums[k] } // 分区操作，返回基准值的索引 p := partition(nums, left, right) // 根据基准索引递归查找 if p == k { return nums[p] } else if p \u0026gt; k { return quickSelect(nums, left, p-1, k) } else { return quickSelect(nums, p+1, right, k) } } // partition 分区函数：以右边界为基准，将小于基准的元素移到左侧，返回基准最终索引 func partition(nums []int, left, right int) int { pivot := nums[right] // 选择右边界为基准值 i := left - 1 // 小于基准的区域边界 // 遍历 [left, right-1] 区间 for j := left; j \u0026lt; right; j++ { if nums[j] \u0026lt; pivot { i++ swap(nums, i, j) // 交换到小于基准的区域 } } // 将基准值放到正确位置（小于基准的区域右侧） i++ swap(nums, i, right) return i } // swap 交换数组中两个位置的元素 func swap(nums []int, i, j int) { nums[i], nums[j] = nums[j], nums[i] }","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:1:3","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：平均 O(n)O(n)O(n)，最坏情况 O(n2)O(n^2)O(n2)（每次分区都极端不平衡）。 空间复杂度：O(1)O(1)O(1)，原地分区操作。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:1:4","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"347. 前 K 个高频元素 - Medium ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:2:0","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#347-前-k-个高频元素---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:2:1","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是 “统计频率 + 筛选高频元素”，暴力解法（排序所有频率）时间复杂度 O (n log n)，最优解法是小顶堆： 哈希表统计频率：遍历数组，用 map 记录每个数字的出现次数； 小顶堆筛选前 k 高： 遍历哈希表，将元素和频率加入堆中； 若堆的大小超过 k，弹出堆顶（频率最小的元素），保证堆中始终是当前频率前 k 高的元素； 提取结果：遍历堆，取出所有元素即为答案（顺序可任意）。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:2:2","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 import \u0026#34;container/heap\u0026#34; // 定义小顶堆的元素结构：包含数字和对应的频率 type Item struct { num int count int } // 定义小顶堆类型，底层是 Item 切片 type MinHeap []Item // 实现 heap.Interface 接口的 Len 方法：返回堆的大小 func (h MinHeap) Len() int { return len(h) } // 实现 heap.Interface 接口的 Less 方法：小顶堆的比较逻辑（count 小的优先） func (h MinHeap) Less(i, j int) bool { return h[i].count \u0026lt; h[j].count } // 实现 heap.Interface 接口的 Swap 方法：交换两个元素的位置 func (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } // 实现 heap.Interface 接口的 Push 方法：向堆中添加元素 func (h *MinHeap) Push(x interface{}) { *h = append(*h, x.(Item)) } // 实现 heap.Interface 接口的 Pop 方法：从堆中弹出最小元素 func (h *MinHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x } // topKFrequent 主函数：找出前 k 个高频元素 func topKFrequent(nums []int, k int) []int { // 1. 统计每个数字的出现频率 freqMap := make(map[int]int) for _, num := range nums { freqMap[num]++ } // 2. 初始化小顶堆 minHeap := \u0026amp;MinHeap{} heap.Init(minHeap) // 3. 遍历频率 map，维护大小为 k 的小顶堆 for num, count := range freqMap { heap.Push(minHeap, Item{num: num, count: count}) // 堆大小超过 k 时，弹出最小频率的元素 if minHeap.Len() \u0026gt; k { heap.Pop(minHeap) } } // 4. 提取堆中的元素作为结果 result := make([]int, k) for i := 0; i \u0026lt; k; i++ { item := heap.Pop(minHeap).(Item) result[k-1-i] = item.num // 倒序填充（也可正序，题目允许任意顺序） } return result }","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:2:3","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(nlog⁡k)O(n \\log k)O(nlogk)，其中 n 是数组长度，k 是需要返回的高频元素数量。 空间复杂度：O(n)O(n)O(n)，哈希表存储频率，堆中最多存储 k 个元素。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:2:4","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"295. 数据流的中位数 - Hard ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:3:0","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#295-数据流的中位数---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。 例如 arr = [2,3,4] 的中位数是 3 。 例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。 实现 MedianFinder 类: MedianFinder() 初始化 MedianFinder 对象。 void addNum(int num) 将数据流中的整数 num 添加到数据结构中。 double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:3:1","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 数据流的中位数需要支持 “动态添加” 和 “快速查询”，普通排序的方法时间复杂度太高（O (n log n) 每次添加），双堆法是最优解： 大顶堆（左堆）：存储数据流中较小的一半元素，堆顶是这一半的最大值； 小顶堆（右堆）：存储数据流中较大的一半元素，堆顶是这一半的最小值； 堆的平衡规则： 左堆大小 = 右堆大小 或 左堆大小 = 右堆大小 + 1； 添加元素时，先根据大小加入对应堆，再调整堆的大小以满足平衡规则； 查询中位数： 若总元素数为奇数：左堆顶就是中位数； 若为偶数：(左堆顶 + 右堆顶) / 2 就是中位数。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:3:2","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 import \u0026#34;container/heap\u0026#34; // -------------------------- 大顶堆实现 -------------------------- // MaxHeap 大顶堆，底层是 int 切片 type MaxHeap []int func (h MaxHeap) Len() int { return len(h) } func (h MaxHeap) Less(i, j int) bool { return h[i] \u0026gt; h[j] } // 大顶堆：值大的优先 func (h MaxHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *MaxHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x } // -------------------------- 小顶堆实现 -------------------------- // MinHeap 小顶堆，底层是 int 切片 type MinHeap []int func (h MinHeap) Len() int { return len(h) } func (h MinHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } // 小顶堆：值小的优先 func (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *MinHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *MinHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x } // -------------------------- MedianFinder 实现 -------------------------- // MedianFinder 维护数据流中位数的结构体 type MedianFinder struct { left *MaxHeap // 左堆：大顶堆，存储较小的一半元素 right *MinHeap // 右堆：小顶堆，存储较大的一半元素 } // Constructor 初始化 MedianFinder 对象 func Constructor() MedianFinder { left := \u0026amp;MaxHeap{} right := \u0026amp;MinHeap{} heap.Init(left) heap.Init(right) return MedianFinder{ left: left, right: right, } } // AddNum 添加一个数字到数据流中 func (this *MedianFinder) AddNum(num int) { // 1. 先根据大小加入对应堆 if this.left.Len() == 0 || num \u0026lt;= (*this.left)[0] { heap.Push(this.left, num) // 小于等于左堆顶，加入左堆 } else { heap.Push(this.right, num) // 大于左堆顶，加入右堆 } // 2. 调整堆的平衡：保证 left.Len() == right.Len() 或 left.Len() = right.Len() + 1 if this.left.Len() \u0026gt; this.right.Len()+1 { // 左堆过大，弹出左堆顶到右堆 val := heap.Pop(this.left).(int) heap.Push(this.right, val) } else if this.right.Len() \u0026gt; this.left.Len() { // 右堆过大，弹出右堆顶到左堆 val := heap.Pop(this.right).(int) heap.Push(this.left, val) } } // FindMedian 查询当前数据流的中位数 func (this *MedianFinder) FindMedian() float64 { // 总元素数为奇数：左堆顶就是中位数 if this.left.Len() \u0026gt; this.right.Len() { return float64((*this.left)[0]) } // 总元素数为偶数：(左堆顶 + 右堆顶) / 2 return float64((*this.left)[0]+(*this.right)[0]) / 2.0 }","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:3:3","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：AddNum 操作 O(log⁡n)O (\\log n)O(logn)，FindMedian 操作 O(1)O (1)O(1)。 空间复杂度：O(n)O(n)O(n)，最坏情况下所有元素都在一个堆中。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-heap/:3:4","tags":["Go","堆","题解"],"title":"[Golang] LeetCode 热题 100 - 堆","uri":"/posts/2026-02-09-heap/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"栈 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:0:0","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#栈"},{"categories":["算法","LeetCode"],"collections":null,"content":"20. 有效的括号 - Easy ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:1:0","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#20-有效的括号---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:1:1","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是利用栈的 “后进先出” 特性验证括号的匹配性： 遍历字符串，遇到左括号（(/{/[）时入栈； 遇到右括号（)/}/]）时，检查栈是否为空（为空则无匹配的左括号，直接返回 false），再弹出栈顶元素，判断是否与当前右括号匹配； 若不匹配则返回 false，遍历结束后检查栈是否为空（不为空说明有未匹配的左括号）。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:1:2","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func isValid(s string) bool { // 用切片模拟栈，存储左括号（rune 兼容 Unicode，等价于 char） stack := []rune{} // 遍历字符串中的每个字符 for _, c := range s { switch c { // 左括号：入栈 case \u0026#39;(\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;[\u0026#39;: stack = append(stack, c) // 右括号：匹配检查 case \u0026#39;)\u0026#39;: // 栈为空 或 栈顶不是对应的左括号，返回false if len(stack) == 0 || stack[len(stack)-1] != \u0026#39;(\u0026#39; { return false } // 匹配成功，弹出栈顶（切片截断） stack = stack[:len(stack)-1] case \u0026#39;]\u0026#39;: if len(stack) == 0 || stack[len(stack)-1] != \u0026#39;[\u0026#39; { return false } stack = stack[:len(stack)-1] case \u0026#39;}\u0026#39;: if len(stack) == 0 || stack[len(stack)-1] != \u0026#39;{\u0026#39; { return false } stack = stack[:len(stack)-1] } } // 遍历结束后栈必须为空（无剩余左括号） return len(stack) == 0 }","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:1:3","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O(n)O(n)，其中 nnn 是字符串的长度。每个字符被访问一次，入栈和出栈操作都是 O(1)O(1)O(1)。 空间复杂度：O(n)O(n)O(n)，在最坏情况下（例如所有都是左括号）栈中会存储所有字符。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:1:4","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"155. 最小栈 - Easy 这道题要求实现一个能在常数时间 O(1) 内获取最小值的栈，核心思路是双栈法： 主栈：存储所有入栈的元素，实现常规的 push/pop/top 操作； 辅助栈：存储当前主栈中的最小值，遵循以下规则： push 时：若辅助栈为空，或新元素 ≤ 辅助栈栈顶，新元素入辅助栈； pop 时：若弹出的元素等于辅助栈栈顶，辅助栈也弹出栈顶； getMin 时：直接返回辅助栈栈顶元素（即当前最小值）。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:2:0","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#155-最小栈---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 // MinStack 定义最小栈结构体 type MinStack struct { stack []int // 主栈：存储所有元素 helper []int // 辅助栈：存储当前最小值 } // Constructor 初始化最小栈（LeetCode 会调用此方法） func Constructor() MinStack { return MinStack{ stack: make([]int, 0), helper: make([]int, 0), } } // Push 入栈操作 func (this *MinStack) Push(val int) { // 主栈始终入栈 this.stack = append(this.stack, val) // 辅助栈：为空 或 新值≤栈顶，才入栈 if len(this.helper) == 0 || val \u0026lt;= this.helper[len(this.helper)-1] { this.helper = append(this.helper, val) } } // Pop 出栈操作 func (this *MinStack) Pop() { // 主栈为空时直接返回（防御性编程） if len(this.stack) == 0 { return } // 弹出主栈栈顶元素 top := this.stack[len(this.stack)-1] this.stack = this.stack[:len(this.stack)-1] // 若弹出的是当前最小值，辅助栈也弹出 if top == this.helper[len(this.helper)-1] { this.helper = this.helper[:len(this.helper)-1] } } // Top 获取栈顶元素 func (this *MinStack) Top() int { // 题目保证调用 Top 时栈非空，此处可省略判空 return this.stack[len(this.stack)-1] } // GetMin 获取当前栈中的最小值 func (this *MinStack) GetMin() int { // 题目保证调用 GetMin 时栈非空，此处可省略判空 return this.helper[len(this.helper)-1] }","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:2:1","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：所有操作（Push、Pop、Top、GetMin）均为 O(1)O(1)O(1)。 空间复杂度：O(n)O(n)O(n)，其中 nnn 是主栈中的元素数量。在最坏情况下（例如所有元素都相同且是最小值）辅助栈也会存储所有元素。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:2:2","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"394. 字符串解码 - Medium ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:3:0","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#394-字符串解码---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 测试用例保证输出的长度不会超过 105。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:3:1","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 编码字符串的核心特点是嵌套结构（比如 3[a2[bc]]），因此需要用栈来处理层级关系： 数字栈：存储当前层级的重复次数 k； 字符串栈：存储当前层级未处理的前缀字符串； 遍历字符串时分三种情况处理： 遇到数字：拼接完整数字（处理多位数，如 123 [abc]）； 遇到左括号 [：将当前数字和前缀字符串分别入栈，然后重置临时变量； 遇到右括号 ]：弹出数字栈的重复次数 k 和字符串栈的前缀，将当前字符串重复 k 次后拼接到前缀后； 遇到普通字符：直接拼接到当前临时字符串。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:3:2","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 import ( \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) func decodeString(s string) string { // 数字栈：存储每一层的重复次数 numStack := []int{} // 字符串栈：存储每一层的前缀字符串 strStack := []string{} // 当前拼接的数字（处理多位数，如 123） curNum := 0 // 当前拼接的字符串 curStr := \u0026#34;\u0026#34; // 遍历每个字符 for _, c := range s { switch { // 情况1：遇到数字，拼接完整数字 case c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;: // 转换为整数，处理多位数（如 \u0026#34;123\u0026#34; → 1*100 + 2*10 + 3） num, _ := strconv.Atoi(string(c)) curNum = curNum*10 + num // 情况2：遇到左括号，入栈并重置临时变量 case c == \u0026#39;[\u0026#39;: numStack = append(numStack, curNum) strStack = append(strStack, curStr) curNum = 0 // 重置数字 curStr = \u0026#34;\u0026#34; // 重置字符串 // 情况3：遇到右括号，拼接重复字符串 case c == \u0026#39;]\u0026#39;: // 弹出当前层的重复次数和前缀字符串 repeat := numStack[len(numStack)-1] numStack = numStack[:len(numStack)-1] prevStr := strStack[len(strStack)-1] strStack = strStack[:len(strStack)-1] // 将当前字符串重复 repeat 次，拼接到前缀后 curStr = prevStr + strings.Repeat(curStr, repeat) // 情况4：普通字符，直接拼接 default: curStr += string(c) } } return curStr }","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:3:3","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n⋅k)O(n \\cdot k)O(n⋅k)，其中 nnn 是输入字符串的长度，kkk 是重复次数的平均值。最坏情况下（例如 \u0026ldquo;100[a]\u0026quot;）需要重复字符串 100 次。 空间复杂度：O(n)O(n)O(n)，主要用于栈的存储和最终解码字符串的空间。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:3:4","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"739. 每日温度 - Medium ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:4:0","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#739-每日温度---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个整数数组 temperatures，表示每天的温度，返回一个数组 answer，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:4:1","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是找到每个元素右侧第一个更大的元素的索引差，暴力解法（双层循环）时间复杂度 O (n²) 会超时，最优解法是单调栈： 单调栈：存储数组索引，保证栈内索引对应的温度单调递减； 遍历温度数组时，对于当前索引 i： 若栈不为空且当前温度 \u0026gt; 栈顶索引对应的温度：弹出栈顶索引 top，计算 i - top 即为 top 位置的答案； 重复上述步骤直到栈为空或当前温度 ≤ 栈顶温度； 将当前索引 i 入栈； 遍历结束后，栈内剩余索引的答案均为 0（无更高温度）。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:4:2","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func dailyTemperatures(temperatures []int) []int { n := len(temperatures) // 初始化答案数组，默认值为0 answer := make([]int, n) // 单调栈：存储温度数组的索引，保证栈内索引对应温度单调递减 stack := []int{} // 遍历每个温度 for i := 0; i \u0026lt; n; i++ { // 栈不为空 且 当前温度 \u0026gt; 栈顶索引对应的温度 → 找到更高温度 for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; temperatures[i] \u0026gt; temperatures[stack[len(stack)-1]] { // 弹出栈顶索引 top := stack[len(stack)-1] stack = stack[:len(stack)-1] // 计算天数差 answer[top] = i - top } // 当前索引入栈 stack = append(stack, i) } return answer }","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:4:3","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O(n)O(n)，每个元素最多被入栈和出栈一次。 空间复杂度：O(n)O(n)O(n)，最坏情况下（例如单调递减的温度数组）栈中会存储所有索引。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:4:4","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"84. 柱状图中最大的矩形 - Hard ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:5:0","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#84-柱状图中最大的矩形---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:5:1","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是找到每个柱子作为高度时，能向左右延伸的最大宽度（即左右第一个比它矮的柱子的位置），面积 = 高度 × 宽度。暴力解法（遍历每个柱子找左右边界）时间复杂度 O (n²) 会超时，单调栈是最优解： 单调递增栈：存储柱子索引，保证栈内索引对应的高度单调递增； 遍历每个柱子时，若当前高度 \u0026lt; 栈顶高度，说明找到了栈顶柱子的右边界（当前索引），左边界是新的栈顶索引（栈空则为 -1）； 计算栈顶柱子的面积，弹出栈顶，重复此过程直到栈空或当前高度 ≥ 栈顶高度； 遍历结束后，处理栈中剩余元素（右边界为数组长度）； 为简化边界处理，可在原数组末尾添加一个高度为 0 的 “哨兵” 柱子，确保所有元素都能被处理。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:5:2","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func largestRectangleArea(heights []int) int { // 1. 复制原数组并添加哨兵（高度0），简化边界处理 newHeights := make([]int, len(heights)+1) copy(newHeights, heights) newHeights[len(heights)] = 0 // 哨兵 // 2. 初始化单调栈（存储索引）和最大面积 stack := []int{} maxArea := 0 // 3. 遍历所有柱子（含哨兵） for i := 0; i \u0026lt; len(newHeights); i++ { // 栈不为空 且 当前高度 \u0026lt; 栈顶索引的高度 → 计算栈顶柱子的面积 for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; newHeights[i] \u0026lt; newHeights[stack[len(stack)-1]] { // 弹出栈顶索引（当前要计算的柱子） top := stack[len(stack)-1] stack = stack[:len(stack)-1] // 计算宽度：左边界是新栈顶（栈空则为-1），右边界是当前索引i width := i if len(stack) \u0026gt; 0 { width = i - stack[len(stack)-1] - 1 } // 计算面积并更新最大面积 area := newHeights[top] * width if area \u0026gt; maxArea { maxArea = area } } // 当前索引入栈（保持栈单调递增） stack = append(stack, i) } return maxArea }","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:5:3","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n)O(n)O(n)，每个元素最多被入栈和出栈一次。 空间复杂度：O(n)O(n)O(n)，最坏情况下（例如单调递增的柱子数组）栈中会存储所有索引。 ","date":"2026-02-09","objectID":"/posts/2026-02-09-stack/:5:4","tags":["Go","栈","题解"],"title":"[Golang] LeetCode 热题 100 - 栈","uri":"/posts/2026-02-09-stack/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"二分查找 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:0:0","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#二分查找"},{"categories":["算法","LeetCode"],"collections":null,"content":"35. 搜索插入位置 - Easy ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:1:0","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#35-搜索插入位置---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(logn)O(log n)O(logn) 的算法。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:1:1","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 为什么最后返回 left？ 当循环 left \u0026lt;= right 结束时，必然满足 left \u0026gt; right。 如果 target 大于数组中所有元素，left 会一直右移直到 len(nums)。 如果 target 小于数组中所有元素，right 会一直左移，最后 left 停在 0。 在中间某处没找到时，left 最终会停在第一个大于 target 的元素位置上，这正是插入点。 防止溢出的写法 在 Go（以及其他语言）中，写 mid = (left + right) / 2 在 left 和 right 很大时可能导致整数溢出。使用 mid = left + (right-left)/2 是一种更健壮、更地道的写法。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:1:2","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func searchInsert(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { // 使用这种方式防止 (left + right) 溢出 mid := left + (right-left)/2 if nums[mid] == target { // 找到目标值，直接返回索引 return mid } else if nums[mid] \u0026lt; target { // 目标值在右半部分，更新左边界 left = mid + 1 } else { // 目标值在左半部分，更新右边界 right = mid - 1 } } // 如果循环结束未找到，left 指向的正是它应该被插入的位置 return left }","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:1:3","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(logn)O(log n)O(logn)，每次迭代将搜索空间减半。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:1:4","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"74. 搜索二维矩阵 - Medium ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:2:0","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#74-搜索二维矩阵---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有以下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:2:1","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 坐标映射公式这是本题最关键的数学技巧。假设矩阵总共有 nnn 列：一维转二维：对于一维索引 idxidxidx，其在矩阵中的位置是 matrix[idx / n][idx % n]。二维转一维：对于坐标 (i,j)(i, j)(i,j)，其在一维序列中的位置是 idx = i * n + j。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:2:2","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 || len(matrix[0]) == 0 { return false } m, n := len(matrix), len(matrix[0]) left, right := 0, m*n-1 for left \u0026lt;= right { mid := left + (right-left)/2 // 核心技巧：将一维索引 mid 映射回二维坐标 (i, j) // 行号 i = mid / 列数 // 列号 j = mid % 列数 val := matrix[mid/n][mid%n] if val == target { return true } else if val \u0026lt; target { left = mid + 1 // 标准二分：跳跃式收缩 } else { right = mid - 1 } } return false }","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:2:3","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(log(m∗n))O(log(m * n))O(log(m∗n))，其中 mmm 和 nnn 分别是矩阵的行数和列数。每次迭代将搜索空间减半。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:2:4","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"34. 在排序数组中查找元素的第一个和最后一个位置 - Medium ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:3:0","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#34-在排序数组中查找元素的第一个和最后一个位置---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target 。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1] 。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:3:1","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 核心原理解析：如何“挤压”边界 普通的二分查找在发现 nums[mid] == target 时会立即返回。但在有重复元素的数组中，我们要继续探索： 寻找起始位置：即使找到了目标值，我们也不敢停，而是把 right 指针移到 mid - 1，强迫搜索区间向左半部分收缩，看看左边还有没有相同的数字。 寻找结束位置：同理，当发现目标值时，把 left 指针移到 mid + 1，强迫搜索区间向右半部分收缩。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:3:2","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func searchRange(nums []int, target int) []int { // 初始化结果 res := []int{-1, -1} if len(nums) == 0 { return res } // 1. 查找左边界 res[0] = findBound(nums, target, true) // 如果没找到左边界，说明目标值不存在，直接返回 if res[0] == -1 { return res } // 2. 查找右边界 res[1] = findBound(nums, target, false) return res } // findBound 辅助函数：isLeft 为 true 找第一个，false 找最后一个 func findBound(nums []int, target int, isLeft bool) int { left, right := 0, len(nums)-1 bound := -1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] == target { bound = mid if isLeft { // 找左边界：在左半部分继续挤压 right = mid - 1 } else { // 找右边界：在右半部分继续挤压 left = mid + 1 } } else if nums[mid] \u0026gt; target { right = mid - 1 } else { left = mid + 1 } } return bound }","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:3:3","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(logn)O(log n)O(logn)，其中 nnn 是数组的长度。我们进行了两次二分查找，每次的时间复杂度都是对数级别。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:3:4","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"33. 搜索旋转排序数组 - Medium ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:4:0","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#33-搜索旋转排序数组---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u0026lt;= k \u0026lt; nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], \u0026hellip;, nums[n-1], nums[0], nums[1], \u0026hellip;, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:4:1","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是在旋转过的有序数组中高效查找目标值，要求时间复杂度为 O (log n)，因此需要基于二分查找进行改造： 旋转后的数组特点：以中间点 mid 为界，[0, mid] 或 [mid, n-1] 必有一个子数组是有序的； 每次二分后，先判断哪一部分有序，再检查目标值是否在这个有序区间内： 若在，则在该有序区间内继续二分； 若不在，则去另一部分无序区间继续二分； 循环结束仍未找到目标值则返回 -1。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:4:2","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func search(nums []int, target int) int { n := len(nums) // 边界条件：空数组直接返回 -1 if n == 0 { return -1 } // 边界条件：只有一个元素，直接判断是否等于目标值 if n == 1 { if nums[0] == target { return 0 } return -1 } // 初始化左右指针 left, right := 0, n-1 // 二分查找核心循环 for left \u0026lt;= right { // 计算中间索引（避免 left+right 溢出，等价于 (left+right)/2） mid := left + (right-left)/2 // 找到目标值，直接返回索引 if nums[mid] == target { return mid } // 判断左半部分 [left, mid] 是否有序 if nums[left] \u0026lt;= nums[mid] { // 目标值在左半有序区间内 if nums[left] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid] { right = mid - 1 } else { // 目标值不在左半，去右半部分查找 left = mid + 1 } } else { // 右半部分 [mid, right] 有序 // 目标值在右半有序区间内 if nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[right] { left = mid + 1 } else { // 目标值不在右半，去左半部分查找 right = mid - 1 } } } return -1 }","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:4:3","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(logn)O(log n)O(logn)，每次迭代将搜索空间减半。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:4:4","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"153. 寻找旋转排序数组中的最小值 - Medium ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:5:0","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#153-寻找旋转排序数组中的最小值---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], \u0026hellip;, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], \u0026hellip;, a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:5:1","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心是在旋转排序数组中找到最小值，核心思路延续了旋转数组的二分特性： 若数组未旋转（nums[0] \u0026lt; nums[n-1]），直接返回第一个元素； 旋转数组的最小值是 “旋转点”，即满足 nums[mid] \u0026lt; nums[mid-1] 的位置，或 nums[mid] \u0026gt; nums[mid+1] 的下一个位置； 利用二分缩小范围：若左半部分有序（nums[0] \u0026lt; nums[mid]），说明最小值在右半部分；反之在左半部分； 循环中找到旋转点直接返回，未找到则返回初始值（应对数组只有 1 个元素的边界情况）。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:5:2","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#核心思路-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func findMin(nums []int) int { n := len(nums) // 数组未旋转，直接返回第一个元素 if nums[0] \u0026lt; nums[n-1] { return nums[0] } // 初始化结果为第一个元素（应对只有1个元素的情况） res := nums[0] left, right := 0, n-1 for left \u0026lt;= right { mid := left + (right-left)/2 // 避免溢出的mid计算方式 // 找到旋转点：当前元素比前一个小，说明是最小值 if mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid] \u0026lt; nums[mid-1] { return nums[mid] } // 找到旋转点：当前元素比后一个大，后一个是最小值 if mid \u0026lt; n-1 \u0026amp;\u0026amp; nums[mid] \u0026gt; nums[mid+1] { return nums[mid+1] } // 左半部分有序，最小值在右半部分 if nums[0] \u0026lt; nums[mid] { left = mid + 1 } else { // 右半部分有序，最小值在左半部分 right = mid - 1 } } return res }","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:5:3","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(logn)O(log n)O(logn)，每次迭代将搜索空间减半。 空间复杂度：O(1)O(1)O(1)，只使用了常数级别的额外空间。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:5:4","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"4. 寻找两个正序数组的中位数 - Hard ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:6:0","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#4-寻找两个正序数组的中位数---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:6:1","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#题目回顾-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的核心要求是在 O (log (m+n)) 时间复杂度内找到两个有序数组的中位数，核心思路是将中位数问题转化为找第 k 小元素的问题： 若两个数组总长度为奇数，中位数就是第 (m+n)/2 + 1 小的元素； 若为偶数，中位数是第 (m+n)/2 和 (m+n)/2 + 1 小的元素的平均值； 找第 k 小元素的递归逻辑： 每次从两个数组中各取前 k/2 个元素，比较末尾值，排除较小的那部分（这部分一定不包含第 k 小元素）； 缩小 k 的值（减去排除的元素个数），递归查找剩余部分； 递归终止条件：某个数组遍历完、k=1（取两数组当前首元素最小值）。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:6:2","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#核心思路-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { m, n := len(nums1), len(nums2) sum := m + n if sum%2 == 1 { // 奇数：找第 sum/2 + 1 小的元素 k := sum/2 + 1 return float64(findKthSmall(k, nums1, 0, m-1, nums2, 0, n-1)) } else { // 偶数：找第 sum/2 和 sum/2+1 小的元素取平均 k1 := sum / 2 k2 := sum/2 + 1 val1 := findKthSmall(k1, nums1, 0, m-1, nums2, 0, n-1) val2 := findKthSmall(k2, nums1, 0, m-1, nums2, 0, n-1) return float64(val1+val2) / 2.0 } } // findKthSmall 查找两个有序数组中第 k 小的元素 // start1/end1: nums1 的当前查找区间 // start2/end2: nums2 的当前查找区间 func findKthSmall(k int, nums1 []int, start1, end1 int, nums2 []int, start2, end2 int) int { // 终止条件1：nums1 已无元素，直接从 nums2 取第 k 个 if start1 \u0026gt; end1 { return nums2[start2+k-1] } // 终止条件2：nums2 已无元素，直接从 nums1 取第 k 个 if start2 \u0026gt; end2 { return nums1[start1+k-1] } // 终止条件3：k=1，取两个数组当前首元素的最小值 if k == 1 { return min(nums1[start1], nums2[start2]) } // 计算两个数组中要比较的位置（防止越界） i1 := min(start1+k/2-1, end1) i2 := min(start2+k/2-1, end2) // 排除较小的那部分元素，递归查找剩余部分 if nums1[i1] \u0026lt; nums2[i2] { excluded := i1 - start1 + 1 // 排除的元素个数 return findKthSmall(k-excluded, nums1, i1+1, end1, nums2, start2, end2) } else { excluded := i2 - start2 + 1 // 排除的元素个数 return findKthSmall(k-excluded, nums1, start1, end1, nums2, i2+1, end2) } } // min 辅助函数：返回两个整数的最小值 func min(a, b int) int { if a \u0026lt; b { return a } return b }","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:6:3","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#代码实现-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(log(m+n))O(log (m+n))O(log(m+n))，每次递归调用将 k 减半，最多递归 log (m+n) 次。 空间复杂度：O(log(m+n))O(log (m+n))O(log(m+n))，递归调用栈的空间复杂度，最坏情况下递归深度为 log (m+n)。 ","date":"2026-02-05","objectID":"/posts/2026-02-05-binary-search/:6:4","tags":["Go","二分查找","题解"],"title":"[Golang] LeetCode 热题 100 - 二分查找","uri":"/posts/2026-02-05-binary-search/#复杂度分析-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"回溯 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:0:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#回溯"},{"categories":["算法","LeetCode"],"collections":null,"content":"46. 全排列 - Medium ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:1:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#46-全排列---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:1:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 回溯算法可以抽象为一个决策树的遍历过程： 路径与选择列表 路径 (Path)：已经做出的选择（代码中的 path）。 选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。 终止条件 当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。 撤销选择 (Backtrack) 这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:1:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func permute(nums []int) [][]int { var res [][]int path := []int{} used := make([]bool, len(nums)) var backtrack func() backtrack = func() { // 终止条件：路径长度等于数组长度 if len(path) == len(nums) { // 注意：Go 中切片是引用传递，必须进行拷贝 temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) return } for i := 0; i \u0026lt; len(nums); i++ { // 如果该数字已经用过，跳过 if used[i] { continue } // 1. 做选择 used[i] = true path = append(path, nums[i]) // 2. 递归进入下一层 backtrack() // 3. 撤销选择（回溯） path = path[:len(path)-1] used[i] = false } } backtrack() return res }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:1:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n∗n!)O(n * n!)O(n∗n!)，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。 空间复杂度：O(n)O(n)O(n)，用于存储递归栈和路径。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:1:4","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"78. 子集 - Medium ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:2:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#78-子集---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:2:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 子集问题可以看作是在一棵多叉树上收集所有节点，而排列/组合问题通常只收集叶子节点。 为什么用 start 参数？ 在全排列中我们使用 used 数组，因为顺序不同是不同的排列。但在子集中，[1, 2] 和 [2, 1] 是同一个集合。为了去重，我们规定搜索顺序：只选取当前元素之后的元素。 拷贝的重要性 和全排列一样，res = append(res, temp) 这一步必须拷贝 path。Go 的切片底层共享数组，如果不拷贝，回溯操作会修改 res 中已经存储的内容。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:2:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func subsets(nums []int) [][]int { var res [][]int var path []int // 定义回溯函数，start 保证我们只往后看，避免重复 var backtrack func(start int) backtrack = func(start int) { // 1. 每一个节点都是一个子集，直接加入结果集 // 注意：必须进行深拷贝 temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) // 2. 遍历候选列表 for i := start; i \u0026lt; len(nums); i++ { // 做选择 path = append(path, nums[i]) // 递归：从当前元素的下一个开始，避免元素重复使用 backtrack(i + 1) // 撤销选择（回溯） path = path[:len(path)-1] } } backtrack(0) return res }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:2:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n∗2n)O(n * 2^n)O(n∗2n)，其中 n 是数组的长度。子集的数量是 2^n，每个子集需要 O(n) 的时间来构建和复制到结果中。 空间复杂度：O(n)O(n)O(n)，用于存储递归栈和路径。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:2:4","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"17. 电话号码的字母组合 - Medium ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:3:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#17-电话号码的字母组合---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:3:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 映射关系 我们建立了一个从数字字符（如 \u0026lsquo;2\u0026rsquo;）到字符串（如 \u0026ldquo;abc\u0026rdquo;）的映射。这决定了搜索每一层时的“分支数量”。 决策树结构 树的深度：由输入 digits 的长度决定。 每一层的宽度：由对应数字包含的字母数量（3 或 4 个）决定。 为什么不需要 used 数组？ 在全排列中，我们需要 used 来防止同一个元素被多次选取。但在电话组合中，由于每一层递归处理的是不同的数字集合，我们只需要一个 index 记录当前处理到 digits 的第几个字符，天然地保证了不会重复使用同一个位置。 代码实现 func letterCombinations(digits string) []string { if len(digits) == 0 { return nil } // 1. 定义数字与字母的映射表 phoneMap := map[byte]string{ \u0026#39;2\u0026#39;: \u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;: \u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;: \u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;: \u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;: \u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;: \u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;: \u0026#34;tuv\u0026#34;, \u0026#39;9\u0026#39;: \u0026#34;wxyz\u0026#34;, } var res []string var path []byte // 2. 定义回溯函数 var backtrack func(index int) backtrack = func(index int) { // 终止条件：路径长度等于输入数字的长度 if index == len(digits) { res = append(res, string(path)) return } // 取出当前数字对应的所有字母 digit := digits[index] letters := phoneMap[digit] // 遍历当前数字对应的每一个字母 for i := 0; i \u0026lt; len(letters); i++ { // 做选择 path = append(path, letters[i]) // 递归：处理下一个数字 backtrack(index + 1) // 撤销选择（回溯） path = path[:len(path)-1] } } backtrack(0) return res }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:3:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 映射关系 我们建立了一个从数字字符（如 \u0026lsquo;2\u0026rsquo;）到字符串（如 \u0026ldquo;abc\u0026rdquo;）的映射。这决定了搜索每一层时的“分支数量”。 决策树结构 树的深度：由输入 digits 的长度决定。 每一层的宽度：由对应数字包含的字母数量（3 或 4 个）决定。 为什么不需要 used 数组？ 在全排列中，我们需要 used 来防止同一个元素被多次选取。但在电话组合中，由于每一层递归处理的是不同的数字集合，我们只需要一个 index 记录当前处理到 digits 的第几个字符，天然地保证了不会重复使用同一个位置。 代码实现 func letterCombinations(digits string) []string { if len(digits) == 0 { return nil } // 1. 定义数字与字母的映射表 phoneMap := map[byte]string{ \u0026#39;2\u0026#39;: \u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;: \u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;: \u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;: \u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;: \u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;: \u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;: \u0026#34;tuv\u0026#34;, \u0026#39;9\u0026#39;: \u0026#34;wxyz\u0026#34;, } var res []string var path []byte // 2. 定义回溯函数 var backtrack func(index int) backtrack = func(index int) { // 终止条件：路径长度等于输入数字的长度 if index == len(digits) { res = append(res, string(path)) return } // 取出当前数字对应的所有字母 digit := digits[index] letters := phoneMap[digit] // 遍历当前数字对应的每一个字母 for i := 0; i \u0026lt; len(letters); i++ { // 做选择 path = append(path, letters[i]) // 递归：处理下一个数字 backtrack(index + 1) // 撤销选择（回溯） path = path[:len(path)-1] } } backtrack(0) return res }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:3:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(3m∗4n)O(3^m * 4^n)O(3m∗4n)，其中 m 是输入数字中对应 3 个字母的数字个数，n 是对应 4 个字母的数字个数。每个组合需要 O(m + n) 的时间来构建和复制到结果中。 空间复杂度：O(m+n)O(m + n)O(m+n)，用于存储递归栈和路径。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:3:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"39. 组合总和 - Medium ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:4:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#39-组合总和---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字 可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两个组合是不同的。对于给定的输入，保证和为 target 的不同组合数量少于 150 个。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:4:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 核心要点解析 如何实现“无限制重复选取”？ 在 dfs(\u0026hellip;, i) 这一步。 如果是 i + 1：代表每个元素只能选一次（如“子集”问题）。 如果是 i：代表在当前的决策树分支下，下一层依然可以从当前这个元素开始选，从而实现重复。 为什么需要 start 变量？ 为了去重。如果我们每一层都从索引 0 开始遍历，就会出现 [2, 2, 3] 和 [2, 3, 2]、[3, 2, 2] 这种由于顺序不同而产生的重复组合。通过 start 确保我们只选取“当前或之后”的元素，强制了结果集的顺序性。 剪枝优化 (Pruning) 在循环中，如果发现 remain - candidates[i] \u0026lt; 0，由于数组是升序的，后面的 candidates[i+1] 肯定也会让结果小于 0。直接 break 掉当前循环，可以减少大量的递归调用。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:4:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 import \u0026#34;sort\u0026#34; func combinationSum(candidates []int, target int) [][]int { var res [][]int var path []int // 1. 排序是为了后续的剪枝优化 sort.Ints(candidates) var backtrack func(remain int, start int) backtrack = func(remain int, start int) { // 终止条件：正好凑成目标金额 if remain == 0 { temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) return } // 从 start 开始遍历，避免产生 [2, 3] 和 [3, 2] 这种重复组合 for i := start; i \u0026lt; len(candidates); i++ { // 2. 剪枝：由于数组已排序，如果当前数字已大于剩余值，后续数字也一定大于 if remain - candidates[i] \u0026lt; 0 { break } // 做选择 path = append(path, candidates[i]) // 3. 递归：关键点在于传递 i 而不是 i + 1，表示当前数字可以重复使用 backtrack(remain - candidates[i], i) // 撤销选择（回溯） path = path[:len(path)-1] } } backtrack(target, 0) return res }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:4:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(2t)O(2^t)O(2t)，其中 t 是目标值 target。最坏情况下，每个数字都可以被多次选择，导致递归树的高度接近 t。 空间复杂度：O(t)O(t)O(t)，用于存储递归栈和路径。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:4:4","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"22. 括号生成 - Medium ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:5:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#22-括号生成---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数 n ，请你生成所有由 n 对括号组成的有效括号组合。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:5:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 有效性剪枝 生成有效括号的核心其实只有两条“潜规则”： 左括号优先：只要还没放满 nnn 个，随时可以放左括号 (。 右括号限制：右括号 ) 必须在有对应的左括号等待匹配时才能放。也就是说，当前已放的右括号数量必须严格小于左括号数量。 通过这两个简单的 if 限制，我们生成的每一条路径最终到达叶子节点时，都必然是一个完美的括号匹配字符串。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:5:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func generateParenthesis(n int) []string { var res []string var path []byte // left: 当前已使用的左括号数量 // right: 当前已使用的右括号数量 var backtrack func(left, right int) backtrack = func(left, right int) { // 终止条件：路径长度达到 2n if len(path) == 2*n { res = append(res, string(path)) return } // 核心规则 1：只要左括号没用完，就可以放左括号 if left \u0026lt; n { path = append(path, \u0026#39;(\u0026#39;) backtrack(left+1, right) path = path[:len(path)-1] // 回溯 } // 核心规则 2：只有当右括号数量小于左括号时，才能放右括号 // 这样可以保证任意时刻右括号都不会比左括号多（有效性保证） if right \u0026lt; left { path = append(path, \u0026#39;)\u0026#39;) backtrack(left, right+1) path = path[:len(path)-1] // 回溯 } } backtrack(0, 0) return res }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:5:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(4nn)O(\\frac{4^n}{\\sqrt{n}})O(n​4n​)，这是生成所有有效括号组合的卡特兰数复杂度。 空间复杂度：O(n)O(n)O(n)，用于存储递归栈和路径。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:5:4","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"79. 单词搜索 - Medium ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:6:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#79-单词搜索---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个 m x n 二维字符网格 board 和一个字符串单词 word ，如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:6:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 状态重置 (The \u0026ldquo;Back\u0026rdquo; in Backtracking)当你访问 board[i][j] 后，必须暂时标记它。如果不标记，搜索路径可能会在同一个格子上打转（例如单词是 ABA，路径可能在两个相邻的 A 和 B 之间反复横跳）。在 DFS 返回后，必须将 board[i][j] 改回原值，确保 下一轮从不同起点开始的搜索 能够正常使用这个格子。 通过 board[i][j] = \u0026lsquo;#\u0026rsquo; 这种原地修改法，将额外空间复杂度降到了 O(1)O(1)O(1)（不计递归栈空间）。这是面试中加分的优化技巧。 短路逻辑 (Short-circuiting)在 Go 实现中，res := dfs(\u0026hellip;) || dfs(\u0026hellip;) || \u0026hellip; 利用了逻辑或的短路特性。一旦第一个 dfs 返回 true，后面的方向就不会再执行，这比显式判断 if found { return } 更加简洁高效。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:6:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) // 定义 DFS 闭包 var dfs func(i, j, k int) bool dfs = func(i, j, k int) bool { // 1. 终止条件：匹配完单词所有字符 if k == len(word) { return true } // 2. 越界检查、字符不匹配检查 if i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n || board[i][j] != word[k] { return false } // 3. 标记当前单元格已访问（避免重复使用同一字母） // 这是一个地道的技巧：将其修改为一个非字母字符，省去 used 数组 temp := board[i][j] board[i][j] = \u0026#39;#\u0026#39; // 4. 向四个方向递归探索 // 只要有一个方向成功，就返回 true res := dfs(i+1, j, k+1) || dfs(i-1, j, k+1) || dfs(i, j+1, k+1) || dfs(i, j-1, k+1) // 5. 回溯：恢复现场 board[i][j] = temp return res } // 遍历起点 for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if board[i][j] == word[0] { if dfs(i, j, 0) { return true } } } } return false }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:6:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(m∗n∗3l)O(m * n * 3^l)O(m∗n∗3l)，其中 m 和 n 分别是网格的行数和列数，l 是单词的长度。每个单元格作为起点进行 DFS，最多有 3 个方向可选（因为不能回到来时的路）。 空间复杂度：O(l)O(l)O(l)，用于存储递归栈，最坏情况下递归深度为单词长度 l。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:6:4","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"131. 分割回文串 - Medium ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:7:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#131-分割回文串---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:7:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 决策树模型 每一层递归：代表在当前剩余字符串中选择一个前缀。 分支：如果前缀是回文，则进入下一层；如果不是，则剪枝（不继续往下走）。 路径收集：当指针移动到字符串末尾，说明找到了一种完整的分割方案。 状态重置 在 Go 中，path = path[:len(path)-1] 完成了回溯。这保证了在尝试不同的切割长度时，path 始终保持干净。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:7:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func partition(s string) [][]string { var res [][]string var path []string // backtrack 逻辑：从 index 开始尝试切割 var backtrack func(index int) backtrack = func(index int) { // 1. 终止条件：如果已经切到了字符串末尾 if index == len(s) { // 拷贝 path 存入结果 temp := make([]string, len(path)) copy(temp, path) res = append(res, temp) return } // 2. 尝试从 index 到 i 进行切割 for i := index; i \u0026lt; len(s); i++ { // 3. 剪枝：只有当前切割出的子串 [index, i] 是回文，才继续递归 if isPalindrome(s, index, i) { // 做选择 path = append(path, s[index:i+1]) // 递归：从 i+1 位置继续切割剩余字符串 backtrack(i + 1) // 撤销选择（回溯） path = path[:len(path)-1] } } } backtrack(0) return res } // 辅助函数：判断 s[left:right+1] 是否为回文 func isPalindrome(s string, left, right int) bool { for left \u0026lt; right { if s[left] != s[right] { return false } left++ right-- } return true }性能优化：动态规划预处理 在上面的代码中，isPalindrome 可能会被重复调用多次。如果面试官要求优化时间，我们可以先用 动态规划 预处理出一个二维数组 dp[i][j]，用来记录 s[i:j+1] 是否为回文。 func partition(s string) [][]string { n := len(s) // dp[i][j] 表示 s[i..j] 是否是回文 dp := make([][]bool, n) for i := range dp { dp[i] = make([]bool, n) } // 预处理回文状态 for j := 0; j \u0026lt; n; j++ { for i := 0; i \u0026lt;= j; i++ { if s[i] == s[j] \u0026amp;\u0026amp; (j-i \u0026lt;= 2 || dp[i+1][j-1]) { dp[i][j] = true } } } var res [][]string var path []string var backtrack func(int) backtrack = func(start int) { if start == n { res = append(res, append([]string(nil), path...)) return } for i := start; i \u0026lt; n; i++ { if dp[start][i] { path = append(path, s[start:i+1]) backtrack(i + 1) path = path[:len(path)-1] } } } backtrack(0) return res }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:7:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n∗2n)O(n * 2^n)O(n∗2n)，其中 n 是字符串的长度。最坏情况下，每个字符都可以单独成一个回文子串，导致组合数量达到 2^n。 空间复杂度：O(n)O(n)O(n)，用于存储递归栈和路径。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:7:4","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"51. N 皇后 - Hard ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:8:0","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#51-n-皇后---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 \u0026lsquo;Q\u0026rsquo; 和 \u0026lsquo;.\u0026rsquo; 分别代表了皇后和空位。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:8:1","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#题目回顾-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 处理行和列的冲突很简单，但处理斜线是这道题的精髓。 捺斜线 (Backslash )在同一条撇向斜线上，所有的坐标 (row,col)(row, col)(row,col) 都满足 row−colrow - colrow−col 是常数。例如：(0,0),(1,1),(2,2)(0,0), (1,1), (2,2)(0,0),(1,1),(2,2) 的差值都是 000。注意：差值可能为负，但 Go 的 map 支持负数 key。 撇斜线 (Slash /)在同一条正向斜线上，所有的坐标 (row,col)(row, col)(row,col) 都满足 row+colrow + colrow+col 是常数。例如：(0,2),(1,1),(2,0)(0,2), (1,1), (2,0)(0,2),(1,1),(2,0) 的和都是 222。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:8:2","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#核心思路-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func solveNQueens(n int) [][]string { var res [][]string // 棋盘初始化 board := make([][]byte, n) for i := range board { board[i] = make([]byte, n) for j := range board[i] { board[i][j] = \u0026#39;.\u0026#39; } } // 用于快速检查冲突的状态记录 cols := make(map[int]bool) // 列冲突 diag1 := make(map[int]bool) // 捺冲突 (\\): 行-列 = 定值 diag2 := make(map[int]bool) // 撇冲突 (/): 行+列 = 定值 var backtrack func(row int) backtrack = func(row int) { // 1. 终止条件：成功放置了 n 个皇后 if row == n { res = append(res, formatBoard(board)) return } // 2. 尝试在当前行的每一列放置皇后 for col := 0; col \u0026lt; n; col++ { // 3. 剪枝：检查当前位置是否会被之前的皇后攻击 if cols[col] || diag1[row-col] || diag2[row+col] { continue } // 4. 做选择 board[row][col] = \u0026#39;Q\u0026#39; cols[col], diag1[row-col], diag2[row+col] = true, true, true // 5. 进入下一行递归 backtrack(row + 1) // 6. 撤销选择（回溯） board[row][col] = \u0026#39;.\u0026#39; delete(cols, col) delete(diag1, row-col) delete(diag2, row+col) } } backtrack(0) return res } // 辅助函数：将二维 byte 棋盘转换为题目要求的字符串切片 func formatBoard(board [][]byte) []string { var s []string for _, row := range board { s = append(s, string(row)) } return s }","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:8:3","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#代码实现-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N!)O(N!)O(N!)，其中 N 是棋盘的大小。 每一行有 N 个选择，第二行有 N-1 个选择，依此类推，整体复杂度近似为 N!。 空间复杂度：O(N)O(N)O(N)，用于存储递归栈和棋盘状态。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-backtracking/:8:4","tags":["Go","回溯","题解"],"title":"[Golang] LeetCode 热题 100 - 回溯","uri":"/posts/2026-02-03-backtracking/#复杂度分析-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"图论 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:0:0","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#图论"},{"categories":["算法","LeetCode"],"collections":null,"content":"200. 岛屿数量 - Mid ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:1:0","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#200-岛屿数量---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个由 \u0026lsquo;1\u0026rsquo;（陆地）和 \u0026lsquo;0\u0026rsquo;（水）组成的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和竖直方向上相邻的陆地连接形成。你可以假设网格的四个边均被水包围。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:1:1","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 扫描：像扫描仪一样遍历每一个格点。 触发搜索：遇到 \u0026lsquo;1\u0026rsquo; 时，说明找到了一个岛屿。 消除影响：为了不重复计算同一个岛屿，必须在发现它的瞬间，通过 DFS 把这个岛屿所有的土地全部标记为 \u0026lsquo;0\u0026rsquo;。这就像是在地图上把发现的岛屿“涂黑”。 计数：触发 DFS 的次数，就是岛屿的总数。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:1:2","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func numIslands(grid [][]byte) int { if len(grid) == 0 { return 0 } m, n := len(grid), len(grid[0]) count := 0 // 遍历整个网格 for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { // 如果发现陆地 if grid[i][j] == \u0026#39;1\u0026#39; { dfs(grid, i, j) // 发现一个岛屿，计数加 1 count++ } } } return count } func dfs(grid [][]byte, i, j int) { m, n := len(grid), len(grid[0]) // 越界检查或遇到水（\u0026#39;0\u0026#39;），直接返回 if i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n || grid[i][j] == \u0026#39;0\u0026#39; { return } // 标记当前陆地已被访问（淹没），防止死循环 grid[i][j] = \u0026#39;0\u0026#39; // 向四个方向扩散 dfs(grid, i+1, j) // 下 dfs(grid, i-1, j) // 上 dfs(grid, i, j+1) // 右 dfs(grid, i, j-1) // 左 }","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:1:3","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(M∗N)O(M * N)O(M∗N)，其中 M 和 N 分别是网格的行数和列数。每个格点最多被访问一次。 空间复杂度：O(M∗N)O(M * N)O(M∗N)，在最坏情况下，递归栈的深度可能达到 M * N。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:1:4","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"994. 腐烂的橘子 - Mid ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:2:0","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#994-腐烂的橘子---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，任何与腐烂橘子（在 4 个正方向上相邻）的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:2:1","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 为什么是 BFS 而不是 DFS？ DFS 会一路深入，难以计算“最短时间”或“同步扩散”。而 BFS 就像是往水里丢石头产生的涟漪，每一圈代表一分钟。层序遍历 保证了我们找到的是最短传播路径。 终止条件 成功：freshCount == 0，所有橘子都烂了。 失败：队列空了但 freshCount \u0026gt; 0，说明有些橘子被隔离了。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:2:2","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func orangesRotting(grid [][]int) int { m, n := len(grid), len(grid[0]) freshCount := 0 queue := [][]int{} // 1. 扫描网格，记录新鲜橘子数量并将腐烂橘子入队 for r := 0; r \u0026lt; m; r++ { for c := 0; c \u0026lt; n; c++ { if grid[r][c] == 1 { freshCount++ } else if grid[r][c] == 2 { queue = append(queue, []int{r, c}) } } } // 如果一开始就没有新鲜橘子，直接返回 0 if freshCount == 0 { return 0 } minutes := 0 // 方向数组：上下左右 dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} // 2. 开始 BFS 扩散 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; freshCount \u0026gt; 0 { minutes++ // 记录当前层的橘子数量 size := len(queue) for i := 0; i \u0026lt; size; i++ { curr := queue[0] queue = queue[1:] r, c := curr[0], curr[1] for _, d := range dirs { nr, nc := r+d[0], c+d[1] // 如果相邻的是新鲜橘子 if nr \u0026gt;= 0 \u0026amp;\u0026amp; nr \u0026lt; m \u0026amp;\u0026amp; nc \u0026gt;= 0 \u0026amp;\u0026amp; nc \u0026lt; n \u0026amp;\u0026amp; grid[nr][nc] == 1 { grid[nr][nc] = 2 // 变腐烂 freshCount-- // 新鲜橘子减少 queue = append(queue, []int{nr, nc}) } } } } // 3. 如果还有新鲜橘子剩下来，说明无法全部腐烂，返回 -1 if freshCount \u0026gt; 0 { return -1 } return minutes }","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:2:3","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(M∗N)O(M * N)O(M∗N)，其中 M 和 N 分别是网格的行数和列数。每个格点最多被访问一次。 空间复杂度：O(M∗N)O(M * N)O(M∗N)，在最坏情况下，队列中可能存储所有的橘子。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:2:4","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"207. 课程表 - Mid ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:3:0","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#207-课程表---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:3:1","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 通用的解法是 Kahn 算法（广度优先搜索实现的拓扑排序）。它的核心逻辑是：不断消除入度为 0 的节点（即没有先修课限制的课程），如果最后所有课程都能被消除，说明图中没有环，可以修完。 关键概念 入度 (In-degree)：指向该节点的边的数量。在本项目中，代表“还需要修多少门先修课”。 出边 (Out-degree/Adjacency)：该节点指向其他节点的边。代表“修完这门课后，哪些课的限制会减少”。 执行流程 找起点：入度为 0 的课是安全的，可以直接上。 拆边：上一门课，就把由它发出的所有边删掉（即减少后继课的入度）。 循环：如果在这个过程中产生了新的入度为 0 的课，继续重复。 判定：如果图中存在环，环上的节点入度永远不会减到 0。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:3:2","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func canFinish(numCourses int, prerequisites [][]int) bool { // 1. 初始化入度数组和邻接表 inDegree := make([]int, numCourses) adjacency := make([][]int, numCourses) for _, pre := range prerequisites { course, preCourse := pre[0], pre[1] inDegree[course]++ adjacency[preCourse] = append(adjacency[preCourse], course) } // 2. 将所有入度为 0 的课程放入队列 queue := make([]int, 0) for i := 0; i \u0026lt; numCourses; i++ { if inDegree[i] == 0 { queue = append(queue, i) } } // 已学习的课程数量 count := 0 // 3. 开始 BFS 拓扑排序 for len(queue) \u0026gt; 0 { curr := queue[0] queue = queue[1:] count++ // 遍历当前课程的所有后继课程 for _, nextCourse := range adjacency[curr] { inDegree[nextCourse]-- // 如果后继课程的入度减为 0，说明先修课都上完了，入队 if inDegree[nextCourse] == 0 { queue = append(queue, nextCourse) } } } // 4. 如果学完的课程等于总课程数，说明无环 return count == numCourses }","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:3:3","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(V+E)O(V + E)O(V+E)，其中 V 是课程数（节点），E 是先修关系数（边）。 空间复杂度：O(V+E)O(V + E)O(V+E)，用于存储入度数组和邻接表。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:3:4","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"208. 实现 Trie (前缀树) - Mid ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:4:0","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#208-实现-trie-前缀树---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 Trie（发音类似 \u0026ldquo;try\u0026rdquo;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:4:1","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。它是一种典型的“空间换时间”的数据结构。 节点结构 每个节点包含： children：一个指向子节点的指针数组。数组的索引 0-25 分别代表字母 a-z。 isEnd：布尔值，表示从根到当前节点的路径是否构成了一个完整的单词。 插入 (Insert) 从根节点开始，根据单词的字符顺序沿树向下。如果子节点不存在，则创建一个新的 Trie 节点。最后将末尾节点的 isEnd 设为 true。 搜索 (Search vs StartsWith) StartsWith：只要路径中每一个字符都能在树中找到对应的节点，就返回 true。 Search：不仅要路径匹配，最后一个字符所在的节点还必须满足 isEnd == true。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:4:2","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 type Trie struct { children [26]*Trie isEnd bool } // Constructor 初始化 Trie func Constructor() Trie { return Trie{} } // Insert 向前缀树中插入一个单词 func (this *Trie) Insert(word string) { node := this for _, ch := range word { index := ch - \u0026#39;a\u0026#39; if node.children[index] == nil { node.children[index] = \u0026amp;Trie{} } node = node.children[index] } // 标记该节点为一个单词的结尾 node.isEnd = true } // Search 查找单词是否存在 func (this *Trie) Search(word string) bool { node := this.searchPrefix(word) return node != nil \u0026amp;\u0026amp; node.isEnd } // StartsWith 查找是否存在以 prefix 为前缀的单词 func (this *Trie) StartsWith(prefix string) bool { return this.searchPrefix(prefix) != nil } // 辅助函数：根据前缀进行搜索，返回最后一个匹配的节点 func (this *Trie) searchPrefix(prefix string) *Trie { node := this for _, ch := range prefix { index := ch - \u0026#39;a\u0026#39; if node.children[index] == nil { return nil } node = node.children[index] } return node }","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:4:3","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度： Insert：O(m)O(m)O(m)，其中 m 是插入单词的长度。 Search 和 StartsWith：O(m)O(m)O(m)，其中 m 是查询单词或前缀的长度。 空间复杂度：O(m)O(m)O(m)，在最坏情况下，插入一个长度为 m 的单词需要创建 m 个新节点。 ","date":"2026-02-03","objectID":"/posts/2026-02-03-graph/:4:4","tags":["Go","图论","题解"],"title":"[Golang] LeetCode 热题 100 - 图论","uri":"/posts/2026-02-03-graph/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"二叉树 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:0:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#二叉树"},{"categories":["算法","LeetCode"],"collections":null,"content":"94. 二叉树的中序遍历 - Easy ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:1:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#94-二叉树的中序遍历---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:1:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 递归或者迭代 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:1:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { res := []int{} stack := []*TreeNode{} curr := root for curr != nil || len(stack) \u0026gt; 0 { // 1. 一路向左，把所有左孩子入栈 for curr != nil { stack = append(stack, curr) curr = curr.Left } // 2. 弹出栈顶（当前最左的节点） curr = stack[len(stack)-1] stack = stack[:len(stack)-1] // 3. 记录结果 res = append(res, curr.Val) // 4. 转向右子树 curr = curr.Right } return res }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:1:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:1:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"104. 二叉树的最大深度 - Easy ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:2:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#104-二叉树的最大深度---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个二叉树，找出其最大深度。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:2:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 递归求解 递归过程详解 触底：递归会一直深入到叶子节点的左右孩子（即 nil），此时返回 0。 回溯： 叶子节点的深度：max(0, 0) + 1 = 1。 父节点的深度：max(左子树深度, 右子树深度) + 1。 总结：每一层都将结果向上汇报，直到根节点。 虽然递归（DFS）最简洁，但在面试中，面试官有时会问：“如果这棵树非常深，导致栈溢出怎么办？” 这时可以使用 BFS（广度优先搜索），通过队列按层统计。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:2:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { // 基准情况：如果节点为空，深度为 0 if root == nil { return 0 } // 递归计算左子树深度 leftHeight := maxDepth(root.Left) // 递归计算右子树深度 rightHeight := maxDepth(root.Right) // 返回左右子树中的最大值 + 1（当前层） if leftHeight \u0026gt; rightHeight { return leftHeight + 1 } return rightHeight + 1 }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:2:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:2:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"226. 翻转二叉树 - Easy ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:3:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#226-翻转二叉树---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:3:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 递归交换每个节点的左右子节点 翻转二叉树的本质是：遍历每一个节点，并交换其左右孩子。 为什么这个解法有效？ 递归分解：我们要翻转以 root 为根的树，其实就是先把它的左右子树分别翻转好，然后再把翻转后的左子树接到右边，翻转后的右子树接到左边。 多重赋值：Go 的 a, b = b, a 特性在这里非常强大。它会先计算等号右边的两个递归调用（即先处理好子问题），然后再一次性赋值给左边的 root.Left 和 root.Right。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:3:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { // 基准情况：如果是空节点，直接返回 if root == nil { return nil } // 递归地翻转左右子树 // 在 Go 中，我们可以直接在一行内交换两个指针 root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) return root }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:3:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:3:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"101. 对称二叉树 - Easy ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:4:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#101-对称二叉树---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个二叉树的根节点 root ， 检查它是否是镜像对称的。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:4:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 判断对称并不是简单地看左右节点是否相等，而是要像“照镜子”一样进行外侧与外侧、内侧与内侧的比较。 递归判断的三个条件： 节点状态：左节点和右节点必须同时存在或同时为空。 数值相等：如果都存在，它们的值必须相等。 镜像递归： Left.Left 对比 Right.Right Left.Right 对比 Right.Left ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:4:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSymmetric(root *TreeNode) bool { // 根节点为空是对称的 if root == nil { return true } // 检查左子树和右子树是否镜像对称 return check(root.Left, root.Right) } func check(p, q *TreeNode) bool { // 1. 如果都为空，是对称的 if p == nil \u0026amp;\u0026amp; q == nil { return true } // 2. 如果只有一个为空，或者值不相等，则不对称 if p == nil || q == nil || p.Val != q.Val { return false } // 3. 递归比较： // p 的左子树 必须等于 q 的右子树 (外侧比较) // p 的右子树 必须等于 q 的左子树 (内侧比较) return check(p.Left, q.Right) \u0026amp;\u0026amp; check(p.Right, q.Left) }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:4:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:4:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"543. 二叉树的直径 - Easy ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:5:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#543-二叉树的直径---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一棵二叉树的根节点 root ，返回该树的 直径 。 二叉树的 直径 是指任意两个节点 之间路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:5:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 我们可以通过计算每个节点的左右子树深度之和来更新最大直径。 深度与直径的关系深度 (Depth)：从当前节点到最远叶子节点的节点数（或边数）。在上面的代码中，我们定义 nil 为 0，叶子节点深度为1。直径 (Diameter)：对于节点 u，经过它的最长路径长度等于 height(u.left) + height(u.right)。 为什么在计算深度的同时更新？如果我们先求深度再算直径，时间复杂度会变成 O(n2)O(n^2)O(n2)。通过在递归后序遍历（Bottom-up）时顺便记录 left + right，我们只需要 一次遍历 就能得到结果。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:5:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func diameterOfBinaryTree(root *TreeNode) int { ans := 0 // 定义辅助函数计算深度 var depth func(*TreeNode) int depth = func(node *TreeNode) int { if node == nil { return 0 } // 递归计算左右子树的深度 left := depth(node.Left) right := depth(node.Right) // 更新全局最大直径：左子树深度 + 右子树深度 if left + right \u0026gt; ans { ans = left + right } // 返回该节点的深度，供父节点使用 if left \u0026gt; right { return left + 1 } return right + 1 } depth(root) return ans }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:5:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:5:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"102. 二叉树的层序遍历 - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:6:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#102-二叉树的层序遍历---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:6:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 队列驱动的 BFS 层序遍历的核心在于先进先出 (FIFO)。我们使用队列来保证每一层都被顺序处理。 为什么用 levelSize？ 在进入内层 for 循环之前，队列中正好包含了且仅包含了当前层的所有节点。通过固定 levelSize := len(queue)，我们可以确保只处理属于该层的节点，而新加入队列的孩子节点（属于下一层）则会在下一次外层循环中被处理。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:6:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } // 使用切片模拟队列 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { // 关键点：获取当前层的节点数量 levelSize := len(queue) // 用于存储当前层节点值的切片 currentLevel := make([]int, 0, levelSize) // 遍历当前层的所有节点 for i := 0; i \u0026lt; levelSize; i++ { // 出队：取出第一个元素 node := queue[0] queue = queue[1:] // 记录当前节点的值 currentLevel = append(currentLevel, node.Val) // 将下一层的节点加入队列 if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } // 将当前层的结果加入最终结果集 res = append(res, currentLevel) } return res }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:6:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数 空间复杂度：O(N)O(N)O(N)，最坏情况下队列中会存储整棵树的一层节点（例如完全二叉树的最后一层）。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:6:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"108. 将有序数组转换为二叉搜索树 - Easy ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:7:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#108-将有序数组转换为二叉搜索树---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:7:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 为什么选择中间节点？ 平衡性：BST 的特性是 左子树 \u0026lt; 根 \u0026lt; 右子树。在有序数组中，中间节点的左侧刚好是所有比它小的数，右侧是所有比它大的数。 高度控制：每次从中间切分，左右子树的节点数差值不会超过 1，这完美符合“高度平衡二叉树”的定义。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:7:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { // 直接调用递归辅助函数 return build(nums, 0, len(nums)-1) } func build(nums []int, left int, right int) *TreeNode { // 基准情况：如果左边界大于右边界，说明当前区间没有元素，返回 nil if left \u0026gt; right { return nil } // 选择中间位置的数字作为根节点 // 使用 left + (right-left)/2 是为了防止整数溢出（虽然在数组索引中较少见） mid := left + (right-left)/2 // 创建根节点 root := \u0026amp;TreeNode{Val: nums[mid]} // 递归构造左子树：使用中间节点左侧的区间 root.Left = build(nums, left, mid-1) // 递归构造右子树：使用中间节点右侧的区间 root.Right = build(nums, mid+1, right) return root }简单写法 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := len(nums) / 2 return \u0026amp;TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), // 利用切片截取 Right: sortedArrayToBST(nums[mid+1:]), } }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:7:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是数组的长度。 空间复杂度：O(log⁡N)O(\\log N)O(logN)，递归调用栈的最大深度为 log⁡N\\log NlogN。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:7:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"98. 验证二叉搜索树 - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:8:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#98-验证二叉搜索树---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:8:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 二叉搜索树的一个核心特性是：它的中序遍历序列一定是严格递增的。 我们只需要在遍历时记录前一个节点的值，与当前节点比较即可。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:8:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func isValidBST(root *TreeNode) bool { var prev *int // 使用指针记录前一个节点的值，方便处理初始化 var inorder func(*TreeNode) bool inorder = func(node *TreeNode) bool { if node == nil { return true } // 1. 遍历左子树 if !inorder(node.Left) { return false } // 2. 检查当前节点：必须大于前一个节点 if prev != nil \u0026amp;\u0026amp; node.Val \u0026lt;= *prev { return false } val := node.Val prev = \u0026amp;val // 更新前一个节点的值 // 3. 遍历右子树 return inorder(node.Right) } return inorder(root) }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:8:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:8:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"230. 二叉搜索树中第 K 小的元素 - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:9:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#230-二叉搜索树中第-k-小的元素---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小的元素（从 1 开始计数）。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:9:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 为什么选择中序遍历？ BST 的定义：左子树 \u0026lt; 根节点 \u0026lt; 右子树。 中序遍历顺序：左 -\u0026gt; 根 -\u0026gt; 右。 结果：按照中序遍历访问 BST 节点的顺序，正好就是数值从小到大的顺序。 优化点： 空间优化：原方案空间复杂度 O(n)O(n)O(n) 用于存储数组，优化后为 O(h)O(h)O(h)（递归栈深度），其中 hhh 是树高。 时间优化：一旦计数器 count == k，我们就不再处理后续节点，在 kkk 很小时效率提升显著。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:9:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func kthSmallest(root *TreeNode, k int) int { var res int count := 0 // 定义闭包递归函数 var inorder func(*TreeNode) inorder = func(node *TreeNode) { // 如果已经找到结果或节点为空，直接返回 if node == nil || count \u0026gt;= k { return } // 1. 递归左子树 inorder(node.Left) // 2. 处理当前节点 count++ if count == k { res = node.Val return } // 3. 递归右子树 inorder(node.Right) } inorder(root) return res }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:9:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(H+k)O(H + k)O(H+k)，其中 H 是树的高度。在最坏情况下，我们可能需要遍历到树的最深处（高度 H），然后再访问 k 个节点。 空间复杂度：O(H)O(H)O(H)，递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:9:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"199. 二叉树的右视图 - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:10:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#199-二叉树的右视图---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个二叉树的根节点 root ，想象自己站在它的右侧，返回从顶部到底部所能看到的节点值。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:10:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 BFS 逻辑 想象你站在二叉树的右侧。每一层中，物理位置最靠右的那个节点会挡住同一层左边的所有节点。因此，只要我们按层遍历，并记录下每一层的最后一个元素，就能得到右视图。 除了 BFS，其实用 深度优先搜索（DFS） 也能解，而且代码更短。思路是：按照 “根 -\u0026gt; 右 -\u0026gt; 左” 的顺序访问节点，并记录当前深度。如果我们第一次到达某个深度，那么当前节点一定是该深度的最右节点。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:10:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { var ans []int if root == nil { return ans } // 使用切片模拟队列 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { // 当前层的节点个数 levelSize := len(queue) for i := 0; i \u0026lt; levelSize; i++ { // 出队 node := queue[0] queue = queue[1:] // 如果是当前层的最后一个节点，它就是从右侧看到的节点 if i == levelSize-1 { ans = append(ans, node.Val) } // 将子节点加入队列（注意：先左后右，保证 i == levelSize-1 是最右边的） if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return ans }DFS解法 func rightSideView(root *TreeNode) []int { var ans []int var dfs func(*TreeNode, int) dfs = func(node *TreeNode, depth int) { if node == nil { return } // 如果当前深度等于结果集的长度，说明该深度还没记录过节点 // 因为我们先递归右子树，所以第一个进来的肯定是该层最右边的 if depth == len(ans) { ans = append(ans, node.Val) } dfs(node.Right, depth+1) // 优先访问右子树 dfs(node.Left, depth+1) } dfs(root, 0) return ans }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:10:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(M)O(M)O(M)，其中 M 是二叉树的最大宽度（即某一层节点的最大数量）。在最坏情况下，队列中会存储整棵树的一层节点（例如完全二叉树的最后一层）。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:10:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"114. 二叉树展开为链表 - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:11:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#114-二叉树展开为链表---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你二叉树的根节点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个节点，而 left 子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:11:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 寻找“前驱节点” 展开后的链表顺序其实就是二叉树的 先序遍历（根 -\u0026gt; 左 -\u0026gt; 右）。 为什么这个逻辑有效？ 先序遍历的性质：在先序遍历中，root 的右子树一定紧跟在左子树的最后一个节点（左子树的最右节点）后面。 原地转移： 我们先找到左子树的“最右节点” pre。 把整个 curr.Right 挪动到 pre.Right。 这时，原来的左子树就可以安全地变成右子树，同时把左边清空。 循环往复：通过 curr = curr.Right 不断向下推进，直到整棵树变成一个细长的“右斜杆”。 除了上述思路外，还有递归的写法。递归的关键在于我们需要从下往上处理节点（即后序遍历的变种），这样才能确保在处理当前节点时，已经处理好了它的右子树和左子树。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:11:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func flatten(root *TreeNode) { curr := root for curr != nil { if curr.Left != nil { // 1. 找到左子树中最右边的节点（即左子树中序遍历的最后一个节点） pre := curr.Left for pre.Right != nil { pre = pre.Right } // 2. 将原先的右子树接到左子树最右节点的右边 pre.Right = curr.Right // 3. 将左子树插到右边，并将左边置空 curr.Right = curr.Left curr.Left = nil } // 4. 继续处理下一个右节点 curr = curr.Right } }递归写法 func flatten(root *TreeNode) { var prev *TreeNode var dfs func(*TreeNode) dfs = func(node *TreeNode) { if node == nil { return } // 按照 右 -\u0026gt; 左 -\u0026gt; 根 的顺序倒着处理 dfs(node.Right) dfs(node.Left) node.Right = prev node.Left = nil prev = node } dfs(root) }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:11:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(1)O(1)O(1)，我们只使用了常数级别的额外空间。递归写法的空间复杂度为 O(H)O(H)O(H)，其中 H 是二叉树的高度。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:11:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"105. 从前序与中序遍历序列构造二叉树 - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:12:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#105-从前序与中序遍历序列构造二叉树---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的前序遍历，inorder 是同一棵树的中序遍历，请你构造并返回这棵二叉树。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:12:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 分治策略 核心步骤： 确定根节点：从 preorder 数组中按顺序取出元素作为根。 划分区间：在 inorder 数组中找到该根节点的位置 mid。 [inLeft, mid-1] 构成左子树的中序序列。 [mid+1, inRight] 构成右子树的中序序列。 递归填充： 由于前序遍历的顺序是“根-左-右”，我们在递归时必须先调用 build(左区间)，再调用 build(右区间)。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:12:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { // 1. 使用 map 存储中序遍历的值与索引的映射，提高查找效率 indexMap := make(map[int]int) for i, v := range inorder { indexMap[v] = i } // preorderIdx 用于记录当前处理到前序遍历的第几个节点 preorderIdx := 0 // 2. 定义递归函数 var build func(inLeft, inRight int) *TreeNode build = func(inLeft, inRight int) *TreeNode { // 如果左边界大于右边界，说明该子树为空 if inLeft \u0026gt; inRight { return nil } // 前序遍历的第一个节点就是当前的根节点 rootVal := preorder[preorderIdx] preorderIdx++ root := \u0026amp;TreeNode{Val: rootVal} // 在中序遍历中找到根节点的索引，以此划分左右子树 mid := indexMap[rootVal] // 3. 递归构造左右子树 // 注意：必须先构造左子树，因为前序遍历中根节点后面紧跟的是左子树 root.Left = build(inLeft, mid-1) root.Right = build(mid+1, inRight) return root } return build(0, len(inorder)-1) }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:12:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(N)O(N)O(N)，用于存储中序遍历的值与索引的映射，以及递归调用栈的空间。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:12:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"437. 路径总和 III - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:13:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#437-路径总和-iii---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个二叉树的根节点 root ，和一个整数目标和 targetSum ，求该二叉树中 和为目标和 的路径数 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:13:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 前缀和在树的路径中，如果“根节点到当前节点 A”的路径和为 S1S_1S1​， 而“根节点到其祖先节点 B”的路径和为 S2S_2S2​，那么 B 到 A 的路径和 就是 S1−S2S_1 - S_2S1​−S2​。 我们要找的是 S1−S2=targetSumS_1 - S_2 = targetSumS1​−S2​=targetSum，即在当前路径的祖先节点中， 有多少个节点的前缀和等于 S1−targetSumS_1 - targetSumS1​−targetSum。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:13:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, targetSum int) int { // prefixSumMap 存储从根节点开始的路径和及其出现的次数 // key: 前缀和, value: 出现次数 prefixSumMap := make(map[int64]int) // 初始化：前缀和为 0 的路径默认有 1 条（代表从根节点开始的路径） prefixSumMap[0] = 1 return dfs(root, 0, int64(targetSum), prefixSumMap) } func dfs(node *TreeNode, currSum int64, target int64, prefixSumMap map[int64]int) int { if node == nil { return 0 } // 1. 更新当前路径和 currSum += int64(node.Val) // 2. 检查是否存在满足条件的前缀和 // currSum - target = 祖先节点的前缀和 count := prefixSumMap[currSum-target] // 3. 将当前前缀和加入 map，供子节点使用 prefixSumMap[currSum]++ // 4. 递归处理左右子树 count += dfs(node.Left, currSum, target, prefixSumMap) count += dfs(node.Right, currSum, target, prefixSumMap) // 5. 回溯：在返回父节点前，移除当前节点的前缀和 // 这是为了防止“左子树”的前缀和影响到“右子树”的路径计算 prefixSumMap[currSum]-- return count }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:13:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(N)O(N)O(N)，用于存储前缀和的哈希表，以及递归调用栈的空间。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:13:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"236. 二叉树的最近公共祖先 - Medium ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:14:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#236-二叉树的最近公共祖先---medium"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:14:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-13"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 三种情况的博弈我们在递归回溯的过程中， left 和 right 的含义是：在该子树中找到的 ppp 或 qqq（或者它们的公共祖先）。 左右逢源：如果 left 和 right 同时不为空，说明 ppp 和 qqq 分别分布在当前节点的左右子树中，那么当前节点 root 必然是 LCA。 一侧全包：如果一边为空，另一边不为空，说明 ppp 和 qqq 都在不为空的那一侧。此时我们继续向上返回那个不为空的节点。 空手而归：如果两边都为空，说明这棵子树里既没有 ppp 也没有 qqq，返回 nil。为什么 root == p || root == q 时直接返回？这是一个巧妙的提前阻断。如果我们在某个节点遇到了 ppp，即使 qqq 在 ppp 的子树下面，根据 LCA 的定义，ppp 本身就是它们的最近公共祖先。所以我们不需要再往下找了，直接把 ppp 向上返回即可。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:14:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-13"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { // 1. 基准情况：如果节点为空，或者找到了 p 或 q，直接返回当前节点 if root == nil || root == p || root == q { return root } // 2. 递归在左右子树中寻找 p 和 q left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) // 3. 根据左右子树的返回值进行逻辑判断： // 如果左子树没找到，说明 p 和 q 都在右子树，返回右子树的结果 if left == nil { return right } // 如果右子树没找到，说明都在左子树，返回左子树的结果 if right == nil { return left } // 如果左、右子树都各找到了一个（都不为 nil）， // 说明当前 root 就是它们分叉的地方，即最近公共祖先 return root }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:14:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-13"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:14:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-13"},{"categories":["算法","LeetCode"],"collections":null,"content":"124. 二叉树中的最大路径和 - Hard ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:15:0","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#124-二叉树中的最大路径和---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个二叉树的根节点 root ，返回其 最大路径和 。 二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:15:1","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#题目回顾-14"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 单边贡献 vs. 完整路径 概念区分完整路径 (Current PathSum)：以当前节点为“转折点”的路径，即 leftGain + node.Val + rightGain。我们用它来更新全局的 maxSum。单边贡献 (Gain)：当前节点向上级汇报的值。由于路径不能有分叉，所以汇报给父节点时，只能选 node.Val + leftGain 或 node.Val + rightGain。 负数处理（贪心）如果某个子树的路径和算出来是 −5-5−5，那么根节点加上它只会让结果变小。此时 max(0, gain) 的逻辑就会起作用，将其视为 000，相当于“斩断”了通往该子树的路径。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:15:2","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#核心思路-14"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ import \u0026#34;math\u0026#34; func maxPathSum(root *TreeNode) int { // 初始化为最小整数，防止树中全是负数 maxSum := math.MinInt32 var gain func(*TreeNode) int gain = func(node *TreeNode) int { if node == nil { return 0 } // 1. 递归计算左右子树能提供的最大贡献 // 如果贡献是负数，我们直接取 0（表示不经过该子树） leftGain := max(0, gain(node.Left)) rightGain := max(0, gain(node.Right)) // 2. 计算经过当前节点的最大路径和（左 + 根 + 右） // 并尝试更新全局最大值 currentPathSum := node.Val + leftGain + rightGain if currentPathSum \u0026gt; maxSum { maxSum = currentPathSum } // 3. 返回该节点能提供给父节点的最大单侧路径 // 因为路径不能分支，所以只能选左或右其中一条 return node.Val + max(leftGain, rightGain) } gain(root) return maxSum } // 辅助函数：返回两个整数中的较大值 func max(a, b int) int { if a \u0026gt; b { return a } return b }","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:15:3","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#代码实现-14"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(N)O(N)O(N)，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：O(H)O(H)O(H)，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ","date":"2026-01-31","objectID":"/posts/2026-01-31-binary-tree/:15:4","tags":["Go","二叉树","题解"],"title":"[Golang] LeetCode 热题 100 - 二叉树","uri":"/posts/2026-01-31-binary-tree/#复杂度分析-14"},{"categories":["算法","LeetCode"],"collections":null,"content":"链表 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:0:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#链表"},{"categories":["算法","LeetCode"],"collections":null,"content":"160. 相交链表 - Easy ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#160-相交链表---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点, 返回 null 。 题目数据 保证 整个链式结构中不存在环，并且函数返回结果后，链表必须 保持其原始结构 。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 思路0：HashSet去重 思路一：双指针 + 长度对齐 这是最直观的解法。既然相交前的部分长度可能不同，导致我们无法直接同步遍历，那我们想办法让它们变得一样长就可以了。 计算长度：首先，分别遍历两个链表，得到它们的长度 lenA 和 lenB。 对齐指针：计算出长度差 diff = |lenA - lenB|。让较长的那个链表的指针先走 diff 步。这样操作之后，两个指针距离各自链表的末尾就有了相同的距离。 同步遍历：现在两个指针位于同一起跑线（相对终点而言），我们让它们同步向后移动，一次一步。 寻找交点：在同步移动的过程中，第一次出现两个指针相等 (headA == headB) 的地方，就是它们的第一个相交节点。如果一直走到末尾 (null) 都没有相遇，则说明两个链表不相交。 这个方法就像两个人去同一个终点，路程长的人先出发一段距离，然后两个人再同时出发，这样他们就能同时到达终点。 思路二：双指针\u0026quot;浪漫\u0026quot;相遇法 这是一个更巧妙，代码也更简洁的解法，它避免了显式地计算长度。 想象有两个指针 pA 和 pB，分别从 headA 和 headB 出发。它们同时前进，当任何一个指针走到自己链表的末尾时，就跳到对方链表的头节点继续前进。 为什么这个方法可行？ 路径长度相等： pA 走过的路径：链表A的长度 + 链表B的长度 pB 走过的路径：链表B的长度 + 链表A的长度 两个指针走过的总路程是完全相同的。 相遇点： 如果相交：设 A 不相交部分长 a，B 不相交部分长 b，相交部分长 c。pA 走 a+c 到达终点，然后从 B 的头部走 b 步。pB 走 b+c 到达终点，然后从 A 的头部走 a 步。当它们都走了 a+b+c 的路程时，会在相交点相遇。 如果不相交：pA 走完 A 再走完 B，pB 走完 B 再走完 A。它们会同时到达终点 null，此时 pA == pB == null，循环结束，正确返回 null。 这个方法可以理解为，通过让两个指针都走一遍 A+B 和 B+A 的路程，从而消除了长度差，使得它们能够在终点前相遇。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 思路0：HashSet去重 思路一：双指针 + 长度对齐 这是最直观的解法。既然相交前的部分长度可能不同，导致我们无法直接同步遍历，那我们想办法让它们变得一样长就可以了。 计算长度：首先，分别遍历两个链表，得到它们的长度 lenA 和 lenB。 对齐指针：计算出长度差 diff = |lenA - lenB|。让较长的那个链表的指针先走 diff 步。这样操作之后，两个指针距离各自链表的末尾就有了相同的距离。 同步遍历：现在两个指针位于同一起跑线（相对终点而言），我们让它们同步向后移动，一次一步。 寻找交点：在同步移动的过程中，第一次出现两个指针相等 (headA == headB) 的地方，就是它们的第一个相交节点。如果一直走到末尾 (null) 都没有相遇，则说明两个链表不相交。 这个方法就像两个人去同一个终点，路程长的人先出发一段距离，然后两个人再同时出发，这样他们就能同时到达终点。 思路二：双指针\u0026quot;浪漫\u0026quot;相遇法 这是一个更巧妙，代码也更简洁的解法，它避免了显式地计算长度。 想象有两个指针 pA 和 pB，分别从 headA 和 headB 出发。它们同时前进，当任何一个指针走到自己链表的末尾时，就跳到对方链表的头节点继续前进。 为什么这个方法可行？ 路径长度相等： pA 走过的路径：链表A的长度 + 链表B的长度 pB 走过的路径：链表B的长度 + 链表A的长度 两个指针走过的总路程是完全相同的。 相遇点： 如果相交：设 A 不相交部分长 a，B 不相交部分长 b，相交部分长 c。pA 走 a+c 到达终点，然后从 B 的头部走 b 步。pB 走 b+c 到达终点，然后从 A 的头部走 a 步。当它们都走了 a+b+c 的路程时，会在相交点相遇。 如果不相交：pA 走完 A 再走完 B，pB 走完 B 再走完 A。它们会同时到达终点 null，此时 pA == pB == null，循环结束，正确返回 null。 这个方法可以理解为，通过让两个指针都走一遍 A+B 和 B+A 的路程，从而消除了长度差，使得它们能够在终点前相遇。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#思路0hashset去重"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 思路0：HashSet去重 思路一：双指针 + 长度对齐 这是最直观的解法。既然相交前的部分长度可能不同，导致我们无法直接同步遍历，那我们想办法让它们变得一样长就可以了。 计算长度：首先，分别遍历两个链表，得到它们的长度 lenA 和 lenB。 对齐指针：计算出长度差 diff = |lenA - lenB|。让较长的那个链表的指针先走 diff 步。这样操作之后，两个指针距离各自链表的末尾就有了相同的距离。 同步遍历：现在两个指针位于同一起跑线（相对终点而言），我们让它们同步向后移动，一次一步。 寻找交点：在同步移动的过程中，第一次出现两个指针相等 (headA == headB) 的地方，就是它们的第一个相交节点。如果一直走到末尾 (null) 都没有相遇，则说明两个链表不相交。 这个方法就像两个人去同一个终点，路程长的人先出发一段距离，然后两个人再同时出发，这样他们就能同时到达终点。 思路二：双指针\u0026quot;浪漫\u0026quot;相遇法 这是一个更巧妙，代码也更简洁的解法，它避免了显式地计算长度。 想象有两个指针 pA 和 pB，分别从 headA 和 headB 出发。它们同时前进，当任何一个指针走到自己链表的末尾时，就跳到对方链表的头节点继续前进。 为什么这个方法可行？ 路径长度相等： pA 走过的路径：链表A的长度 + 链表B的长度 pB 走过的路径：链表B的长度 + 链表A的长度 两个指针走过的总路程是完全相同的。 相遇点： 如果相交：设 A 不相交部分长 a，B 不相交部分长 b，相交部分长 c。pA 走 a+c 到达终点，然后从 B 的头部走 b 步。pB 走 b+c 到达终点，然后从 A 的头部走 a 步。当它们都走了 a+b+c 的路程时，会在相交点相遇。 如果不相交：pA 走完 A 再走完 B，pB 走完 B 再走完 A。它们会同时到达终点 null，此时 pA == pB == null，循环结束，正确返回 null。 这个方法可以理解为，通过让两个指针都走一遍 A+B 和 B+A 的路程，从而消除了长度差，使得它们能够在终点前相遇。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#思路一双指针--长度对齐"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 思路0：HashSet去重 思路一：双指针 + 长度对齐 这是最直观的解法。既然相交前的部分长度可能不同，导致我们无法直接同步遍历，那我们想办法让它们变得一样长就可以了。 计算长度：首先，分别遍历两个链表，得到它们的长度 lenA 和 lenB。 对齐指针：计算出长度差 diff = |lenA - lenB|。让较长的那个链表的指针先走 diff 步。这样操作之后，两个指针距离各自链表的末尾就有了相同的距离。 同步遍历：现在两个指针位于同一起跑线（相对终点而言），我们让它们同步向后移动，一次一步。 寻找交点：在同步移动的过程中，第一次出现两个指针相等 (headA == headB) 的地方，就是它们的第一个相交节点。如果一直走到末尾 (null) 都没有相遇，则说明两个链表不相交。 这个方法就像两个人去同一个终点，路程长的人先出发一段距离，然后两个人再同时出发，这样他们就能同时到达终点。 思路二：双指针\u0026quot;浪漫\u0026quot;相遇法 这是一个更巧妙，代码也更简洁的解法，它避免了显式地计算长度。 想象有两个指针 pA 和 pB，分别从 headA 和 headB 出发。它们同时前进，当任何一个指针走到自己链表的末尾时，就跳到对方链表的头节点继续前进。 为什么这个方法可行？ 路径长度相等： pA 走过的路径：链表A的长度 + 链表B的长度 pB 走过的路径：链表B的长度 + 链表A的长度 两个指针走过的总路程是完全相同的。 相遇点： 如果相交：设 A 不相交部分长 a，B 不相交部分长 b，相交部分长 c。pA 走 a+c 到达终点，然后从 B 的头部走 b 步。pB 走 b+c 到达终点，然后从 A 的头部走 a 步。当它们都走了 a+b+c 的路程时，会在相交点相遇。 如果不相交：pA 走完 A 再走完 B，pB 走完 B 再走完 A。它们会同时到达终点 null，此时 pA == pB == null，循环结束，正确返回 null。 这个方法可以理解为，通过让两个指针都走一遍 A+B 和 B+A 的路程，从而消除了长度差，使得它们能够在终点前相遇。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#思路二双指针浪漫相遇法"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 解法一：长度对齐法 func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } // 1. 计算长度 lenA, lenB := 0, 0 currA, currB := headA, headB for currA != nil { lenA++ currA = currA.Next } for currB != nil { lenB++ currB = currB.Next } // 2. 指针重置并对齐 currA, currB = headA, headB if lenA \u0026gt; lenB { for i := 0; i \u0026lt; lenA-lenB; i++ { currA = currA.Next } } else { for i := 0; i \u0026lt; lenB-lenA; i++ { currB = currB.Next } } // 3. 同时移动，直到相遇 for currA != currB { currA = currA.Next currB = currB.Next } return currA }解法二：双指针\u0026quot;换路\u0026quot;法 (更巧妙) func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pA, pB := headA, headB for pA != pB { // Go 中没有三元运算符 a ? b : c // 如果 pA 到头了，就跳到 B 的头 if pA == nil { pA = headB } else { pA = pA.Next } // 如果 pB 到头了，就跳到 A 的头 if pB == nil { pB = headA } else { pB = pB.Next } } // 最终 pA == pB，可能是相交节点，也可能是 nil return pA }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 解法一：长度对齐法 func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } // 1. 计算长度 lenA, lenB := 0, 0 currA, currB := headA, headB for currA != nil { lenA++ currA = currA.Next } for currB != nil { lenB++ currB = currB.Next } // 2. 指针重置并对齐 currA, currB = headA, headB if lenA \u0026gt; lenB { for i := 0; i \u0026lt; lenA-lenB; i++ { currA = currA.Next } } else { for i := 0; i \u0026lt; lenB-lenA; i++ { currB = currB.Next } } // 3. 同时移动，直到相遇 for currA != currB { currA = currA.Next currB = currB.Next } return currA }解法二：双指针\u0026quot;换路\u0026quot;法 (更巧妙) func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pA, pB := headA, headB for pA != pB { // Go 中没有三元运算符 a ? b : c // 如果 pA 到头了，就跳到 B 的头 if pA == nil { pA = headB } else { pA = pA.Next } // 如果 pB 到头了，就跳到 A 的头 if pB == nil { pB = headA } else { pB = pB.Next } } // 最终 pA == pB，可能是相交节点，也可能是 nil return pA }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#解法一长度对齐法"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 解法一：长度对齐法 func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } // 1. 计算长度 lenA, lenB := 0, 0 currA, currB := headA, headB for currA != nil { lenA++ currA = currA.Next } for currB != nil { lenB++ currB = currB.Next } // 2. 指针重置并对齐 currA, currB = headA, headB if lenA \u0026gt; lenB { for i := 0; i \u0026lt; lenA-lenB; i++ { currA = currA.Next } } else { for i := 0; i \u0026lt; lenB-lenA; i++ { currB = currB.Next } } // 3. 同时移动，直到相遇 for currA != currB { currA = currA.Next currB = currB.Next } return currA }解法二：双指针\u0026quot;换路\u0026quot;法 (更巧妙) func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pA, pB := headA, headB for pA != pB { // Go 中没有三元运算符 a ? b : c // 如果 pA 到头了，就跳到 B 的头 if pA == nil { pA = headB } else { pA = pA.Next } // 如果 pB 到头了，就跳到 A 的头 if pB == nil { pB = headA } else { pB = pB.Next } } // 最终 pA == pB，可能是相交节点，也可能是 nil return pA }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#解法二双指针换路法-更巧妙"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(m + n)。其中 m 和 n 分别是两个链表的长度。两种方法都需要线性遍历链表。 空间复杂度: O(1)。两种方法都只使用了常数个额外指针变量。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:1:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"206. 反转链表 - Easy ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#206-反转链表---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]示例 2： 输入：head = [1,2] 输出：[2,1]示例 3： 输入：head = [] 输出：[]","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 思路一：迭代法（双指针） 这是最直观的解法。我们需要遍历链表，在遍历过程中改变每个节点的 next 指针指向。 三个指针：我们需要三个指针来完成反转： prev：指向当前节点的前一个节点（初始为 null） curr：指向当前节点（初始为 head） next：临时存储当前节点的下一个节点 遍历反转： 保存 curr.next 到 next（防止断链） 将 curr.next 指向 prev（反转当前节点） 将 prev 移动到 curr 位置 将 curr 移动到 next 位置 返回结果：遍历结束后，prev 就是新链表的头节点 这个方法就像把一列火车车厢的方向逐个反转，需要临时标记下一个车厢的位置。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 思路一：迭代法（双指针） 这是最直观的解法。我们需要遍历链表，在遍历过程中改变每个节点的 next 指针指向。 三个指针：我们需要三个指针来完成反转： prev：指向当前节点的前一个节点（初始为 null） curr：指向当前节点（初始为 head） next：临时存储当前节点的下一个节点 遍历反转： 保存 curr.next 到 next（防止断链） 将 curr.next 指向 prev（反转当前节点） 将 prev 移动到 curr 位置 将 curr 移动到 next 位置 返回结果：遍历结束后，prev 就是新链表的头节点 这个方法就像把一列火车车厢的方向逐个反转，需要临时标记下一个车厢的位置。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#思路一迭代法双指针"},{"categories":["算法","LeetCode"],"collections":null,"content":"思路二：头插法（虚拟头节点） 这个方法使用一个虚拟头节点，将原链表的节点逐个插入到虚拟头节点后面。 创建虚拟头节点：dummy = new ListNode(0) 遍历原链表： 保存当前节点 curr 将当前节点从原链表中断开 将当前节点插入到虚拟头节点后面 返回结果：返回 dummy.next ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#思路二头插法虚拟头节点"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 解法一：迭代法（双指针） func reverseList(head *ListNode) *ListNode { var prev *ListNode // 在 Go 中，nil 是指针的零值 curr := head for curr != nil { // 利用 Go 的多重赋值特性： // 1. 记录 curr.Next 到下一次循环的 curr // 2. 将 curr.Next 指向 prev (完成反转) // 3. 将 prev 移动到当前 curr 位置 // 顺序必须保证：先处理 curr.Next，再更新 curr next := curr.Next curr.Next = prev prev = curr curr = next } return prev }解法二：头插法（虚拟头节点） func reverseList(head *ListNode) *ListNode { if head == nil { return nil } // 初始化虚拟头节点 dummy := \u0026amp;ListNode{Val: 0} curr := head for curr != nil { next := curr.Next // 暂时保存余下的链表 // 头插逻辑： curr.Next = dummy.Next dummy.Next = curr curr = next // 继续处理原链表 } return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 解法一：迭代法（双指针） func reverseList(head *ListNode) *ListNode { var prev *ListNode // 在 Go 中，nil 是指针的零值 curr := head for curr != nil { // 利用 Go 的多重赋值特性： // 1. 记录 curr.Next 到下一次循环的 curr // 2. 将 curr.Next 指向 prev (完成反转) // 3. 将 prev 移动到当前 curr 位置 // 顺序必须保证：先处理 curr.Next，再更新 curr next := curr.Next curr.Next = prev prev = curr curr = next } return prev }解法二：头插法（虚拟头节点） func reverseList(head *ListNode) *ListNode { if head == nil { return nil } // 初始化虚拟头节点 dummy := \u0026amp;ListNode{Val: 0} curr := head for curr != nil { next := curr.Next // 暂时保存余下的链表 // 头插逻辑： curr.Next = dummy.Next dummy.Next = curr curr = next // 继续处理原链表 } return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#解法一迭代法双指针"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 解法一：迭代法（双指针） func reverseList(head *ListNode) *ListNode { var prev *ListNode // 在 Go 中，nil 是指针的零值 curr := head for curr != nil { // 利用 Go 的多重赋值特性： // 1. 记录 curr.Next 到下一次循环的 curr // 2. 将 curr.Next 指向 prev (完成反转) // 3. 将 prev 移动到当前 curr 位置 // 顺序必须保证：先处理 curr.Next，再更新 curr next := curr.Next curr.Next = prev prev = curr curr = next } return prev }解法二：头插法（虚拟头节点） func reverseList(head *ListNode) *ListNode { if head == nil { return nil } // 初始化虚拟头节点 dummy := \u0026amp;ListNode{Val: 0} curr := head for curr != nil { next := curr.Next // 暂时保存余下的链表 // 头插逻辑： curr.Next = dummy.Next dummy.Next = curr curr = next // 继续处理原链表 } return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#解法二头插法虚拟头节点"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(n)。其中 n 是链表的长度，所有方法都需要遍历整个链表一次。 空间复杂度: 迭代法：O(1)，只使用了常数个额外指针变量。 头插法：O(1)，只使用了虚拟头节点和几个指针变量。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:2:5","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"234. 回文链表 - Easy ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:3:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#234-回文链表---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:3:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 快慢指针 + 反转后半部分 这是一个经典的解法，利用快慢指针找到链表的中点，然后反转后半部分，再与前半部分进行比较。 找到中点：使用快慢指针，快指针每次走两步，慢指针每次走一步。当快指针到达末尾时，慢指针正好到达中点。 反转后半部分：从慢指针开始，反转链表的后半部分。 比较前后部分：从头节点和反转后的中点开始，逐个比较节点值是否相等。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:3:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 快慢指针 + 反转后半部分 这是一个经典的解法，利用快慢指针找到链表的中点，然后反转后半部分，再与前半部分进行比较。 找到中点：使用快慢指针，快指针每次走两步，慢指针每次走一步。当快指针到达末尾时，慢指针正好到达中点。 反转后半部分：从慢指针开始，反转链表的后半部分。 比较前后部分：从头节点和反转后的中点开始，逐个比较节点值是否相等。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:3:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#快慢指针--反转后半部分"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { if head == nil { return true } // 1. 找到前半部分的末尾节点 firstHalfEnd := endOfFirstHalf(head) // 2. 反转后半部分链表 secondHalfStart := reverseList(firstHalfEnd.Next) // 3. 判断是否回文 p1 := head p2 := secondHalfStart result := true for result \u0026amp;\u0026amp; p2 != nil { if p1.Val != p2.Val { result = false } p1 = p1.Next p2 = p2.Next } // 4. 还原链表（可选，但在实际工程中是好习惯） firstHalfEnd.Next = reverseList(secondHalfStart) return result } // 使用快慢指针寻找中点 func endOfFirstHalf(head *ListNode) *ListNode { fast := head slow := head // 快指针走两步，慢指针走一步 for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { fast = fast.Next.Next slow = slow.Next } return slow } // 原地反转链表（双指针法，比头插法更简洁） func reverseList(head *ListNode) *ListNode { var prev *ListNode curr := head for curr != nil { next := curr.Next curr.Next = prev prev = curr curr = next } return prev }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:3:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(n)。其中 n 是链表的长度，所有方法都需要遍历整个链表一次。 空间复杂度: O(1)。只使用了常数个额外指针变量。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:3:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"141. 环形链表 - Easy ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:4:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#141-环形链表---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:4:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 相对速度：想象在环形跑道上，兔子（快指针）比乌龟（慢指针）快一步。从乌龟进入环的那一刻起，每移动一次，兔子和乌龟之间的距离就会缩短 111。 最终相遇：既然距离每次缩小 111，那么在有限的步数内，距离一定会变成 000（即相遇），而不会出现“跳过”彼此的情况。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:4:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func hasCycle(head *ListNode) bool { // 如果链表为空或者只有一个节点且无环，直接返回 false if head == nil || head.Next == nil { return false } slow, fast := head, head // 只要快指针没有走到尽头，就继续跑 // 因为 fast 每次走两步，所以要检查 fast 和 fast.Next for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next // 慢指针走一步 fast = fast.Next.Next // 快指针走两步 // 如果相遇，说明有环 if slow == fast { return true } } // 如果跳出循环，说明快指针指向了 nil，即链表有终点，无环 return false }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:4:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(n)。其中 n 是链表的长度，快慢指针最多遍历链表一次。 空间复杂度: O(1)。只使用了常数个额外指针变量。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:4:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"142. 环形链表 II - Mid ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:5:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#142-环形链表-ii---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:5:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 为什么“一个指针从 head 出发，一个从相遇点出发，等速移动必会在入环点相遇”？我们来做个简单的算术题： 定义距离： 设从 起点 到 入环点 的距离为 aaa。 设从 入环点 到 首次相遇点 的距离为 bbb。 设从 首次相遇点 回到 入环点 的剩余距离为 ccc。 环的总周长就是 b+cb + cb+c。 指针走过的路程： 慢指针 (slow) 走的距离：s=a+bs = a + bs=a+b 快指针 (fast) 走的距离：f=a+n(b+c)+bf = a + n(b + c) + bf=a+n(b+c)+b （nnn 是快指针绕环的圈数） 速度关系： 因为快指针速度是慢指针的两倍，所以 f=2sf = 2sf=2s。 代入公式：a+n(b+c)+b=2(a+b)a + n(b + c) + b = 2(a + b)a+n(b+c)+b=2(a+b) 化简得：n(b+c)=a+bn(b + c) = a + bn(b+c)=a+b 我们要找的是 aaa（起点到入环点的距离），所以把 aaa 孤立出来： a=n(b+c)−ba = n(b + c) - ba=n(b+c)−b 进一步整理：a=(n−1)(b+c)+ca = (n - 1)(b + c) + ca=(n−1)(b+c)+c 结论： 这个公式 a=(n−1)×周长+ca = (n - 1) \\times \\text{周长} + ca=(n−1)×周长+c 告诉我们：从起点走 aaa 步，等同于从相遇点走过 n−1n-1n−1 圈后再走 ccc 步。 由于都在环里转圈，那 n−1n-1n−1 圈可以忽略，结论简化为：走 aaa 步的路程等于走 ccc 步的路程。 所以两个指针再次相遇时，一定是在入环点。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:5:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { if head == nil || head.Next == nil { return nil } slow, fast := head, head // 第一阶段：判断是否有环（龟兔赛跑） for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next // 如果快慢指针相遇，说明有环 if slow == fast { // 第二阶段：寻找入环点 // 将其中一个指针重置到 head，另一个留在相遇点 p := head for p != slow { p = p.Next slow = slow.Next } // 它们再次相遇的地方就是入环点 return p } } return nil }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:5:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：。第一阶段快慢指针相遇最多 ，第二阶段寻找入环点最多 。 空间复杂度：。只使用了指针。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:5:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"21. 合并两个有序链表 - Easy ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:6:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#21-合并两个有序链表---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:6:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 核心步骤： 哨兵节点（Dummy Node）：我们先造一个“假”的头节点。它的作用是作为新链表的起点，避免我们在循环里去写 if head == nil 这种逻辑判断。 比较与连接：像拉链一样，比较 p 和 q 的值，谁小就把 curr.Next 指向谁，然后那个指针后移。 收尾工作：因为两个链表长度可能不等，当一个遍历完后，另一个肯定还剩下一截。由于原链表已经是有序的，我们直接把剩余的那一整截挂在 curr.Next 上即可。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:6:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { // 1. 创建虚拟头节点，便于处理返回结果 // 在 Go 中，\u0026amp;ListNode{} 会分配内存并返回指针 dummy := \u0026amp;ListNode{} curr := dummy // 2. 同时遍历两个链表 p, q := list1, list2 for p != nil \u0026amp;\u0026amp; q != nil { if p.Val \u0026lt; q.Val { curr.Next = p p = p.Next } else { curr.Next = q q = q.Next } curr = curr.Next } // 3. 处理剩余部分 // Go 没有三元运算符，直接用 if 赋值即可 if p != nil { curr.Next = p } else { curr.Next = q } // 返回虚拟头节点的下一个节点，即合并后的真正头节点 return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:6:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度：O(n+m)O(n + m)O(n+m)，其中 nnn 和 mmm 分别是两个链表的长度。我们只需要遍历每个节点一次。 空间复杂度：O(1)O(1)O(1)。我们只是在修改原有节点的指针指向，并没有创建 n+mn+mn+m 个新节点。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:6:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-5"},{"categories":["算法","LeetCode"],"collections":null,"content":"2. 两数相加 - Mid ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:7:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#2-两数相加---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:7:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这道题的本质是 模拟竖式加法。由于链表已经是逆序存储的（个位在头），这反而降低了难度，因为我们可以直接从头开始加。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:7:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { dummy := \u0026amp;ListNode{} // 虚拟头节点 curr := dummy carry := 0 // 进位 // 只要 l1, l2 没走完，或者最后还有一个进位没处理，就继续循环 for l1 != nil || l2 != nil || carry \u0026gt; 0 { sum := carry // 开始计算当前位的和 if l1 != nil { sum += l1.Val l1 = l1.Next } if l2 != nil { sum += l2.Val l2 = l2.Next } // 计算新的进位和当前位的值 carry = sum / 10 val := sum % 10 // 创建新节点并移动指针 curr.Next = \u0026amp;ListNode{Val: val} curr = curr.Next } return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:7:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(max(m,n))O(max(m, n))O(max(m,n))，其中 m 和 n 分别是两个链表的长度。我们需要遍历最长的链表。 空间复杂度: O(1)O(1)O(1)，用于存储结果 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:7:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-6"},{"categories":["算法","LeetCode"],"collections":null,"content":"19. 删除链表的倒数第 N 个结点 - Mid ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:8:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#19-删除链表的倒数第-n-个结点---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:8:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 让快指针先走 n+1n+1n+1 步，然后快慢指针同步移动。当快指针到达末尾时，慢指针正好指向倒数第 nnn 个节点的前驱。 或者把所有的节点入栈，弹出 nnn 个节点后，栈顶节点就是倒数第 nnn 个节点的前驱。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:8:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func removeNthFromEnd(head *ListNode, n int) *ListNode { // 1. 创建虚拟头节点，处理删除头节点的情况 dummy := \u0026amp;ListNode{Next: head} // 2. 初始化快慢指针都指向 dummy fast, slow := dummy, dummy // 3. 快指针先走 n+1 步 // 为什么要走 n+1？因为我们要让 slow 停在被删节点的前一个位置 for i := 0; i \u0026lt;= n; i++ { fast = fast.Next } // 4. 快慢指针同步移动，直到 fast 走到头 for fast != nil { fast = fast.Next slow = slow.Next } // 5. 此时 slow 就在待删除节点的前面，直接跳过目标节点 slow.Next = slow.Next.Next return dummy.Next }栈版本 func removeNthFromEndStack(head *ListNode, n int) *ListNode { dummy := \u0026amp;ListNode{Next: head} stack := []*ListNode{} // 入栈 curr := dummy for curr != nil { stack = append(stack, curr) curr = curr.Next } // 出栈 n 次 stack = stack[:len(stack)-n] // 栈顶就是待删除节点的前驱 prev := stack[len(stack)-1] prev.Next = prev.Next.Next return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:8:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(n)O(n)O(n)。其中 n 是链表的长度，快指针需要遍历链表一次。 空间复杂度: O(1)O(1)O(1)。只使用了常数个额外空间。或者栈版本的空间复杂度是 O(n)O(n)O(n)，因为需要存储所有节点。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:8:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-7"},{"categories":["算法","LeetCode"],"collections":null,"content":"24. 两两交换链表中的节点 - Mid ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:9:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#24-两两交换链表中的节点---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:9:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 两两交换链表节点的关键在于顺序。我们需要改动三个指针的指向才能完成一次完整的内部易位： 关键点解析 为什么 prev = node1？ 交换前顺序是：prev -\u0026gt; node1 -\u0026gt; node2 -\u0026gt; node3。 交换后顺序是：prev -\u0026gt; node2 -\u0026gt; node1 -\u0026gt; node3。 为了处理下一对，我们的 prev 必须移动到 node1 的位置，因为 node1 现在是下一对节点的“前驱”。 边界条件： 如果链表为空或只有一个节点，prev.Next 或 prev.Next.Next 会为 nil，循环直接不执行，返回原链表。符合预期。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:9:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func swapPairs(head *ListNode) *ListNode { // 1. 创建虚拟头节点，指向当前的 head dummy := \u0026amp;ListNode{Next: head} // prev 指向待交换的一对节点之前的一个位置 prev := dummy // 2. 只有当后面至少有两个节点时，才需要交换 for prev.Next != nil \u0026amp;\u0026amp; prev.Next.Next != nil { // 确定要交换的两个节点 node1 := prev.Next node2 := prev.Next.Next // 3. 执行交换逻辑 (三个指针的变动) // 第一步：让前驱指向第二个节点 prev.Next = node2 // 第二步：让第一个节点指向第三个节点 (node2.Next) node1.Next = node2.Next // 第三步：让第二个节点指向第一个节点 node2.Next = node1 // 4. 更新 prev，准备处理下一对 // 此时 node1 已经换到了后面，所以它就是下一对的前驱 prev = node1 } return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:9:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(n)O(n)O(n)。其中 n 是链表的长度，所有方法都需要遍历整个链表一次。 空间复杂度: O(1)O(1)O(1)。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:9:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-8"},{"categories":["算法","LeetCode"],"collections":null,"content":"25. K 个一组翻转链表 - Hard ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:10:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#25-k-个一组翻转链表---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:10:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 分治思想：将大问题拆解。 我们复用了之前学过的 reverse 函数来翻转长度为 kkk 的短链表。 断开连接 (end.Next = nil)：这是为了让 reverse 函数知道在哪里停止。 如果不切断，reverse 会一路翻转到整个链表的末尾。 重新桥接：pre.Next = reverse(start)：让上一组的结尾指向这一组翻转后的新头。 start.Next = nextGroup：让这一组翻转后的新尾（原 start）指向下一组的开头。 不足 kkk 个的处理：题目要求不足 kkk 个保持原样，所以 if end == nil { break } 的判断至关重要。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:10:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { // 1. 创建虚拟头节点 dummy := \u0026amp;ListNode{Next: head} // pre 指向每一组待翻转部分的前驱节点 pre := dummy // end 指向每一组待翻转部分的末尾节点 end := dummy for end.Next != nil { // 2. 尝试向后移动 end 指针 k 次，定位当前组的结尾 for i := 0; i \u0026lt; k \u0026amp;\u0026amp; end != nil; i++ { end = end.Next } // 如果剩余节点不足 k 个，则不需要翻转，直接结束 if end == nil { break } // 3. 记录当前组的起始节点和下一组的开头 start := pre.Next nextGroup := end.Next // 4. 断开当前组与后面部分的连接，以便进行翻转 end.Next = nil // 5. 翻转当前组，并接回原链表 // 翻转后的新头节点接到 pre.Next 上 pre.Next = reverse(start) // 翻转后的尾节点（即原 start）接到下一组开头上 start.Next = nextGroup // 6. 重置 pre 和 end，准备处理下一组 pre = start end = pre } return dummy.Next } // 辅助函数：翻转一个完整的单链表 func reverse(head *ListNode) *ListNode { var prev *ListNode curr := head for curr != nil { next := curr.Next curr.Next = prev prev = curr curr = next } return prev }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:10:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(n)O(n)O(n)。其中 n 是链表的长度。 空间复杂度: O(1)O(1)O(1)。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:10:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-9"},{"categories":["算法","LeetCode"],"collections":null,"content":"138. 随机链表的复制 - Mid ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:11:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#138-随机链表的复制---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random \u0026ndash;\u0026gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random \u0026ndash;\u0026gt; y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:11:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 这个算法通过将新旧节点交叉链接，巧妙地解决了 random 指针的定位问题： 原地克隆 (Interweaving)：我们在每个原节点 AAA 后面立即插入它的克隆节点 A′A\u0026#x27;A′。这样做的好处是，我们可以通过 A.NextA.NextA.Next 瞬间找到 A′A\u0026#x27;A′，而不需要任何哈希表映射。 建立随机链接 (Linking Randoms)：如果 A.RandomA.RandomA.Random 指向 CCC，那么显然 A′.RandomA\u0026#x27;.RandomA′.Random 应该指向 C′C\u0026#x27;C′。在我们的混合链表中，C′C\u0026#x27;C′ 就在 C.NextC.NextC.Next。所以逻辑就是：cur.Next.Random = cur.Random.Next。 拆解 (Decoupling)：最后一步类似于“拉链分拣”，我们需要小心地把奇数位置的节点连回原链表，把偶数位置的节点连成结果链表。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:11:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { if head == nil { return nil } // 1. 复制节点，插入到原节点之后 // A -\u0026gt; B -\u0026gt; C 变成 A -\u0026gt; A\u0026#39; -\u0026gt; B -\u0026gt; B\u0026#39; -\u0026gt; C -\u0026gt; C\u0026#39; cur := head for cur != nil { newNode := \u0026amp;Node{ Val: cur.Val, Next: cur.Next, } cur.Next = newNode cur = newNode.Next } // 2. 复制 random 指针 // 新节点的 random 应该指向原节点 random 的下一个节点（即对应的复制节点） cur = head for cur != nil { if cur.Random != nil { cur.Next.Random = cur.Random.Next } cur = cur.Next.Next } // 3. 拆分链表 // 将 A -\u0026gt; A\u0026#39; -\u0026gt; B -\u0026gt; B\u0026#39; 恢复为 A -\u0026gt; B 和 A\u0026#39; -\u0026gt; B\u0026#39; cur = head newHead := head.Next copyCur := newHead for cur != nil { // 恢复原链表的 Next cur.Next = cur.Next.Next cur = cur.Next // 恢复新链表的 Next if cur != nil { copyCur.Next = cur.Next copyCur = copyCur.Next } } return newHead }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:11:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(n)O(n)O(n)，其中 n 是链表的长度。 空间复杂度: O(1)O(1)O(1)，我们只使用了常数级别的额外空间。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:11:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-10"},{"categories":["算法","LeetCode"],"collections":null,"content":"148. 排序链表 - Mid ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:12:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#148-排序链表---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:12:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 归并排序在链表上比在数组上更有优势，因为链表合并只需要修改指针，不需要额外的数组空间。 切分 (Divide)通过快慢指针找到中点。注意点：为了防止死循环（特别是只有两个节点时），我们将 fast 初始化为 head.Next。这样对于两个节点 [4, 2]，slow 会停在 4，我们从 4 后面切断，成功分为 [4] 和 [2]。 递归 (Conquer)不断递归调用直到链表长度为 1（天然有序）。3. 合并 (Merge)将两个有序链表“穿针引线”式地合并。这步的时间复杂度是 O(n)O(n)O(n)。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:12:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { // 1. 递归终止条件：节点为空或只有一个节点 if head == nil || head.Next == nil { return head } // 2. 找到中点并切断链表 // 使用快慢指针，注意 fast 从 head.Next 开始，可以确保在偶数节点时 slow 停在前半段末尾 slow, fast := head, head.Next for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next } // tmp 是后半部分的头，断开 slow.Next 以彻底切分 mid := slow.Next slow.Next = nil // 3. 递归排序左右两半 left := sortList(head) right := sortList(mid) // 4. 合并两个已排序的链表 return merge(left, right) } // 辅助函数：合并两个有序链表（逻辑同 21 题） func merge(l1, l2 *ListNode) *ListNode { dummy := \u0026amp;ListNode{} curr := dummy for l1 != nil \u0026amp;\u0026amp; l2 != nil { if l1.Val \u0026lt; l2.Val { curr.Next = l1 l1 = l1.Next } else { curr.Next = l2 l2 = l2.Next } curr = curr.Next } if l1 != nil { curr.Next = l1 } else { curr.Next = l2 } return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:12:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(nlog⁡n)O(n \\log n)O(nlogn)。其中 n 是链表的长度。归并排序的时间复杂度是 O(nlog⁡n)O(n \\log n)O(nlogn)。 空间复杂度: O(log⁡n)O(\\log n)O(logn)。递归调用栈的空间复杂度是 O(log⁡n)O(\\log n)O(logn)。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:12:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-11"},{"categories":["算法","LeetCode"],"collections":null,"content":"23. 合并 K 个升序链表 - Hard ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:13:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#23-合并-k-个升序链表---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:13:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 优先队列+多路归并 核心逻辑多路赛马：想象 K 个赛道，每个赛道都已经按速度排好序了。我们只需要每次把每个赛道里最快的那匹马（头节点）拉出来比一下，挑出最快的一匹。 堆的作用：如果我们每次都手动遍历 K 个节点找最小值，时间复杂度是 O(K⋅N)O(K \\cdot N)O(K⋅N)。使用小顶堆，每次获取最小值并重新调整只需 O(log⁡K)O(\\log K)O(logK)。 动态维护：当一个链表的节点被取走后，我们需要立即把它的下一个节点（如果有）补充进堆里，确保堆中始终持有每个链表当前的“领头羊”。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:13:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现(Java) /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((n1,n2)-\u0026gt;n1.val-n2.val); int n = lists.length; ListNode newHead = new ListNode(); ListNode p = newHead; if (n == 0) { return null; } for (int i = 0; i \u0026lt; n; i++) { if (lists[i] != null) { pq.offer(lists[i]); } } while (!pq.isEmpty()) { ListNode node = pq.poll(); p.next = node; p = p.next; if (node.next != null) { pq.offer(node.next); } } return newHead.next; } }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:13:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现java"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现(Go) import \u0026#34;container/heap\u0026#34; /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 1. 定义一个类型（切片），用于实现堆接口 type ListNodeHeap []*ListNode // 实现 sort.Interface func (h ListNodeHeap) Len() int { return len(h) } func (h ListNodeHeap) Less(i, j int) bool { return h[i].Val \u0026lt; h[j].Val } func (h ListNodeHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } // 实现 heap.Interface 的 Push 和 Pop // 注意：Push 和 Pop 必须使用指针接收者，因为它们会修改切片的长度 func (h *ListNodeHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) } func (h *ListNodeHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } func mergeKLists(lists []*ListNode) *ListNode { // 2. 初始化小顶堆 h := \u0026amp;ListNodeHeap{} heap.Init(h) // 3. 将所有链表的头节点放入堆中 for _, l := range lists { if l != nil { heap.Push(h, l) } } // 4. 构建新链表 dummy := \u0026amp;ListNode{} curr := dummy for h.Len() \u0026gt; 0 { // 弹出堆顶（当前最小的节点） node := heap.Pop(h).(*ListNode) curr.Next = node curr = curr.Next // 如果该节点还有下一个节点，将其入堆 if node.Next != nil { heap.Push(h, node.Next) } } return dummy.Next }","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:13:4","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现go"},{"categories":["算法","LeetCode"],"collections":null,"content":"复杂度分析 时间复杂度: O(N log k)，其中 N 是所有链表中节点的总数，k 是链表的数量。每个节点都被插入和弹出堆一次，堆操作的时间复杂度是 O(log k)。 空间复杂度: O(k)，堆中最多存储 k 个节点。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:13:5","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#复杂度分析-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"146. LRU 缓存 - Mid ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:14:0","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#146-lru-缓存---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:14:1","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#题目回顾-13"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路 为什么用双向链表？如果用单链表，删除一个节点需要找到它的 prev，这需要 O(n)O(n)O(n) 遍历。而双向链表每个节点都存了 prev，删除操作是真正的 O(1)O(1)O(1)。 哨兵节点 (Dummy Nodes) 的妙用我们在头部和尾部各放一个不存数据的 head 和 tail。好处：在插入和删除节点时，不需要判断 if head == nil 或者 if node == tail，逻辑非常统一，能有效避免复杂的边界 Bug。 操作逻辑Get：在 Map 里找。找不到回 -1；找到了，把该节点从当前位置撕下来，插到 head 后面。Put：Key 已存在：更新值，提到 head。Key 不存在：新建节点插到 head。如果满了，把 tail.prev（最久没用的）删掉，并从 Map 里也删掉。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:14:2","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#核心思路-13"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 type Node struct { key, value int prev, next *Node } type LRUCache struct { capacity int cache map[int]*Node head, tail *Node // 虚拟头尾节点（哨兵） } func Constructor(capacity int) LRUCache { l := LRUCache{ capacity: capacity, cache: make(map[int]*Node), head: \u0026amp;Node{}, tail: \u0026amp;Node{}, } // 初始化哨兵节点，互相连接 l.head.next = l.tail l.tail.prev = l.head return l } func (this *LRUCache) Get(key int) int { if node, ok := this.cache[key]; ok { this.moveToHead(node) // 只要访问了，就提到最前面 return node.value } return -1 } func (this *LRUCache) Put(key int, value int) { if node, ok := this.cache[key]; ok { node.value = value this.moveToHead(node) } else { newNode := \u0026amp;Node{key: key, value: value} this.cache[key] = newNode this.addToHead(newNode) if len(this.cache) \u0026gt; this.capacity { removed := this.removeTail() delete(this.cache, removed.key) } } } // --- 内部辅助函数，处理链表节点的挪动 --- func (this *LRUCache) addToHead(node *Node) { node.prev = this.head node.next = this.head.next this.head.next.prev = node this.head.next = node } func (this *LRUCache) removeNode(node *Node) { node.prev.next = node.next node.next.prev = node.prev } func (this *LRUCache) moveToHead(node *Node) { this.removeNode(node) this.addToHead(node) } func (this *LRUCache) removeTail() *Node { node := this.tail.prev this.removeNode(node) return node } 时间复杂度：Get 和 Put 均为 O(1)O(1)O(1)。Map 查找是常数级，双向链表断开和重连指针也是常数级。 空间复杂度：O(capacity)O(capacity)O(capacity)。哈希表和链表最多同时存储 capacity + 2 个节点。 ","date":"2026-01-28","objectID":"/posts/2026-01-28-linked-list/:14:3","tags":["Go","链表","题解"],"title":"[Golang] LeetCode 热题 100 - 链表","uri":"/posts/2026-01-28-linked-list/#代码实现-12"},{"categories":["算法","LeetCode"],"collections":null,"content":"矩阵 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:0:0","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#矩阵"},{"categories":["算法","LeetCode"],"collections":null,"content":"73. 矩阵置零 - Mid ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:1:0","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#73-矩阵置零---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 示例 1： 输入： matrix = [[1,1,1],[1,0,1],[1,1,1]] 输出： [[1,0,1],[0,0,0],[1,0,1]] 示例 2： 输入： matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] 输出： [[0,0,0,0],[0,4,5,0],[0,3,1,0]] 进阶： 一个直观的解决方案是使用 O(mn)O(mn)O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m+n)O(m + n)O(m+n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个仅使用常量空间的解决方案吗？ ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:1:1","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：利用首行首列做标记 这道题的难点在于污染问题：如果我们一边遍历一边将 0 所在的行列置零，那么修改后的 0 会干扰后续的遍历，导致整个矩阵最后全变成了 0。 空间复杂度优化路径 O(MN)O(MN)O(MN) 空间：新建一个同样的矩阵做标记。太浪费。 O(M+N)O(M+N)O(M+N) 空间：使用两个布尔数组 row[] 和 col[]，分别记录哪一行、哪一列需要置零。 O(1)O(1)O(1) 空间：直接利用矩阵的第一行和第一列来替代上面的两个布尔数组。 算法流程 (O(1)O(1)O(1) 方案) 既然我们要用第一行和第一列来记录\u0026quot;该行/列是否需要置零\u0026quot;，那么第一行和第一列原本的状态（是否包含 0）就需要先被保存下来，否则会被后续的标记覆盖。 步骤如下： 记录首行首列状态： 定义两个变量 firstRowHasZero 和 firstColHasZero，遍历第一行和第一列，如果发现 0，则将对应的变量置为 true。 利用首行首列做标记： 遍历矩阵的其余部分（从 (1,1) 开始）。如果发现 matrix[i][j] == 0，就将它对应的行首 matrix[i][0] 和列首 matrix[0][j] 设为 0。 根据标记置零内部： 再次遍历矩阵的其余部分（从 (1,1) 开始）。检查当前位置对应的行首或列首是否为 0，如果是，则将 matrix[i][j] 置为 0。 处理首行首列： 最后，根据第 1 步记录的 firstRowHasZero 和 firstColHasZero，决定是否要将第一行或第一列全部置零。 注意：处理顺序很重要，必须先处理内部，最后再根据布尔变量处理首行首列，否则首行首列作为\u0026quot;控制位\u0026quot;如果先被置零了，内部的逻辑就乱了。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:1:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#核心思路利用首行首列做标记"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：利用首行首列做标记 这道题的难点在于污染问题：如果我们一边遍历一边将 0 所在的行列置零，那么修改后的 0 会干扰后续的遍历，导致整个矩阵最后全变成了 0。 空间复杂度优化路径 O(MN)O(MN)O(MN) 空间：新建一个同样的矩阵做标记。太浪费。 O(M+N)O(M+N)O(M+N) 空间：使用两个布尔数组 row[] 和 col[]，分别记录哪一行、哪一列需要置零。 O(1)O(1)O(1) 空间：直接利用矩阵的第一行和第一列来替代上面的两个布尔数组。 算法流程 (O(1)O(1)O(1) 方案) 既然我们要用第一行和第一列来记录\u0026quot;该行/列是否需要置零\u0026quot;，那么第一行和第一列原本的状态（是否包含 0）就需要先被保存下来，否则会被后续的标记覆盖。 步骤如下： 记录首行首列状态： 定义两个变量 firstRowHasZero 和 firstColHasZero，遍历第一行和第一列，如果发现 0，则将对应的变量置为 true。 利用首行首列做标记： 遍历矩阵的其余部分（从 (1,1) 开始）。如果发现 matrix[i][j] == 0，就将它对应的行首 matrix[i][0] 和列首 matrix[0][j] 设为 0。 根据标记置零内部： 再次遍历矩阵的其余部分（从 (1,1) 开始）。检查当前位置对应的行首或列首是否为 0，如果是，则将 matrix[i][j] 置为 0。 处理首行首列： 最后，根据第 1 步记录的 firstRowHasZero 和 firstColHasZero，决定是否要将第一行或第一列全部置零。 注意：处理顺序很重要，必须先处理内部，最后再根据布尔变量处理首行首列，否则首行首列作为\u0026quot;控制位\u0026quot;如果先被置零了，内部的逻辑就乱了。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:1:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#空间复杂度优化路径"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：利用首行首列做标记 这道题的难点在于污染问题：如果我们一边遍历一边将 0 所在的行列置零，那么修改后的 0 会干扰后续的遍历，导致整个矩阵最后全变成了 0。 空间复杂度优化路径 O(MN)O(MN)O(MN) 空间：新建一个同样的矩阵做标记。太浪费。 O(M+N)O(M+N)O(M+N) 空间：使用两个布尔数组 row[] 和 col[]，分别记录哪一行、哪一列需要置零。 O(1)O(1)O(1) 空间：直接利用矩阵的第一行和第一列来替代上面的两个布尔数组。 算法流程 (O(1)O(1)O(1) 方案) 既然我们要用第一行和第一列来记录\u0026quot;该行/列是否需要置零\u0026quot;，那么第一行和第一列原本的状态（是否包含 0）就需要先被保存下来，否则会被后续的标记覆盖。 步骤如下： 记录首行首列状态： 定义两个变量 firstRowHasZero 和 firstColHasZero，遍历第一行和第一列，如果发现 0，则将对应的变量置为 true。 利用首行首列做标记： 遍历矩阵的其余部分（从 (1,1) 开始）。如果发现 matrix[i][j] == 0，就将它对应的行首 matrix[i][0] 和列首 matrix[0][j] 设为 0。 根据标记置零内部： 再次遍历矩阵的其余部分（从 (1,1) 开始）。检查当前位置对应的行首或列首是否为 0，如果是，则将 matrix[i][j] 置为 0。 处理首行首列： 最后，根据第 1 步记录的 firstRowHasZero 和 firstColHasZero，决定是否要将第一行或第一列全部置零。 注意：处理顺序很重要，必须先处理内部，最后再根据布尔变量处理首行首列，否则首行首列作为\u0026quot;控制位\u0026quot;如果先被置零了，内部的逻辑就乱了。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:1:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#算法流程--方案"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func setZeroes(matrix [][]int) { if len(matrix) == 0 { return } m, n := len(matrix), len(matrix[0]) firstRowHasZero := false firstColHasZero := false // 1. 检查第一列是否有 0 for i := 0; i \u0026lt; m; i++ { if matrix[i][0] == 0 { firstColHasZero = true break } } // 2. 检查第一行是否有 0 for j := 0; j \u0026lt; n; j++ { if matrix[0][j] == 0 { firstRowHasZero = true break } } // 3. 使用第一行和第一列作为“看板”记录标记位 // 从 (1,1) 开始遍历，如果发现 0，就把对应的表头（第一行、第一列）置 0 for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { if matrix[i][j] == 0 { matrix[i][0] = 0 matrix[0][j] = 0 } } } // 4. 根据“看板”标记，将内部元素置零 for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 5. 独立处理第一行 if firstRowHasZero { for j := 0; j \u0026lt; n; j++ { matrix[0][j] = 0 } } // 6. 独立处理第一列 if firstColHasZero { for i := 0; i \u0026lt; m; i++ { matrix[i][0] = 0 } } }复杂度分析 时间复杂度: O(M×N)O(M \\times N)O(M×N)。我们对矩阵进行了几次遍历，但总体操作次数与元素总数呈线性关系。 空间复杂度: O(1)O(1)O(1)。我们只使用了两个布尔变量，利用矩阵本身的空间存储了状态，满足了进阶要求。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:2:0","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"54. 螺旋矩阵 - Mid ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:3:0","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#54-螺旋矩阵---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 输入： matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出： [1,2,3,6,9,8,7,4,5] 示例 2： 输入： matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出： [1,2,3,4,8,12,11,10,9,5,6,7] ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:3:1","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：四边界模拟法 这道题没有太多的算法技巧，本质上是一道模拟题。我们需要模拟一个机器人在矩阵中按照\u0026quot;右 -\u0026gt; 下 -\u0026gt; 左 -\u0026gt; 上\u0026quot;的顺序一直走，直到填满所有格子。 虽然思路简单，但如果不加设计地直接写，很容易陷入各种边界判断的泥潭（比如拐角处怎么处理、什么时候停止）。 最优雅的解法是设定四个边界： t (top)：上边界，初始为 0 b (bottom)：下边界，初始为 m-1 l (left)：左边界，初始为 0 r (right)：右边界，初始为 n-1 算法流程 我们要在一个循环中按照顺时针方向依次处理四条边。每处理完一条边，就将对应的边界向内收缩，并立即检查是否越界（越界意味着遍历结束）。 向右移动：遍历从 l 到 r。处理完后，上边界下移 (++t)。如果 t \u0026gt; b，说明上下边界交错，遍历结束。 向下移动：遍历从 t 到 b。处理完后，右边界左移 (--r)。如果 l \u0026gt; r，说明左右边界交错，遍历结束。 向左移动：遍历从 r 到 l。处理完后，下边界上移 (--b)。如果 t \u0026gt; b，遍历结束。 向上移动：遍历从 b 到 t。处理完后，左边界右移 (++l)。如果 l \u0026gt; r，遍历结束。 这种写法将边界检查巧妙地融合在每一步操作之后，不需要在循环头部写复杂的 count \u0026lt; total 判断，代码逻辑非常清晰。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:3:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#核心思路四边界模拟法"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：四边界模拟法 这道题没有太多的算法技巧，本质上是一道模拟题。我们需要模拟一个机器人在矩阵中按照\u0026quot;右 -\u0026gt; 下 -\u0026gt; 左 -\u0026gt; 上\u0026quot;的顺序一直走，直到填满所有格子。 虽然思路简单，但如果不加设计地直接写，很容易陷入各种边界判断的泥潭（比如拐角处怎么处理、什么时候停止）。 最优雅的解法是设定四个边界： t (top)：上边界，初始为 0 b (bottom)：下边界，初始为 m-1 l (left)：左边界，初始为 0 r (right)：右边界，初始为 n-1 算法流程 我们要在一个循环中按照顺时针方向依次处理四条边。每处理完一条边，就将对应的边界向内收缩，并立即检查是否越界（越界意味着遍历结束）。 向右移动：遍历从 l 到 r。处理完后，上边界下移 (++t)。如果 t \u0026gt; b，说明上下边界交错，遍历结束。 向下移动：遍历从 t 到 b。处理完后，右边界左移 (--r)。如果 l \u0026gt; r，说明左右边界交错，遍历结束。 向左移动：遍历从 r 到 l。处理完后，下边界上移 (--b)。如果 t \u0026gt; b，遍历结束。 向上移动：遍历从 b 到 t。处理完后，左边界右移 (++l)。如果 l \u0026gt; r，遍历结束。 这种写法将边界检查巧妙地融合在每一步操作之后，不需要在循环头部写复杂的 count \u0026lt; total 判断，代码逻辑非常清晰。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:3:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#算法流程"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func spiralOrder(matrix [][]int) []int { // 边界检查 if len(matrix) == 0 || len(matrix[0]) == 0 { return []int{} } m, n := len(matrix), len(matrix[0]) // 预分配切片容量，避免频繁扩容带来的性能开销 res := make([]int, 0, m*n) // 定义四个边界 t, b := 0, m-1 // Top, Bottom l, r := 0, n-1 // Left, Right for { // 1. 从左到右：遍历上边界所在的行 for i := l; i \u0026lt;= r; i++ { res = append(res, matrix[t][i]) } t++ // 上边界下移 if t \u0026gt; b { break } // 2. 从上到下：遍历右边界所在的列 for i := t; i \u0026lt;= b; i++ { res = append(res, matrix[i][r]) } r-- // 右边界左移 if l \u0026gt; r { break } // 3. 从右到左：遍历下边界所在的行 for i := r; i \u0026gt;= l; i-- { res = append(res, matrix[b][i]) } b-- // 下边界上移 if t \u0026gt; b { break } // 4. 从下到上：遍历左边界所在的列 for i := b; i \u0026gt;= t; i-- { res = append(res, matrix[i][l]) } l++ // 左边界右移 if l \u0026gt; r { break } } return res }复杂度分析 时间复杂度: O(M×N)O(M \\times N)O(M×N)。矩阵中的每个元素都被访问且仅被访问一次。 空间复杂度: O(1)O(1)O(1)。除了用于返回结果的 res 列表外，我们只使用了 4 个变量来记录边界，不需要额外的存储空间。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:3:3","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"48. 旋转图像 - Mid ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:4:0","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#48-旋转图像---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 输入： matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出： [[7,4,1],[8,5,2],[9,6,3]] 示例 2： 输入： matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出： [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:4:1","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：数学变换 这道题最直接的思路是找出每个元素旋转后的坐标规律。对于一个坐标为 (i, j) 的元素，顺时针旋转 90 度后，它的新位置是 (j, n-1-i)。 如果直接模拟这个过程，我们需要小心翼翼地进行四角交换，逻辑容易出错。 更优雅的解法是利用矩阵运算的性质。顺时针旋转 90 度可以拆解为两步简单的变换： 转置 (Transpose)：将矩阵的行列互换（沿对角线翻转）。 matrix[i][j] ↔\\leftrightarrow↔ matrix[j][i] 水平镜像 (Reverse Rows)：将每一行左右翻转。 matrix[i][j] ↔\\leftrightarrow↔ matrix[i][n-1-j] 演示过程： 假设输入为： 1 2 3 4 5 6 7 8 9第一步：转置（对角线翻转） 1 4 7 2 5 8 3 6 9第二步：每行左右翻转 7 4 1 8 5 2 9 6 3我们可以看到，结果正好是顺时针旋转 90 度的样子。这种方法代码非常简洁且不易出错。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:4:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#核心思路数学变换"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func rotate(matrix [][]int) { n := len(matrix) if n == 0 { return } // 1. 转置矩阵 (Transpose) // 沿着主对角线翻转，将 matrix[i][j] 与 matrix[j][i] 交换 for i := 0; i \u0026lt; n; i++ { for j := i + 1; j \u0026lt; n; j++ { // Go 的多重赋值直接完成交换 matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] } } // 2. 沿垂直轴翻转每一行 (Reflect) // 将每一行进行左右镜像对称交换 for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; n/2; j++ { // 对第 i 行的元素进行左右交换 matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j] } } }复杂度分析 时间复杂度: O(N2)O(N^2)O(N2)。 空间复杂度: O(1)O(1)O(1)。我们是原地修改矩阵，没有使用额外的存储空间。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:4:3","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"240. 搜索二维矩阵 II - Mid ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:5:0","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#240-搜索二维矩阵-ii---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 输入： matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出： true 示例 2： 输入： matrix = ... (同上), target = 20 输出： false ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:5:1","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：抽象 BST (从角落出发) 如果把矩阵的每一个位置看作一个节点，我们要利用\u0026quot;行有序\u0026quot;和\u0026quot;列有序\u0026quot;这两个条件来快速缩小查找范围。 如果我们从左上角出发，当前值小于 target 时，我们既可以向右走（变大），也可以向下走（变大），这就产生了歧义，无法确定唯一的搜索方向。 但是，如果我们选择左下角（或者右上角）作为起点，情况就完全不同了。 以左下角 (m-1, 0) 为例： 当前值 \u0026gt; target： 因为当前行是升序的，左下角已经是该行最小的数了，如果连它都比 target 大，说明这一行所有的数都比 target 大。 -\u0026gt; 结论：排除当前行，向上移动 (i--)。 当前值 \u0026lt; target： 因为当前列是升序的，左下角已经是该列最大的数了（在剩下的范围内），如果连它都比 target 小，说明这一列所有的数都比 target 小。 -\u0026gt; 结论：排除当前列，向右移动 (j++)。 这个过程就像是在遍历一棵二叉搜索树 (BST)，左下角就是根节点，往上走是找更小的（类似左子树），往右走是找更大的（类似右子树）。 算法流程 初始化指针 i 指向最后一行，j 指向第一列。 循环条件：只要 i 没有超出上边界，且 j 没有超出右边界。 比较 matrix[i][j] 和 target： 相等：找到目标，返回 true。 matrix[i][j] \u0026gt; target：i-- (往上找小的)。 matrix[i][j] \u0026lt; target：j++ (往右找大的)。 如果循环结束还没找到，返回 false。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:5:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#核心思路抽象-bst-从角落出发"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：抽象 BST (从角落出发) 如果把矩阵的每一个位置看作一个节点，我们要利用\u0026quot;行有序\u0026quot;和\u0026quot;列有序\u0026quot;这两个条件来快速缩小查找范围。 如果我们从左上角出发，当前值小于 target 时，我们既可以向右走（变大），也可以向下走（变大），这就产生了歧义，无法确定唯一的搜索方向。 但是，如果我们选择左下角（或者右上角）作为起点，情况就完全不同了。 以左下角 (m-1, 0) 为例： 当前值 \u0026gt; target： 因为当前行是升序的，左下角已经是该行最小的数了，如果连它都比 target 大，说明这一行所有的数都比 target 大。 -\u0026gt; 结论：排除当前行，向上移动 (i--)。 当前值 \u0026lt; target： 因为当前列是升序的，左下角已经是该列最大的数了（在剩下的范围内），如果连它都比 target 小，说明这一列所有的数都比 target 小。 -\u0026gt; 结论：排除当前列，向右移动 (j++)。 这个过程就像是在遍历一棵二叉搜索树 (BST)，左下角就是根节点，往上走是找更小的（类似左子树），往右走是找更大的（类似右子树）。 算法流程 初始化指针 i 指向最后一行，j 指向第一列。 循环条件：只要 i 没有超出上边界，且 j 没有超出右边界。 比较 matrix[i][j] 和 target： 相等：找到目标，返回 true。 matrix[i][j] \u0026gt; target：i-- (往上找小的)。 matrix[i][j] \u0026lt; target：j++ (往右找大的)。 如果循环结束还没找到，返回 false。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:5:2","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#算法流程-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func searchMatrix(matrix [][]int, target int) bool { // 基础边界检查 if len(matrix) == 0 || len(matrix[0]) == 0 { return false } m := len(matrix) n := len(matrix[0]) // 从左下角开始搜索 // i: 行索引，初始化为最后一行 // j: 列索引，初始化为第一列 i := m - 1 j := 0 // 只要索引在矩阵范围内，就持续收缩搜索范围 for i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n { current := matrix[i][j] if current == target { // 匹配成功 return true } else if current \u0026gt; target { // 当前值太大，因为该行右侧元素更火， // 排除当前行，向上移动 i-- } else { // current \u0026lt; target // 当前值太小，因为该列上方元素更小， // 排除当前列，向右移动 j++ } } // 走出边界还没找到，说明目标不存在 return false }复杂度分析 时间复杂度: O(M+N)O(M + N)O(M+N)。在最坏的情况下（比如目标值就在右上角，或者不存在），我们需要从左下角一路走到右上角。每次迭代要么行索引减少，要么列索引增加，最多移动 m + n 次。 空间复杂度: O(1)O(1)O(1)。只使用了常数个变量作为指针。 ","date":"2026-01-27","objectID":"/posts/2026-01-27-matrix/:5:3","tags":["Go","矩阵","题解"],"title":"[Golang] LeetCode 热题 100 - 矩阵","uri":"/posts/2026-01-27-matrix/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"普通数组 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:0:0","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#普通数组"},{"categories":["算法","LeetCode"],"collections":null,"content":"53. 最大子数组和 - Mid ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:1:0","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#53-最大子数组和---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入： nums = [-2,1,-3,4,-1,2,1,-5,4] 输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入： nums = [1] 输出： 1 示例 3： 输入： nums = [5,4,-1,7,8] 输出： 23 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:1:1","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：动态规划与贪心 这道题是动态规划的经典入门题。 如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 O(N2)O(N^2)O(N2)，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。 状态定义 我们要思考：以当前数字 nums[i] 结尾的子数组，它的最大和是多少？ 假设 dp[i] 表示以 nums[i] 结尾的连续子数组的最大和。那么对于 nums[i] 来说，它面临两个选择： 加入前面的队伍：如果前面的子数组和 dp[i-1] 是正数，那么加上它肯定比自己单干强，即 dp[i-1] + nums[i]。 另起炉灶：如果前面的子数组和 dp[i-1] 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 nums[i]。 状态转移方程 根据上述分析，我们可以得到状态转移方程： dp[i]=max⁡(dp[i−1]+nums[i],nums[i]) dp[i] = \\max(dp[i-1] + \\text{nums}[i], \\text{nums}[i]) dp[i]=max(dp[i−1]+nums[i],nums[i])空间优化 观察转移方程发现，当前状态 dp[i] 只与前一个状态 dp[i-1] 有关。因此，我们不需要维护一个完整的 dp 数组，只需要用一个变量 pre 来记录\u0026quot;前一个位置的最大子数组和\u0026quot;即可。这也就是代码中 pre 变量的作用。 这种一边遍历一边做决策（如果收益为负则舍弃）的思想，也体现了贪心算法的影子。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:1:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#核心思路动态规划与贪心"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：动态规划与贪心 这道题是动态规划的经典入门题。 如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 O(N2)O(N^2)O(N2)，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。 状态定义 我们要思考：以当前数字 nums[i] 结尾的子数组，它的最大和是多少？ 假设 dp[i] 表示以 nums[i] 结尾的连续子数组的最大和。那么对于 nums[i] 来说，它面临两个选择： 加入前面的队伍：如果前面的子数组和 dp[i-1] 是正数，那么加上它肯定比自己单干强，即 dp[i-1] + nums[i]。 另起炉灶：如果前面的子数组和 dp[i-1] 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 nums[i]。 状态转移方程 根据上述分析，我们可以得到状态转移方程： dp[i]=max⁡(dp[i−1]+nums[i],nums[i]) dp[i] = \\max(dp[i-1] + \\text{nums}[i], \\text{nums}[i]) dp[i]=max(dp[i−1]+nums[i],nums[i])空间优化 观察转移方程发现，当前状态 dp[i] 只与前一个状态 dp[i-1] 有关。因此，我们不需要维护一个完整的 dp 数组，只需要用一个变量 pre 来记录\u0026quot;前一个位置的最大子数组和\u0026quot;即可。这也就是代码中 pre 变量的作用。 这种一边遍历一边做决策（如果收益为负则舍弃）的思想，也体现了贪心算法的影子。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:1:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#状态定义"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：动态规划与贪心 这道题是动态规划的经典入门题。 如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 O(N2)O(N^2)O(N2)，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。 状态定义 我们要思考：以当前数字 nums[i] 结尾的子数组，它的最大和是多少？ 假设 dp[i] 表示以 nums[i] 结尾的连续子数组的最大和。那么对于 nums[i] 来说，它面临两个选择： 加入前面的队伍：如果前面的子数组和 dp[i-1] 是正数，那么加上它肯定比自己单干强，即 dp[i-1] + nums[i]。 另起炉灶：如果前面的子数组和 dp[i-1] 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 nums[i]。 状态转移方程 根据上述分析，我们可以得到状态转移方程： dp[i]=max⁡(dp[i−1]+nums[i],nums[i]) dp[i] = \\max(dp[i-1] + \\text{nums}[i], \\text{nums}[i]) dp[i]=max(dp[i−1]+nums[i],nums[i])空间优化 观察转移方程发现，当前状态 dp[i] 只与前一个状态 dp[i-1] 有关。因此，我们不需要维护一个完整的 dp 数组，只需要用一个变量 pre 来记录\u0026quot;前一个位置的最大子数组和\u0026quot;即可。这也就是代码中 pre 变量的作用。 这种一边遍历一边做决策（如果收益为负则舍弃）的思想，也体现了贪心算法的影子。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:1:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#状态转移方程"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：动态规划与贪心 这道题是动态规划的经典入门题。 如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 O(N2)O(N^2)O(N2)，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。 状态定义 我们要思考：以当前数字 nums[i] 结尾的子数组，它的最大和是多少？ 假设 dp[i] 表示以 nums[i] 结尾的连续子数组的最大和。那么对于 nums[i] 来说，它面临两个选择： 加入前面的队伍：如果前面的子数组和 dp[i-1] 是正数，那么加上它肯定比自己单干强，即 dp[i-1] + nums[i]。 另起炉灶：如果前面的子数组和 dp[i-1] 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 nums[i]。 状态转移方程 根据上述分析，我们可以得到状态转移方程： dp[i]=max⁡(dp[i−1]+nums[i],nums[i]) dp[i] = \\max(dp[i-1] + \\text{nums}[i], \\text{nums}[i]) dp[i]=max(dp[i−1]+nums[i],nums[i])空间优化 观察转移方程发现，当前状态 dp[i] 只与前一个状态 dp[i-1] 有关。因此，我们不需要维护一个完整的 dp 数组，只需要用一个变量 pre 来记录\u0026quot;前一个位置的最大子数组和\u0026quot;即可。这也就是代码中 pre 变量的作用。 这种一边遍历一边做决策（如果收益为负则舍弃）的思想，也体现了贪心算法的影子。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:1:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#空间优化"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func maxSubArray(nums []int) int { pre := 0 maxAns := nums[0] for _, x := range nums { pre = max(pre+x, x) maxAns = max(pre, maxAns) } return maxAns }复杂度分析 时间复杂度: O(N)O(N)O(N)。我们只需要遍历数组一次 空间复杂度: O(1)O(1)O(1)。我们只使用了常数个变量，没有使用额外的数组空间（如果使用标准的 DP 数组则是 O(N)O(N)O(N)）。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:1:3","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"56. 合并区间 - Mid ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:2:0","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#56-合并区间---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [start_i, end_i] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 示例 1： 输入： intervals = [[1,3],[2,6],[8,10],[15,18]] 输出： [[1,6],[8,10],[15,18]] 解释： 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入： intervals = [[1,4],[4,5]] 输出： [[1,5]] 解释： 区间 [1,4] 和 [4,5] 可被视为重叠区间。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:2:1","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：排序 + 贪心 区间问题最常见的痛点在于：输入的区间可能是乱序的。如果乱序处理，我们需要两两比较，复杂度会飙升到 O(N2)O(N^2)O(N2)。 解决此类问题的\u0026quot;银弹\u0026quot;通常是先排序. 1. 预处理：排序 我们首先按照区间的**左端点（Start Time）**进行从小到大的排序。 排序后，重叠的区间在数组中一定是相邻的。这使得我们只需要进行一次线性扫描就能完成合并。 2. 遍历与合并 我们维护一个结果集 res，并遍历排序后的区间列表： 初始状态：如果 res 为空，直接将当前区间加入。 无重叠：如果当前区间的左端点大于结果集中最后一个区间的右端点，说明它们断开了，没有交集。直接将当前区间加入 res。 有重叠：如果当前区间的左端点小于等于结果集中最后一个区间的右端点，说明发生了重叠（或者通过端点相连）。 此时我们需要合并：更新结果集中最后一个区间的右端点。 新的右端点应该是两者右端点的最大值：max(last_interval.end, current_interval.end)。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:2:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#核心思路排序--贪心"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func merge(intervals [][]int) [][]int { // 边界检查：如果为空直接返回 if len(intervals) == 0 { return nil } // 1. 按照区间左端点进行排序 // 使用 sort.Slice 进行排序，传入 less 函数 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) // res 用于存储合并后的结果 // 预分配 capacity 可以略微提升性能，但不是必须的 var res [][]int // 2. 遍历排序后的区间 for _, interval := range intervals { l, r := interval[0], interval[1] // 如果结果集为空，或者当前区间的左端点 \u0026gt; 结果集最后一个区间的右端点 // 说明没有重叠，直接添加新的区间 if len(res) == 0 || l \u0026gt; res[len(res)-1][1] { res = append(res, []int{l, r}) } else { // 发生重叠，我们需要合并区间 // 修改结果集中最后一个区间的右端点：取 max(当前右端点, 存量右端点) if r \u0026gt; res[len(res)-1][1] { res[len(res)-1][1] = r } } } return res }复杂度分析 时间复杂度: O(Nlog⁡N)O(N \\log N)O(NlogN)。虽然遍历是一次线性的 O(N)O(N)O(N)，但排序的开销是 O(Nlog⁡N)O(N \\log N)O(NlogN)，它是整个算法的瓶颈。 空间复杂度: O(log⁡N)O(\\log N)O(logN)。这里指的是 Java 排序算法（通常是快排或归并排序的变种）所需的栈空间。如果算上存储结果的 res 列表，则是 O(N)O(N)O(N)。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:2:3","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"189. 轮转数组 - Mid ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:3:0","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#189-轮转数组---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入： nums = [-1,-100,3,99], k = 2 输出： [3,99,-1,-100] ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:3:1","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：三次翻转法 这道题最直观的解法是使用一个额外的数组，将每个元素放到正确的位置，但这需要 O(N)O(N)O(N) 的空间。 如果要求原地算法（O(1)O(1)O(1) 空间），最经典且容易理解的方法是数组翻转法。 我们可以观察一下规律，以 nums = [1,2,3,4,5,6,7], k = 3 为例： 原始数组：[1, 2, 3, 4, 5, 6, 7] 我们可以把数组分为两部分： 第一部分（前 n-k 个）：[1, 2, 3, 4] 第二部分（后 k 个）：[5, 6, 7] (这部分实际上是要移动到数组头部的) 第一步：整体翻转 将整个数组翻转： [7, 6, 5, 4, 3, 2, 1] 此时，原本在尾部的 [5, 6, 7] 跑到了头部，但是顺序是反的（7, 6, 5）。原本在头部的 [1, 2, 3, 4] 跑到了尾部，顺序也是反的（4, 3, 2, 1）。 第二步：翻转前 k 个元素 我们将前 k 个元素（下标 0 到 k-1）再次翻转： [5, 6, 7, 4, 3, 2, 1] 此时，头部元素顺序恢复正常。 第三步：翻转剩余元素 我们将剩下的元素（下标 k 到 n-1）再次翻转： [5, 6, 7, 1, 2, 3, 4] 此时，尾部元素顺序也恢复正常，得到最终结果。 注意事项： 如果 k 大于数组长度 n，轮转 k 次等于轮转 k % n 次。所以在开始处理前，需要先执行 k %= n。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:3:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#核心思路三次翻转法"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func rotate(nums []int, k int) { n := len(nums) if n == 0 { return } // 处理 k \u0026gt; n 的情况 // 比如长度 5，轮转 6 次 等于 轮转 1 次 k %= n // 核心逻辑：三次翻转 // 1. 翻转整个数组 reverse(nums, 0, n-1) // 2. 翻转前 k 个元素 reverse(nums, 0, k-1) // 3. 翻转剩余元素 reverse(nums, k, n-1) } // 辅助函数：翻转 nums 中 [start, end] 区间的元素 func reverse(nums []int, start, end int) { for start \u0026lt; end { // Go 语言特有的元组赋值（Tuple Assignment），无需临时变量即可交换 nums[start], nums[end] = nums[end], nums[start] start++ end-- } }复杂度分析 时间复杂度: O(N)O(N)O(N)。我们需要遍历数组三次（一次整体，两次局部），每次操作都是线性的，总时间复杂度为 O(N)O(N)O(N)。 空间复杂度: O(1)O(1)O(1)。我们只使用了常数个额外变量进行交换操作，没有使用额外的数组空间。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:3:3","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"238. 除了自身以外数组的乘积 - Mid ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:4:0","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#238-除了自身以外数组的乘积---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除了 nums[i] 之外其余各元素的乘积。 题目数据 保证 数组 nums 之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(n)O(n)O(n) 时间复杂度内完成此题。 示例 1: 输入: nums = [1,2,3,4] 输出: [24,12,8,6] 示例 2: 输入: nums = [-1,1,0,-3,3] 输出: [0,0,9,0,0] ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:4:1","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：左右乘积列表 这道题如果允许使用除法，那非常简单：算出所有元素的总乘积，然后除以当前元素即可（注意需要处理 0 的情况）。但题目明确禁止除法，我们需要另辟蹊径。 对于数组中的任意一个元素 nums[i]，除了它自身以外的乘积，实际上等于： （它左边所有元素的乘积） ×\\times× （它右边所有元素的乘积） 因此，我们可以通过两次遍历来解决这个问题： 计算后缀积：先算出每个位置右边所有元素的乘积。 计算前缀积并合并：再算出每个位置左边所有元素的乘积，并乘上刚才算好的后缀积。 空间优化 (O(1)O(1)O(1) 额外空间) 为了满足进阶要求的 O(1)O(1)O(1) 额外空间（输出数组不计入空间复杂度），我们可以直接利用返回的数组 answer（代码中为 suf）来作为中间容器。 第一轮遍历（从右向左）： 我们在 suf 数组中存储后缀积。 suf[i] 表示 i 之后所有元素的乘积。 初始化 suf[n-1] = 1（因为最后一个元素右边没有元素）。 第二轮遍历（从左向右）： 我们使用一个变量 pre 来动态维护前缀积。 对于每个位置 i，suf[i] 目前存储的是\u0026quot;右边的积\u0026quot;。 我们只需要执行 suf[i] = suf[i] * pre，就可以得到\u0026quot;右边的积 ×\\times× 左边的积\u0026quot;。 然后更新 pre，将其乘上 nums[i]，为下一个位置做准备。 这样，我们只需要遍历两次，且不需要额外开辟数组空间。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:4:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#核心思路左右乘积列表"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：左右乘积列表 这道题如果允许使用除法，那非常简单：算出所有元素的总乘积，然后除以当前元素即可（注意需要处理 0 的情况）。但题目明确禁止除法，我们需要另辟蹊径。 对于数组中的任意一个元素 nums[i]，除了它自身以外的乘积，实际上等于： （它左边所有元素的乘积） ×\\times× （它右边所有元素的乘积） 因此，我们可以通过两次遍历来解决这个问题： 计算后缀积：先算出每个位置右边所有元素的乘积。 计算前缀积并合并：再算出每个位置左边所有元素的乘积，并乘上刚才算好的后缀积。 空间优化 (O(1)O(1)O(1) 额外空间) 为了满足进阶要求的 O(1)O(1)O(1) 额外空间（输出数组不计入空间复杂度），我们可以直接利用返回的数组 answer（代码中为 suf）来作为中间容器。 第一轮遍历（从右向左）： 我们在 suf 数组中存储后缀积。 suf[i] 表示 i 之后所有元素的乘积。 初始化 suf[n-1] = 1（因为最后一个元素右边没有元素）。 第二轮遍历（从左向右）： 我们使用一个变量 pre 来动态维护前缀积。 对于每个位置 i，suf[i] 目前存储的是\u0026quot;右边的积\u0026quot;。 我们只需要执行 suf[i] = suf[i] * pre，就可以得到\u0026quot;右边的积 ×\\times× 左边的积\u0026quot;。 然后更新 pre，将其乘上 nums[i]，为下一个位置做准备。 这样，我们只需要遍历两次，且不需要额外开辟数组空间。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:4:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#空间优化--额外空间"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func productExceptSelf(nums []int) []int { n := len(nums) // 初始化结果数组，在 Go 中切片默认值为 0 res := make([]int, n) // 1. 计算后缀积 (Suffix Product) // res[i] 存储的是 nums[i] 右侧所有元素的乘积 res[n-1] = 1 for i := n - 2; i \u0026gt;= 0; i-- { res[i] = res[i+1] * nums[i+1] } // 2. 计算前缀积 (Prefix Product) 并与后缀积相乘 // pre 变量动态维护当前位置左侧所有元素的乘积 pre := 1 for i := 0; i \u0026lt; n; i++ { // 核心公式：结果 = 左侧积 * 右侧积 res[i] *= pre // 为下一次循环更新前缀积（包含当前 nums[i]） pre *= nums[i] } return res }复杂度分析 时间复杂度: O(N)O(N)O(N)。我们对数组进行了两次遍历。 空间复杂度: O(1)O(1)O(1)。除了用于返回答案的数组 suf 外，我们只使用了常数级别的额外变量（n, pre, i）。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:4:3","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"41. 缺失的第一个正数 - Hard ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:5:0","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#41-缺失的第一个正数---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n)O(n)O(n) 并且只使用常数级别额外空间的解决方案。 示例 1： 输入： nums = [1,2,0] 输出： 3 解释： 范围 [1,2] 中的数字都在数组中。 示例 2： 输入： nums = [3,4,-1,1] 输出： 2 解释： 1 在数组中，但 2 没有。 示例 3： 输入： nums = [7,8,9,11,12] 输出： 1 解释： 最小的正数 1 没有出现。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:5:1","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#题目回顾-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：原地哈希（萝卜坑） 这道题的难点在于限制条件：时间 O(N)O(N)O(N) 且 空间 O(1)O(1)O(1)。 如果允许 O(Nlog⁡N)O(N \\log N)O(NlogN) 时间，我们可以直接排序。 如果允许 O(N)O(N)O(N) 空间，我们可以用 HashSet 记录出现过的数字。 为了满足双重限制，我们需要利用数组本身作为哈希表。 关键推论 对于一个长度为 N 的数组，缺失的第一个正数一定在 [1, N + 1] 这个范围内。 最理想的情况是 [1, 2, ..., N] 都出现了，那么缺失的是 N + 1。 否则，缺失的数字一定在 [1, N] 之间。 算法流程 我们可以把数组当作一个个“坑位”。 索引 0 的坑应该放数字 1。 索引 1 的坑应该放数字 2。 \u0026hellip; 索引 i 的坑应该放数字 i + 1。 我们的目标就是遍历数组，通过交换，尽可能把每个数字放到它该去的坑里。 归位（交换）： 遍历数组，对于当前数字 x = nums[i]，如果它满足以下三个条件，就把它交换到正确的位置 x - 1 上： x 是正数 (x \u0026gt;= 1)。 x 在有效范围内 (x \u0026lt;= N)。 x 还没有呆在正确的位置上 (nums[x - 1] != x) —— 这一步同时也避免了死循环（处理重复元素）。 注意：交换过来后，新的 nums[i] 可能还是需要交换的，所以这里要用 while 循环不断交换，直到当前位置无法进行交换为止。 查找： 再次遍历数组，检查每个坑位。如果发现 nums[i] != i + 1，说明这个坑位原本该有的数字 i + 1 缺失了，直接返回 i + 1。 兜底： 如果所有坑位都填满了正确的数字，说明缺失的是 N + 1。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:5:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#核心思路原地哈希萝卜坑"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：原地哈希（萝卜坑） 这道题的难点在于限制条件：时间 O(N)O(N)O(N) 且 空间 O(1)O(1)O(1)。 如果允许 O(Nlog⁡N)O(N \\log N)O(NlogN) 时间，我们可以直接排序。 如果允许 O(N)O(N)O(N) 空间，我们可以用 HashSet 记录出现过的数字。 为了满足双重限制，我们需要利用数组本身作为哈希表。 关键推论 对于一个长度为 N 的数组，缺失的第一个正数一定在 [1, N + 1] 这个范围内。 最理想的情况是 [1, 2, ..., N] 都出现了，那么缺失的是 N + 1。 否则，缺失的数字一定在 [1, N] 之间。 算法流程 我们可以把数组当作一个个“坑位”。 索引 0 的坑应该放数字 1。 索引 1 的坑应该放数字 2。 \u0026hellip; 索引 i 的坑应该放数字 i + 1。 我们的目标就是遍历数组，通过交换，尽可能把每个数字放到它该去的坑里。 归位（交换）： 遍历数组，对于当前数字 x = nums[i]，如果它满足以下三个条件，就把它交换到正确的位置 x - 1 上： x 是正数 (x \u0026gt;= 1)。 x 在有效范围内 (x \u0026lt;= N)。 x 还没有呆在正确的位置上 (nums[x - 1] != x) —— 这一步同时也避免了死循环（处理重复元素）。 注意：交换过来后，新的 nums[i] 可能还是需要交换的，所以这里要用 while 循环不断交换，直到当前位置无法进行交换为止。 查找： 再次遍历数组，检查每个坑位。如果发现 nums[i] != i + 1，说明这个坑位原本该有的数字 i + 1 缺失了，直接返回 i + 1。 兜底： 如果所有坑位都填满了正确的数字，说明缺失的是 N + 1。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:5:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#关键推论"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：原地哈希（萝卜坑） 这道题的难点在于限制条件：时间 O(N)O(N)O(N) 且 空间 O(1)O(1)O(1)。 如果允许 O(Nlog⁡N)O(N \\log N)O(NlogN) 时间，我们可以直接排序。 如果允许 O(N)O(N)O(N) 空间，我们可以用 HashSet 记录出现过的数字。 为了满足双重限制，我们需要利用数组本身作为哈希表。 关键推论 对于一个长度为 N 的数组，缺失的第一个正数一定在 [1, N + 1] 这个范围内。 最理想的情况是 [1, 2, ..., N] 都出现了，那么缺失的是 N + 1。 否则，缺失的数字一定在 [1, N] 之间。 算法流程 我们可以把数组当作一个个“坑位”。 索引 0 的坑应该放数字 1。 索引 1 的坑应该放数字 2。 \u0026hellip; 索引 i 的坑应该放数字 i + 1。 我们的目标就是遍历数组，通过交换，尽可能把每个数字放到它该去的坑里。 归位（交换）： 遍历数组，对于当前数字 x = nums[i]，如果它满足以下三个条件，就把它交换到正确的位置 x - 1 上： x 是正数 (x \u0026gt;= 1)。 x 在有效范围内 (x \u0026lt;= N)。 x 还没有呆在正确的位置上 (nums[x - 1] != x) —— 这一步同时也避免了死循环（处理重复元素）。 注意：交换过来后，新的 nums[i] 可能还是需要交换的，所以这里要用 while 循环不断交换，直到当前位置无法进行交换为止。 查找： 再次遍历数组，检查每个坑位。如果发现 nums[i] != i + 1，说明这个坑位原本该有的数字 i + 1 缺失了，直接返回 i + 1。 兜底： 如果所有坑位都填满了正确的数字，说明缺失的是 N + 1。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:5:2","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#算法流程"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func firstMissingPositive(nums []int) int { n := len(nums) // 1. 原地哈希 (In-place Hash) // 目标：尝试让 nums[i] 存储数字 i + 1 for i := 0; i \u0026lt; n; i++ { // 使用 for 循环（对应 Java 的 while） // 如果当前数字 nums[i] 在 [1, n] 范围内， // 且它不在它应该在的位置（index 为 nums[i]-1），则进行交换 for nums[i] \u0026gt;= 1 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[i] != nums[nums[i]-1] { // Go 的多重赋值特性，可以直接完成交换，无需手动写 swap 函数 nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] } } // 2. 遍历检查 // 第一个 nums[i] != i + 1 的位置，说明缺失了 i + 1 for i := 0; i \u0026lt; n; i++ { if nums[i] != i + 1 { return i + 1 } } // 3. 如果 1 到 n 都在正确位置，说明缺失的是 n + 1 return n + 1 }复杂度分析 时间复杂度: O(N)O(N)O(N)。初看代码里有 for 循环，似乎是 O(N2)O(N^2)O(N2)？其实不然。每个数字最多只会被交换一次到它正确的位置上。一旦它到了正确位置，就不会再被移动。因此所有元素的总交换次数不会超过 NNN 次。均摊下来是 O(N)O(N)O(N)。 空间复杂度: O(1)O(1)O(1)。我们直接修改了输入数组，没有使用额外的线性空间。 ","date":"2026-01-26","objectID":"/posts/2026-01-26-array/:5:3","tags":["Go","普通数组","题解","动态规划","贪心"],"title":"[Golang] LeetCode 热题 100 - 普通数组","uri":"/posts/2026-01-26-array/#代码实现-4"},{"categories":["算法","LeetCode"],"collections":null,"content":"子串 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:0:0","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#子串"},{"categories":["算法","LeetCode"],"collections":null,"content":"560. 和为 K 的子数组 - Mid ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:1:0","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#560-和为-k-的子数组---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 示例 1： 输入： nums = [1,1,1], k = 2 输出： 2 示例 2： 输入： nums = [1,2,3], k = 3 输出： 2 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:1:1","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：前缀和 + 哈希表优化 这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 O(n2)O(n^2)O(n2) 甚至 O(n3)O(n^3)O(n3)，无法通过所有测试用例。我们需要利用前缀和的性质进行优化。 1. 前缀和转化 定义 pre[i] 为 [0..i] 里所有数的和。那么 [j..i] 这个子数组的和可以表示为： sum[j..i]=pre[i]−pre[j−1] sum[j..i] = pre[i] - pre[j-1] sum[j..i]=pre[i]−pre[j−1] 题目要求找到和为 k 的子数组，即寻找满足以下条件的 j 和 i： pre[i]−pre[j−1]==k pre[i] - pre[j-1] == k pre[i]−pre[j−1]==k 移项得： pre[j−1]==pre[i]−k pre[j-1] == pre[i] - k pre[j−1]==pre[i]−k2. 哈希表优化 这意味着，当我们遍历到位置 i 时，我们需要统计在 i 之前，有多少个位置 j-1 的前缀和等于 pre[i] - k。 为了快速查找和统计，我们可以使用一个 哈希表 (HashMap)： Key: 前缀和的值。 Value: 该前缀和出现的次数。 3. 算法流程 初始化变量 sum = 0 (当前前缀和) 和 count = 0 (结果计数)。 初始化哈希表 map，并预先插入 map.put(0, 1)。 重点解释：这是为了处理那些从数组下标 0 开始的子数组。如果某个子数组就是 nums[0..i] 且和为 k，那么 pre[i] - k 将等于 0。我们需要保证这种情况下能找到匹配项。 遍历数组 nums： 累加计算当前前缀和 sum。 查询 map 中是否存在 sum - k。如果存在，说明找到了对应个数的子数组，将 map.get(sum - k) 累加到 count 中。 将当前的 sum 存入 map，更新其出现次数。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:1:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#核心思路前缀和--哈希表优化"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：前缀和 + 哈希表优化 这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 O(n2)O(n^2)O(n2) 甚至 O(n3)O(n^3)O(n3)，无法通过所有测试用例。我们需要利用前缀和的性质进行优化。 1. 前缀和转化 定义 pre[i] 为 [0..i] 里所有数的和。那么 [j..i] 这个子数组的和可以表示为： sum[j..i]=pre[i]−pre[j−1] sum[j..i] = pre[i] - pre[j-1] sum[j..i]=pre[i]−pre[j−1] 题目要求找到和为 k 的子数组，即寻找满足以下条件的 j 和 i： pre[i]−pre[j−1]==k pre[i] - pre[j-1] == k pre[i]−pre[j−1]==k 移项得： pre[j−1]==pre[i]−k pre[j-1] == pre[i] - k pre[j−1]==pre[i]−k2. 哈希表优化 这意味着，当我们遍历到位置 i 时，我们需要统计在 i 之前，有多少个位置 j-1 的前缀和等于 pre[i] - k。 为了快速查找和统计，我们可以使用一个 哈希表 (HashMap)： Key: 前缀和的值。 Value: 该前缀和出现的次数。 3. 算法流程 初始化变量 sum = 0 (当前前缀和) 和 count = 0 (结果计数)。 初始化哈希表 map，并预先插入 map.put(0, 1)。 重点解释：这是为了处理那些从数组下标 0 开始的子数组。如果某个子数组就是 nums[0..i] 且和为 k，那么 pre[i] - k 将等于 0。我们需要保证这种情况下能找到匹配项。 遍历数组 nums： 累加计算当前前缀和 sum。 查询 map 中是否存在 sum - k。如果存在，说明找到了对应个数的子数组，将 map.get(sum - k) 累加到 count 中。 将当前的 sum 存入 map，更新其出现次数。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:1:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#1-前缀和转化"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：前缀和 + 哈希表优化 这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 O(n2)O(n^2)O(n2) 甚至 O(n3)O(n^3)O(n3)，无法通过所有测试用例。我们需要利用前缀和的性质进行优化。 1. 前缀和转化 定义 pre[i] 为 [0..i] 里所有数的和。那么 [j..i] 这个子数组的和可以表示为： sum[j..i]=pre[i]−pre[j−1] sum[j..i] = pre[i] - pre[j-1] sum[j..i]=pre[i]−pre[j−1] 题目要求找到和为 k 的子数组，即寻找满足以下条件的 j 和 i： pre[i]−pre[j−1]==k pre[i] - pre[j-1] == k pre[i]−pre[j−1]==k 移项得： pre[j−1]==pre[i]−k pre[j-1] == pre[i] - k pre[j−1]==pre[i]−k2. 哈希表优化 这意味着，当我们遍历到位置 i 时，我们需要统计在 i 之前，有多少个位置 j-1 的前缀和等于 pre[i] - k。 为了快速查找和统计，我们可以使用一个 哈希表 (HashMap)： Key: 前缀和的值。 Value: 该前缀和出现的次数。 3. 算法流程 初始化变量 sum = 0 (当前前缀和) 和 count = 0 (结果计数)。 初始化哈希表 map，并预先插入 map.put(0, 1)。 重点解释：这是为了处理那些从数组下标 0 开始的子数组。如果某个子数组就是 nums[0..i] 且和为 k，那么 pre[i] - k 将等于 0。我们需要保证这种情况下能找到匹配项。 遍历数组 nums： 累加计算当前前缀和 sum。 查询 map 中是否存在 sum - k。如果存在，说明找到了对应个数的子数组，将 map.get(sum - k) 累加到 count 中。 将当前的 sum 存入 map，更新其出现次数。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:1:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#2-哈希表优化"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：前缀和 + 哈希表优化 这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 O(n2)O(n^2)O(n2) 甚至 O(n3)O(n^3)O(n3)，无法通过所有测试用例。我们需要利用前缀和的性质进行优化。 1. 前缀和转化 定义 pre[i] 为 [0..i] 里所有数的和。那么 [j..i] 这个子数组的和可以表示为： sum[j..i]=pre[i]−pre[j−1] sum[j..i] = pre[i] - pre[j-1] sum[j..i]=pre[i]−pre[j−1] 题目要求找到和为 k 的子数组，即寻找满足以下条件的 j 和 i： pre[i]−pre[j−1]==k pre[i] - pre[j-1] == k pre[i]−pre[j−1]==k 移项得： pre[j−1]==pre[i]−k pre[j-1] == pre[i] - k pre[j−1]==pre[i]−k2. 哈希表优化 这意味着，当我们遍历到位置 i 时，我们需要统计在 i 之前，有多少个位置 j-1 的前缀和等于 pre[i] - k。 为了快速查找和统计，我们可以使用一个 哈希表 (HashMap)： Key: 前缀和的值。 Value: 该前缀和出现的次数。 3. 算法流程 初始化变量 sum = 0 (当前前缀和) 和 count = 0 (结果计数)。 初始化哈希表 map，并预先插入 map.put(0, 1)。 重点解释：这是为了处理那些从数组下标 0 开始的子数组。如果某个子数组就是 nums[0..i] 且和为 k，那么 pre[i] - k 将等于 0。我们需要保证这种情况下能找到匹配项。 遍历数组 nums： 累加计算当前前缀和 sum。 查询 map 中是否存在 sum - k。如果存在，说明找到了对应个数的子数组，将 map.get(sum - k) 累加到 count 中。 将当前的 sum 存入 map，更新其出现次数。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:1:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#3-算法流程"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func subarraySum(nums []int, k int) int { // countMap: key 是前缀和, value 是该前缀和出现的次数 countMap := make(map[int]int) // 初始化：前缀和为 0 默认出现 1 次 // 这是为了处理从数组第一个元素开始就满足和为 k 的情况 countMap[0] = 1 count := 0 preSum := 0 for _, num := range nums { preSum += num // 如果 preSum - k 在 map 中存在，说明从某个旧的前缀和到当前位置的子数组和为 k if v, ok := countMap[preSum-k]; ok { count += v } // 更新当前前缀和出现的次数 countMap[preSum]++ } return count }复杂度分析 时间复杂度: O(n)O(n)O(n)。我们只需要遍历数组一次，哈希表的插入和查询操作平均时间复杂度为 O(1)O(1)O(1)。 空间复杂度: O(n)O(n)O(n)。哈希表在最坏情况下（所有前缀和都不同）需要存储 n 个键值对。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:1:3","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"239. 滑动窗口最大值 - Hard ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:2:0","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#239-滑动窗口最大值---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例： 输入： nums = [1,3,-1,-3,5,3,6,7], k = 3 输出： [3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:2:1","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：单调队列（Monotonic Deque） 本题的难点在于：如何在 O(1)O(1)O(1) 时间内动态维护滑动窗口的最大值？ 若对每个窗口都遍历求最大值，时间复杂度为 O(nk)O(nk)O(nk)，在 k 较大时会超时（n = 10^5 级别）。我们需要一种能“快速淘汰无用元素 + 快速获取最大值”的数据结构。 ✅ 单调递减队列（从队首到队尾：值递减，存储下标） 队首：始终是当前窗口中的最大值对应下标 队尾：用于插入新元素，并在插入前弹出所有比它小的元素（因为这些元素不可能成为后续窗口的最大值——它们更小、且更早被移出窗口） 为什么可以弹出“比当前元素小的”？ 假设 j \u0026lt; i 且 nums[j] ≤ nums[i]，那么对于所有包含 i 的后续窗口，nums[j] 都不可能成为最大值： 它比 nums[i] 小 它比 nums[i] 更早离开窗口 → j 是“无用”的，可安全丢弃。 算法流程 初始化一个双端队列 q（Deque），用于存储下标，维护窗口内元素对应的下标单调递减（对应值单调递减）。 先处理前 k 个元素（第一个窗口）： 入队前，从队尾弹出所有 nums[q.peekLast()] \u0026lt; nums[i] 的下标； 将当前下标 i 入队尾。 此时队首即为第一个窗口最大值下标。 从 i = k 开始滑动窗口： 维护队列单调性：从队尾弹出所有小于 nums[i] 的元素； 移除过期元素：若队首下标 ≤ i - k（已不在窗口内），则从队首弹出； 将 i 入队尾； 当前窗口最大值为 nums[q.peekFirst()]，存入结果数组。 ⚠️ 注意：队列中存的是下标而非值，便于判断元素是否过期。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:2:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#核心思路单调队列monotonic-deque"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：单调队列（Monotonic Deque） 本题的难点在于：如何在 O(1)O(1)O(1) 时间内动态维护滑动窗口的最大值？ 若对每个窗口都遍历求最大值，时间复杂度为 O(nk)O(nk)O(nk)，在 k 较大时会超时（n = 10^5 级别）。我们需要一种能“快速淘汰无用元素 + 快速获取最大值”的数据结构。 ✅ 单调递减队列（从队首到队尾：值递减，存储下标） 队首：始终是当前窗口中的最大值对应下标 队尾：用于插入新元素，并在插入前弹出所有比它小的元素（因为这些元素不可能成为后续窗口的最大值——它们更小、且更早被移出窗口） 为什么可以弹出“比当前元素小的”？ 假设 j \u0026lt; i 且 nums[j] ≤ nums[i]，那么对于所有包含 i 的后续窗口，nums[j] 都不可能成为最大值： 它比 nums[i] 小 它比 nums[i] 更早离开窗口 → j 是“无用”的，可安全丢弃。 算法流程 初始化一个双端队列 q（Deque），用于存储下标，维护窗口内元素对应的下标单调递减（对应值单调递减）。 先处理前 k 个元素（第一个窗口）： 入队前，从队尾弹出所有 nums[q.peekLast()] \u0026lt; nums[i] 的下标； 将当前下标 i 入队尾。 此时队首即为第一个窗口最大值下标。 从 i = k 开始滑动窗口： 维护队列单调性：从队尾弹出所有小于 nums[i] 的元素； 移除过期元素：若队首下标 ≤ i - k（已不在窗口内），则从队首弹出； 将 i 入队尾； 当前窗口最大值为 nums[q.peekFirst()]，存入结果数组。 ⚠️ 注意：队列中存的是下标而非值，便于判断元素是否过期。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:2:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#-单调递减队列从队首到队尾值递减存储下标"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：单调队列（Monotonic Deque） 本题的难点在于：如何在 O(1)O(1)O(1) 时间内动态维护滑动窗口的最大值？ 若对每个窗口都遍历求最大值，时间复杂度为 O(nk)O(nk)O(nk)，在 k 较大时会超时（n = 10^5 级别）。我们需要一种能“快速淘汰无用元素 + 快速获取最大值”的数据结构。 ✅ 单调递减队列（从队首到队尾：值递减，存储下标） 队首：始终是当前窗口中的最大值对应下标 队尾：用于插入新元素，并在插入前弹出所有比它小的元素（因为这些元素不可能成为后续窗口的最大值——它们更小、且更早被移出窗口） 为什么可以弹出“比当前元素小的”？ 假设 j \u0026lt; i 且 nums[j] ≤ nums[i]，那么对于所有包含 i 的后续窗口，nums[j] 都不可能成为最大值： 它比 nums[i] 小 它比 nums[i] 更早离开窗口 → j 是“无用”的，可安全丢弃。 算法流程 初始化一个双端队列 q（Deque），用于存储下标，维护窗口内元素对应的下标单调递减（对应值单调递减）。 先处理前 k 个元素（第一个窗口）： 入队前，从队尾弹出所有 nums[q.peekLast()] \u0026lt; nums[i] 的下标； 将当前下标 i 入队尾。 此时队首即为第一个窗口最大值下标。 从 i = k 开始滑动窗口： 维护队列单调性：从队尾弹出所有小于 nums[i] 的元素； 移除过期元素：若队首下标 ≤ i - k（已不在窗口内），则从队首弹出； 将 i 入队尾； 当前窗口最大值为 nums[q.peekFirst()]，存入结果数组。 ⚠️ 注意：队列中存的是下标而非值，便于判断元素是否过期。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:2:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#为什么可以弹出比当前元素小的"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：单调队列（Monotonic Deque） 本题的难点在于：如何在 O(1)O(1)O(1) 时间内动态维护滑动窗口的最大值？ 若对每个窗口都遍历求最大值，时间复杂度为 O(nk)O(nk)O(nk)，在 k 较大时会超时（n = 10^5 级别）。我们需要一种能“快速淘汰无用元素 + 快速获取最大值”的数据结构。 ✅ 单调递减队列（从队首到队尾：值递减，存储下标） 队首：始终是当前窗口中的最大值对应下标 队尾：用于插入新元素，并在插入前弹出所有比它小的元素（因为这些元素不可能成为后续窗口的最大值——它们更小、且更早被移出窗口） 为什么可以弹出“比当前元素小的”？ 假设 j \u0026lt; i 且 nums[j] ≤ nums[i]，那么对于所有包含 i 的后续窗口，nums[j] 都不可能成为最大值： 它比 nums[i] 小 它比 nums[i] 更早离开窗口 → j 是“无用”的，可安全丢弃。 算法流程 初始化一个双端队列 q（Deque），用于存储下标，维护窗口内元素对应的下标单调递减（对应值单调递减）。 先处理前 k 个元素（第一个窗口）： 入队前，从队尾弹出所有 nums[q.peekLast()] \u0026lt; nums[i] 的下标； 将当前下标 i 入队尾。 此时队首即为第一个窗口最大值下标。 从 i = k 开始滑动窗口： 维护队列单调性：从队尾弹出所有小于 nums[i] 的元素； 移除过期元素：若队首下标 ≤ i - k（已不在窗口内），则从队首弹出； 将 i 入队尾； 当前窗口最大值为 nums[q.peekFirst()]，存入结果数组。 ⚠️ 注意：队列中存的是下标而非值，便于判断元素是否过期。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:2:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#算法流程"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func maxSlidingWindow(nums []int, k int) []int { // 边界条件处理 if len(nums) == 0 || k == 0 { return nil } n := len(nums) // 预分配结果数组，容量为 n-k+1 res := make([]int, 0, n-k+1) // q 是单调队列，仅存储数组的【下标】 // 保证队列头部 q[0] 对应的数值 nums[q[0]] 永远是当前窗口的最大值 q := []int{} for i, v := range nums { // 1. 维护单调性（递减）： // 如果队尾元素对应的值小于当前值 v，说明队尾元素不可能是最大值了，弹出 for len(q) \u0026gt; 0 \u0026amp;\u0026amp; nums[q[len(q)-1]] \u0026lt; v { q = q[:len(q)-1] // 弹出队尾 } // 2. 入队：将当前元素下标加入队尾 q = append(q, i) // 3. 移除过期元素： // 检查队首下标是否已经滑出窗口范围 (应当 \u0026gt; i-k) if q[0] \u0026lt;= i-k { q = q[1:] // 弹出队首 } // 4. 记录结果： // 当窗口完全形成（下标 i \u0026gt;= k-1）时，队首即为当前窗口最大值 if i \u0026gt;= k-1 { res = append(res, nums[q[0]]) } } return res }复杂度分析 时间复杂度： O(n)O(n)O(n). 每个元素最多入队一次、出队一次，总操作数为 2n，均摊 O(1)O(1)O(1)。 空间复杂度： O(k)O(k)O(k). 队列中最多存放 k 个元素（窗口大小）。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:2:3","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"76. 最小覆盖子串 - Hard ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:3:0","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#76-最小覆盖子串---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定两个字符串 s 和 t，长度分别是 m 和 n，返回 s 中的 最短窗口 子串，使得该子串包含 t 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 \u0026quot;\u0026quot;。 测试用例保证答案唯一。 示例： 输入： s = \u0026quot;ADOBECODEBANC\u0026quot;, t = \u0026quot;ABC\u0026quot; 输出： \u0026quot;BANC\u0026quot; 解释： 最小覆盖子串 \u0026quot;BANC\u0026quot; 包含 t 中所有字符 'A', 'B', 'C'。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:3:1","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：滑动窗口 + 哈希计数 本题是「滑动窗口」的经典应用，核心目标是：在 s 中找到一个最短连续子串，使其字符频次 ≥ t 的字符频次（即完全覆盖 t）。 关键观察点 窗口有效性判定：不能只看字符是否出现，而要看频次是否足够。例如 t = \u0026quot;AAB\u0026quot;，窗口中至少要有 2 个 'A' 和 1 个 'B'。 扩展与收缩策略： 右指针 r 扩展窗口：直到窗口首次满足覆盖条件； 左指针 l 收缩窗口：在满足条件的前提下，尽可能缩小窗口，尝试找到更优解； 重复上述过程，维护全局最小窗口。 实现细节 改用「需匹配字符种类数」+「当前达标种类数」实现 O(1)O(1)O(1) 判断 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:3:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#核心思路滑动窗口--哈希计数"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：滑动窗口 + 哈希计数 本题是「滑动窗口」的经典应用，核心目标是：在 s 中找到一个最短连续子串，使其字符频次 ≥ t 的字符频次（即完全覆盖 t）。 关键观察点 窗口有效性判定：不能只看字符是否出现，而要看频次是否足够。例如 t = \u0026quot;AAB\u0026quot;，窗口中至少要有 2 个 'A' 和 1 个 'B'。 扩展与收缩策略： 右指针 r 扩展窗口：直到窗口首次满足覆盖条件； 左指针 l 收缩窗口：在满足条件的前提下，尽可能缩小窗口，尝试找到更优解； 重复上述过程，维护全局最小窗口。 实现细节 改用「需匹配字符种类数」+「当前达标种类数」实现 O(1)O(1)O(1) 判断 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:3:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#关键观察点"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：滑动窗口 + 哈希计数 本题是「滑动窗口」的经典应用，核心目标是：在 s 中找到一个最短连续子串，使其字符频次 ≥ t 的字符频次（即完全覆盖 t）。 关键观察点 窗口有效性判定：不能只看字符是否出现，而要看频次是否足够。例如 t = \u0026quot;AAB\u0026quot;，窗口中至少要有 2 个 'A' 和 1 个 'B'。 扩展与收缩策略： 右指针 r 扩展窗口：直到窗口首次满足覆盖条件； 左指针 l 收缩窗口：在满足条件的前提下，尽可能缩小窗口，尝试找到更优解； 重复上述过程，维护全局最小窗口。 实现细节 改用「需匹配字符种类数」+「当前达标种类数」实现 O(1)O(1)O(1) 判断 ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:3:2","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#实现细节"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func minWindow(s string, t string) string { // 边界检查 if len(s) \u0026lt; len(t) { return \u0026#34;\u0026#34; } // 1. 频次统计 //由于是 ASCII 字符，使用数组代替 map 性能更高 (index 0-127) need := [128]int{} for i := 0; i \u0026lt; len(t); i++ { need[t[i]]++ } // needCnt: 还需要匹配多少个字符才能完全覆盖 t needCnt := len(t) // 记录最小覆盖子串的起始位置和长度 start, minLen := 0, len(s)+1 // 滑动窗口：[l, r) 左闭右开区间 l, r := 0, 0 for r \u0026lt; len(s) { // === 1. 进窗口逻辑 === ch := s[r] // 如果当前字符 ch 是 t 中需要的 (即 need[ch] \u0026gt; 0)， // 那么我们将 needCnt 减 1，表示\u0026#34;还缺少的字符数\u0026#34;少了一个 if need[ch] \u0026gt; 0 { needCnt-- } // 无论是否需要，都将该字符在 need 数组中的计数减 1 // need[ch] \u0026gt; 0 表示还缺这个字符 // need[ch] \u0026lt;= 0 表示窗口内该字符已经足够，甚至多余了 (负数表示多余个数) need[ch]-- r++ // === 2. 窗口满足条件，尝试收缩左边界 === // needCnt == 0 意味着 t 中所有字符都已被覆盖 for needCnt == 0 { // 更新最小结果 if r-l \u0026lt; minLen { minLen = r - l start = l } // === 3. 出窗口逻辑 === removeChar := s[l] // 恢复 need 数组计数 need[removeChar]++ // 核心逻辑：判断是否破坏了覆盖条件 // 如果 need[removeChar] 变回 \u0026gt; 0，说明刚才移除的那个字符是\u0026#34;必须\u0026#34;的， // 且移除后窗口内数量不足了，所以 needCnt + 1 if need[removeChar] \u0026gt; 0 { needCnt++ } l++ } } if minLen == len(s)+1 { return \u0026#34;\u0026#34; } return s[start : start+minLen] }复杂度分析 时间复杂度: O(m+n)O(m+n)O(m+n) 其中 m = s.length(), n = t.length() 空间复杂度: O(1)O(1)O(1) ","date":"2026-01-25","objectID":"/posts/2026-01-25-substring/:3:3","tags":["Go","子串","题解"],"title":"[Golang] LeetCode 热题 100 - 子串","uri":"/posts/2026-01-25-substring/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"滑动窗口 ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:0:0","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#滑动窗口"},{"categories":["算法","LeetCode"],"collections":null,"content":"3. 无重复字符的最长子串 - Mid ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:1:0","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#3-无重复字符的最长子串---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \u0026quot;abcabcbb\u0026quot; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026quot;abc\u0026quot;，所以其长度为 3。 示例 2: 输入: s = \u0026quot;pwwkew\u0026quot; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026quot;wke\u0026quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\u0026quot;pwke\u0026quot; 是一个子序列，不是子串。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:1:1","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：滑动窗口 这道题要求我们找到一个连续的子串，这个子串需要满足\u0026quot;无重复字符\u0026quot;的条件，并且长度要最长。这种在连续区间上求解的问题，非常适合使用滑动窗口算法。 我们可以想象有一个窗口在字符串 s 上滑动，窗口的左右边界由两个指针 left 和 right 决定。这个窗口 s[left...right] 就代表了我们正在考察的当前子串。 数据结构选择：我们需要一个数据结构来快速判断窗口内是否存在重复字符。哈希集合 (HashSet) 是不二之选，它可以在 O(1)O(1)O(1) 的时间内添加、删除和查找元素。 窗口的移动逻辑： 扩大窗口：我们不断地移动右指针 right，将新的字符纳入窗口中。 缩小窗口：当新加入的字符 s[right] 已经在哈希集合中存在时，说明窗口内出现了重复。此时，我们必须从左侧开始缩小窗口，即不断地移动左指针 left 并从哈希集合中移除 s[left]，直到窗口内不再包含重复的 s[right] 为止。 算法步骤： 初始化左指针 left = 0，右指针 right = 0，最大长度 maxLength = 0，以及一个空的哈希集合 set。 右指针 right 开始遍历整个字符串： a. 获取当前右指针的字符 c = s.charAt(right)。 b. 检查重复：在 set 中检查是否存在字符 c。如果存在，就进入一个循环，不断从 set 中移除左指针 left 指向的字符，并递增 left，直到 set 中不再有 c。 c. 添加新字符：将当前字符 c 添加到 set 中。 d. 更新最大长度：此时，从 left 到 right 的窗口内一定是无重复字符的。我们更新最大长度：maxLength = Math.max(maxLength, right - left + 1)。 e. 将右指针 right 右移一位，考察下一个字符。 遍历结束后，maxLength 就是最终答案。 通过这种一扩一缩的动态调整，滑动窗口能够保证在一次遍历中就找到最优解。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:1:2","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#核心思路滑动窗口"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func lengthOfLongestSubstring(s string) int { n := len(s) left, right := 0, 0 ans := 0 countMap := make(map[byte]struct{}) for right \u0026lt; n { // 如果 set 中已存在当前字符，说明窗口需要从左侧收缩 for { _, ok := countMap[s[right]] if ok { delete(countMap, s[left]) left++ continue } break } // 不存在 就添加 更新长度大小 countMap[s[right]] = struct{}{} length := right - left + 1 if length \u0026gt; ans { ans = length } right++ } return ans }复杂度分析 时间复杂度: O(n)O(n)O(n)。虽然代码中有一个 for 循环嵌套一个 while 循环，但每个字符最多被左指针 left 和右指针 right 访问一次。因此，总的操作次数是线性的，而不是二次方。 空间复杂度: O(k)O(k)O(k)。其中 k 是字符串中不同字符的数量（即字符集的大小）。哈希集合在最坏情况下需要存储 k 个字符。对于 ASCII 字符集，k 最多为 128，可以看作是 O(1)O(1)O(1)。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:1:3","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"优化后的代码 如果当前的字符出现过，我们可以直接将左指针跳到上次出现该字符的下一个位置，而不是一个一个地移动左指针，这样就需要用数组记录一下最后出现的位置+1，方便跳转。 func lengthOfLongestSubstring(s string) int { n := len(s) if n \u0026lt;= 1 { return n } // 使用数组记录字符最后出现的位置 + 1（默认为 0 表示没出现过） // 128 足以覆盖标准 ASCII 字符 lastOccur := [128]int{} ans := 0 left := 0 for right := 0; right \u0026lt; n; right++ { char := s[right] // 如果该字符出现过，且其上次出现的位置在当前窗口 [left, right] 内 if lastOccur[char] \u0026gt; left { // 直接跳过重复部分，更新左边界 left = lastOccur[char] } // 计算当前窗口长度 if right-left+1 \u0026gt; ans { ans = right - left + 1 } // 记录当前字符的下一个位置，方便 left 直接跳转 lastOccur[char] = right + 1 } return ans }","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:1:4","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#优化后的代码"},{"categories":["算法","LeetCode"],"collections":null,"content":"438. 找到字符串中所有字母异位词 - Mid ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:2:0","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#438-找到字符串中所有字母异位词---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定两个字符串 s 和 p，找到 s 中所有 p 的 字母异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 字母异位词 指由相同字母按不同顺序排列组成的字符串。 示例 1: 输入: s = \u0026quot;cbaebabacd\u0026quot;, p = \u0026quot;abc\u0026quot; 输出: [0,6] 解释: 起始索引等于 0 的子串是 \u0026quot;cba\u0026quot;, 它是 \u0026quot;abc\u0026quot; 的异位词。 起始索引等于 6 的子串是 \u0026quot;bac\u0026quot;, 它是 \u0026quot;abc\u0026quot; 的异位词。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:2:1","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：定长滑动窗口 + 字符频率统计 这道题要求我们在一个长字符串 s 中，找出所有与短字符串 p 构成字母异位词的子串。 \u0026ldquo;字母异位词\u0026quot;的判断标准是：两个字符串长度相等，且包含的字符种类和数量完全相同。这提示我们，核心在于字符频率的比较。 \u0026ldquo;找出所有\u0026hellip;的子串\u0026quot;则强烈地暗示了滑动窗口算法。由于 p 的长度是固定的，我们可以使用一个大小固定的滑动窗口来遍历 s。 结合以上两点，我们的解题策略就清晰了： 统计 p 的频率：首先，我们需要一个\u0026quot;标准答案\u0026rdquo;，也就是字符串 p 的字符频率分布。因为题目只包含小写字母，我们可以用一个长度为 26 的数组 countP 来存储。 创建固定大小的窗口：我们在 s 上维护一个长度与 p 相同的滑动窗口。我们同样用一个长度为 26 的数组 countS 来实时统计这个窗口内的字符频率。 滑动与比较： 初始化：先统计 s 中第一个窗口（即 s[0...p.length()-1]）的字符频率到 countS 中，并与 countP 比较。如果两者完全相同，那么索引 0 就是一个答案。 滑动：将窗口向右滑动一格。这个过程非常高效，我们不需要重新统计整个窗口，只需要： 减去移出窗口的左侧字符的频率。 加上进入窗口的右侧新字符的频率。 比较：每次滑动后，都将更新后的 countS 与 countP 进行比较。如果相同，就记录下当前窗口的起始索引。 收集结果：重复滑动和比较的过程，直到窗口滑动到 s 的末尾，我们就找到了所有答案。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:3:0","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#核心思路定长滑动窗口--字符频率统计"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func findAnagrams(s string, p string) []int { sLen, pLen := len(s), len(p) if sLen \u0026lt; pLen { return []int{} } var res []int // 使用数组代替 map，性能更高 var pCount, sCount [26]int // 1. 初始化统计 p 的字符和 s 的第一个窗口 for i := 0; i \u0026lt; pLen; i++ { pCount[p[i]-\u0026#39;a\u0026#39;]++ sCount[s[i]-\u0026#39;a\u0026#39;]++ } // 2. 比较第一个窗口 if sCount == pCount { res = append(res, 0) } // 3. 开始滑动窗口 // i 是新进入窗口的字符索引，i - pLen 是要滑出窗口的字符索引 for i := pLen; i \u0026lt; sLen; i++ { sCount[s[i]-\u0026#39;a\u0026#39;]++ // 右边界移入 sCount[s[i-pLen]-\u0026#39;a\u0026#39;]-- // 左边界移出 // Go 数组支持直接 == 比较，复杂度为 $O(26)$ if sCount == pCount { res = append(res, i-pLen+1) } } return res }复杂度分析 时间复杂度: O(N)O(N)O(N)。 空间复杂度: O(1)O(1)O(1)。 ","date":"2026-01-25","objectID":"/posts/2026-01-25-sliding-window/:3:1","tags":["Go","滑动窗口","题解"],"title":"[Golang] LeetCode 热题 100 - 滑动窗口","uri":"/posts/2026-01-25-sliding-window/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"双指针 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:0:0","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#双指针"},{"categories":["算法","LeetCode"],"collections":null,"content":"283. 移动零 - Easy ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:1:0","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#283-移动零---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:1:1","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：快慢指针（一次遍历） 这道题有两个核心要求： 将所有 0 移动到末尾。 保持所有非零元素的相对顺序不变。 第二个要求\u0026quot;保持相对顺序\u0026quot;是解题的关键。它告诉我们，不能简单地像\u0026quot;移除元素\u0026quot;那样，用头尾指针交换元素，因为那样会打乱非零元素的原有顺序。 这个问题的本质可以看作是：将所有非零元素，按原有的顺序，紧凑地移动到数组的前面，然后将剩余的位置全部填上零。 这正是快慢指针擅长的场景： 定义指针： 慢指针 p (或 slow): 这个指针用于标记\u0026quot;下一个非零元素应该被放置的位置\u0026quot;。在 p 左边的所有元素（不含 p）都是已经处理好的、按序排列的非零元素。 快指针 q (或 fast): 这个指针负责遍历整个数组，去寻找非零元素。 执行过程： 初始化 p 和 q 都指向数组的起始位置 0。 快指针 q 开始向后遍历数组。 当 q 遇到一个非零元素时，说明这个元素需要被保留并放到前面。于是，我们执行两个操作： 将这个非零元素 nums[q] 赋值给慢指针 p 所在的位置 nums[p]。 将慢指针 p 向后移动一位 (p++)，为下一个非零元素腾出位置。 如果 q 遇到的是 0，则慢指针 p 保持不动，只有快指针 q 继续向后移动。 填充末尾的零： 当快指针 q 遍历完整个数组后，所有非零元素都已经被紧凑地移动到了数组的前 p 个位置。 数组中从索引 p 到末尾的所有位置，都应该是 0。 因此，我们再进行一次循环，从 p 开始，将数组剩余的位置全部赋值为 0。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:1:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#核心思路快慢指针一次遍历"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func moveZeroes(nums []int) { p := 0 for q := 0; q \u0026lt; len(nums); q++ { if nums[q] != 0 { nums[p] = nums[q] p++ } } for ; p \u0026lt; len(nums); p++ { nums[p] = 0 } }复杂度分析 时间复杂度: O(n)O(n)O(n)。其中 n 是数组的长度。快指针 q 遍历数组一次，慢指针 p 在第二步中也最多遍历一次。总的操作次数与 n 呈线性关系。 空间复杂度: O(1)O(1)O(1)。所有操作都在原数组上进行，没有使用额外的存储空间。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:1:3","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"11. 盛最多水的容器 - Mid ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:2:0","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#11-盛最多水的容器---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明： 你不能倾斜容器。 示例 1： 输入： height = [1,8,6,2,5,4,8,3,7] 输出： 49 解释： 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:2:1","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：双指针与贪心策略 这道题是经典的双指针（Two Pointers）应用题，同时也蕴含了贪心（Greedy）的思想。 如果我们使用暴力解法，两两组合计算面积，时间复杂度会达到 O(n2)O(n^2)O(n2)，这在 n 很大时会超时。我们需要寻找一种 O(n)O(n)O(n) 的线性扫描方法。 面积公式分析 容器的蓄水量（面积）取决于两板之间较短的那块板的高度 × 两板之间的距离。这就像\u0026quot;木桶效应\u0026quot;，装多少水取决于最短的那块木板。 双指针的决策逻辑 我们从数组的两端开始向内收缩，初始化左指针 l = 0，右指针 r = n - 1。此时宽度最大。 在每一步迭代中，我们需要决定移动哪一边的指针。这里有一个关键的贪心策略： 总是移动高度较小的那一端指针。 为什么？ 假设当前 height[l] \u0026lt; height[r]： 如果移动右指针（高板）：宽度 (r - l) 变小了。而高度受限于左边的短板 height[l]，无论右边新的板多高，容器的实际高度不可能超过 height[l]。因此，面积一定变小。 如果移动左指针（短板）：宽度 (r - l) 变小了。但是，新的左边板 height[l+1] 有可能比原来的 height[l] 高。虽然宽度减小了，但高度有可能大幅增加，从而使得整体面积有可能变大。 简而言之，保留短板没有前途（因为宽度在不断减小，短板限制了高度上限），只有丢弃短板，才有可能找到更高的板来弥补宽度的损失。 算法流程 初始化 ans = 0，l = 0，r = n - 1。 当 l \u0026lt; r 时循环： a. 计算当前面积：tmp = min(height[l], height[r]) * (r - l)。 b. 更新最大面积：ans = max(ans, tmp)。 c. 移动指针：如果 height[l] \u0026lt;= height[r]，则 l++；否则 r--。 返回 ans。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:2:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#核心思路双指针与贪心策略"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：双指针与贪心策略 这道题是经典的双指针（Two Pointers）应用题，同时也蕴含了贪心（Greedy）的思想。 如果我们使用暴力解法，两两组合计算面积，时间复杂度会达到 O(n2)O(n^2)O(n2)，这在 n 很大时会超时。我们需要寻找一种 O(n)O(n)O(n) 的线性扫描方法。 面积公式分析 容器的蓄水量（面积）取决于两板之间较短的那块板的高度 × 两板之间的距离。这就像\u0026quot;木桶效应\u0026quot;，装多少水取决于最短的那块木板。 双指针的决策逻辑 我们从数组的两端开始向内收缩，初始化左指针 l = 0，右指针 r = n - 1。此时宽度最大。 在每一步迭代中，我们需要决定移动哪一边的指针。这里有一个关键的贪心策略： 总是移动高度较小的那一端指针。 为什么？ 假设当前 height[l] \u0026lt; height[r]： 如果移动右指针（高板）：宽度 (r - l) 变小了。而高度受限于左边的短板 height[l]，无论右边新的板多高，容器的实际高度不可能超过 height[l]。因此，面积一定变小。 如果移动左指针（短板）：宽度 (r - l) 变小了。但是，新的左边板 height[l+1] 有可能比原来的 height[l] 高。虽然宽度减小了，但高度有可能大幅增加，从而使得整体面积有可能变大。 简而言之，保留短板没有前途（因为宽度在不断减小，短板限制了高度上限），只有丢弃短板，才有可能找到更高的板来弥补宽度的损失。 算法流程 初始化 ans = 0，l = 0，r = n - 1。 当 l \u0026lt; r 时循环： a. 计算当前面积：tmp = min(height[l], height[r]) * (r - l)。 b. 更新最大面积：ans = max(ans, tmp)。 c. 移动指针：如果 height[l] \u0026lt;= height[r]，则 l++；否则 r--。 返回 ans。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:2:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#面积公式分析"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：双指针与贪心策略 这道题是经典的双指针（Two Pointers）应用题，同时也蕴含了贪心（Greedy）的思想。 如果我们使用暴力解法，两两组合计算面积，时间复杂度会达到 O(n2)O(n^2)O(n2)，这在 n 很大时会超时。我们需要寻找一种 O(n)O(n)O(n) 的线性扫描方法。 面积公式分析 容器的蓄水量（面积）取决于两板之间较短的那块板的高度 × 两板之间的距离。这就像\u0026quot;木桶效应\u0026quot;，装多少水取决于最短的那块木板。 双指针的决策逻辑 我们从数组的两端开始向内收缩，初始化左指针 l = 0，右指针 r = n - 1。此时宽度最大。 在每一步迭代中，我们需要决定移动哪一边的指针。这里有一个关键的贪心策略： 总是移动高度较小的那一端指针。 为什么？ 假设当前 height[l] \u0026lt; height[r]： 如果移动右指针（高板）：宽度 (r - l) 变小了。而高度受限于左边的短板 height[l]，无论右边新的板多高，容器的实际高度不可能超过 height[l]。因此，面积一定变小。 如果移动左指针（短板）：宽度 (r - l) 变小了。但是，新的左边板 height[l+1] 有可能比原来的 height[l] 高。虽然宽度减小了，但高度有可能大幅增加，从而使得整体面积有可能变大。 简而言之，保留短板没有前途（因为宽度在不断减小，短板限制了高度上限），只有丢弃短板，才有可能找到更高的板来弥补宽度的损失。 算法流程 初始化 ans = 0，l = 0，r = n - 1。 当 l \u0026lt; r 时循环： a. 计算当前面积：tmp = min(height[l], height[r]) * (r - l)。 b. 更新最大面积：ans = max(ans, tmp)。 c. 移动指针：如果 height[l] \u0026lt;= height[r]，则 l++；否则 r--。 返回 ans。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:2:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#双指针的决策逻辑"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：双指针与贪心策略 这道题是经典的双指针（Two Pointers）应用题，同时也蕴含了贪心（Greedy）的思想。 如果我们使用暴力解法，两两组合计算面积，时间复杂度会达到 O(n2)O(n^2)O(n2)，这在 n 很大时会超时。我们需要寻找一种 O(n)O(n)O(n) 的线性扫描方法。 面积公式分析 容器的蓄水量（面积）取决于两板之间较短的那块板的高度 × 两板之间的距离。这就像\u0026quot;木桶效应\u0026quot;，装多少水取决于最短的那块木板。 双指针的决策逻辑 我们从数组的两端开始向内收缩，初始化左指针 l = 0，右指针 r = n - 1。此时宽度最大。 在每一步迭代中，我们需要决定移动哪一边的指针。这里有一个关键的贪心策略： 总是移动高度较小的那一端指针。 为什么？ 假设当前 height[l] \u0026lt; height[r]： 如果移动右指针（高板）：宽度 (r - l) 变小了。而高度受限于左边的短板 height[l]，无论右边新的板多高，容器的实际高度不可能超过 height[l]。因此，面积一定变小。 如果移动左指针（短板）：宽度 (r - l) 变小了。但是，新的左边板 height[l+1] 有可能比原来的 height[l] 高。虽然宽度减小了，但高度有可能大幅增加，从而使得整体面积有可能变大。 简而言之，保留短板没有前途（因为宽度在不断减小，短板限制了高度上限），只有丢弃短板，才有可能找到更高的板来弥补宽度的损失。 算法流程 初始化 ans = 0，l = 0，r = n - 1。 当 l \u0026lt; r 时循环： a. 计算当前面积：tmp = min(height[l], height[r]) * (r - l)。 b. 更新最大面积：ans = max(ans, tmp)。 c. 移动指针：如果 height[l] \u0026lt;= height[r]，则 l++；否则 r--。 返回 ans。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:2:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#算法流程"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func maxArea(height []int) int { l, r := 0, len(height)-1 maxAns := 0 for l \u0026lt; r { width := r - l // 确定当前这一步的短板高度 h := 0 if height[l] \u0026lt; height[r] { h = height[l] } else { h = height[r] } // 计算面积并更新最大值 area := h * width if area \u0026gt; maxAns { maxAns = area } // --- 核心优化：快速跳过无意义的柱子 --- // 如果左侧是短板，移动左指针，且跳过所有比当前短板还矮的柱子 if height[l] \u0026lt; height[r] { lastH := height[l] l++ for l \u0026lt; r \u0026amp;\u0026amp; height[l] \u0026lt;= lastH { l++ } } else { // 如果右侧是短板，同理 lastH := height[r] r-- for l \u0026lt; r \u0026amp;\u0026amp; height[r] \u0026lt;= lastH { r-- } } } return maxAns }复杂度分析 时间复杂度: O(n)O(n)O(n)。我们只需遍历数组一次，双指针 l 和 r 总共移动了 n 次。 空间复杂度: O(1)O(1)O(1)。只需要常数级别的变量来存储状态，不需要额外的存储空间。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:2:3","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"15. 三数之和 - Mid ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:3:0","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#15-三数之和---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。 请你返回所有和为 0 且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例 1： 输入： nums = [-1,0,1,2,-1,-4] 输出： [[-1,-1,2],[-1,0,1]] 解释： 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:3:1","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#题目回顾-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：排序 + 双指针 这道题是“两数之和”的进阶版。如果直接使用三重循环暴力求解，时间复杂度为 O(n3)O(n^3)O(n3)，这显然会超时。我们需要寻找 O(n2)O(n^2)O(n2) 级别的解法。 1. 为什么先排序？ 排序是解决这道题的关键步骤（通常花费 O(nlog⁡n)O(n \\log n)O(nlogn)）。 便于双指针操作：排序后，我们可以利用单调性，通过移动左右指针来调整两数之和的大小。 便于去重：题目要求不包含重复的三元组。排序后，相同的元素会相邻，我们在遍历时很容易判断并跳过重复元素。 2. 算法流程 我们将三数之和问题转化为：固定一个数 nums[i]，在剩下的数组中寻找两个数，使它们的和等于 -nums[i]。 具体步骤如下： 特判：如果数组为空或长度小于3，直接返回空列表。 排序：对数组进行升序排序。 遍历：枚举第一个数 nums[i]（索引 i 从 0 到 n-2）： 剪枝优化：因为数组已排序，如果 nums[i] \u0026gt; 0，那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。 外层去重：如果 i \u0026gt; 0 且 nums[i] == nums[i-1]，说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。 双指针查找：令左指针 L = i + 1，右指针 R = n - 1。当 L \u0026lt; R 时： 计算 sum = nums[i] + nums[L] + nums[R]。 若 sum == 0：找到一组解，加入结果集。 内层去重：为了防止结果重复，需要将 L 向右移过所有重复值，将 R 向左移过所有重复值。 移动指针：L++, R--。 若 sum \u0026lt; 0：说明和太小，需要变大，因此 L++。 若 sum \u0026gt; 0：说明和太大，需要变小，因此 R--。 3. 去重的细节 这道题最容易出错的地方就是去重。 外层去重 (nums[i] == nums[i-1])：保证三元组的第一个位置不使用相同的值。 内层去重 (nums[left] == nums[left+1])：在找到一个解后，保证三元组的第二个（以及自然确定的第三个）位置不使用相同的值。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:3:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#核心思路排序--双指针"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：排序 + 双指针 这道题是“两数之和”的进阶版。如果直接使用三重循环暴力求解，时间复杂度为 O(n3)O(n^3)O(n3)，这显然会超时。我们需要寻找 O(n2)O(n^2)O(n2) 级别的解法。 1. 为什么先排序？ 排序是解决这道题的关键步骤（通常花费 O(nlog⁡n)O(n \\log n)O(nlogn)）。 便于双指针操作：排序后，我们可以利用单调性，通过移动左右指针来调整两数之和的大小。 便于去重：题目要求不包含重复的三元组。排序后，相同的元素会相邻，我们在遍历时很容易判断并跳过重复元素。 2. 算法流程 我们将三数之和问题转化为：固定一个数 nums[i]，在剩下的数组中寻找两个数，使它们的和等于 -nums[i]。 具体步骤如下： 特判：如果数组为空或长度小于3，直接返回空列表。 排序：对数组进行升序排序。 遍历：枚举第一个数 nums[i]（索引 i 从 0 到 n-2）： 剪枝优化：因为数组已排序，如果 nums[i] \u0026gt; 0，那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。 外层去重：如果 i \u0026gt; 0 且 nums[i] == nums[i-1]，说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。 双指针查找：令左指针 L = i + 1，右指针 R = n - 1。当 L \u0026lt; R 时： 计算 sum = nums[i] + nums[L] + nums[R]。 若 sum == 0：找到一组解，加入结果集。 内层去重：为了防止结果重复，需要将 L 向右移过所有重复值，将 R 向左移过所有重复值。 移动指针：L++, R--。 若 sum \u0026lt; 0：说明和太小，需要变大，因此 L++。 若 sum \u0026gt; 0：说明和太大，需要变小，因此 R--。 3. 去重的细节 这道题最容易出错的地方就是去重。 外层去重 (nums[i] == nums[i-1])：保证三元组的第一个位置不使用相同的值。 内层去重 (nums[left] == nums[left+1])：在找到一个解后，保证三元组的第二个（以及自然确定的第三个）位置不使用相同的值。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:3:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#1-为什么先排序"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：排序 + 双指针 这道题是“两数之和”的进阶版。如果直接使用三重循环暴力求解，时间复杂度为 O(n3)O(n^3)O(n3)，这显然会超时。我们需要寻找 O(n2)O(n^2)O(n2) 级别的解法。 1. 为什么先排序？ 排序是解决这道题的关键步骤（通常花费 O(nlog⁡n)O(n \\log n)O(nlogn)）。 便于双指针操作：排序后，我们可以利用单调性，通过移动左右指针来调整两数之和的大小。 便于去重：题目要求不包含重复的三元组。排序后，相同的元素会相邻，我们在遍历时很容易判断并跳过重复元素。 2. 算法流程 我们将三数之和问题转化为：固定一个数 nums[i]，在剩下的数组中寻找两个数，使它们的和等于 -nums[i]。 具体步骤如下： 特判：如果数组为空或长度小于3，直接返回空列表。 排序：对数组进行升序排序。 遍历：枚举第一个数 nums[i]（索引 i 从 0 到 n-2）： 剪枝优化：因为数组已排序，如果 nums[i] \u0026gt; 0，那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。 外层去重：如果 i \u0026gt; 0 且 nums[i] == nums[i-1]，说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。 双指针查找：令左指针 L = i + 1，右指针 R = n - 1。当 L \u0026lt; R 时： 计算 sum = nums[i] + nums[L] + nums[R]。 若 sum == 0：找到一组解，加入结果集。 内层去重：为了防止结果重复，需要将 L 向右移过所有重复值，将 R 向左移过所有重复值。 移动指针：L++, R--。 若 sum \u0026lt; 0：说明和太小，需要变大，因此 L++。 若 sum \u0026gt; 0：说明和太大，需要变小，因此 R--。 3. 去重的细节 这道题最容易出错的地方就是去重。 外层去重 (nums[i] == nums[i-1])：保证三元组的第一个位置不使用相同的值。 内层去重 (nums[left] == nums[left+1])：在找到一个解后，保证三元组的第二个（以及自然确定的第三个）位置不使用相同的值。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:3:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#2-算法流程"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：排序 + 双指针 这道题是“两数之和”的进阶版。如果直接使用三重循环暴力求解，时间复杂度为 O(n3)O(n^3)O(n3)，这显然会超时。我们需要寻找 O(n2)O(n^2)O(n2) 级别的解法。 1. 为什么先排序？ 排序是解决这道题的关键步骤（通常花费 O(nlog⁡n)O(n \\log n)O(nlogn)）。 便于双指针操作：排序后，我们可以利用单调性，通过移动左右指针来调整两数之和的大小。 便于去重：题目要求不包含重复的三元组。排序后，相同的元素会相邻，我们在遍历时很容易判断并跳过重复元素。 2. 算法流程 我们将三数之和问题转化为：固定一个数 nums[i]，在剩下的数组中寻找两个数，使它们的和等于 -nums[i]。 具体步骤如下： 特判：如果数组为空或长度小于3，直接返回空列表。 排序：对数组进行升序排序。 遍历：枚举第一个数 nums[i]（索引 i 从 0 到 n-2）： 剪枝优化：因为数组已排序，如果 nums[i] \u0026gt; 0，那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。 外层去重：如果 i \u0026gt; 0 且 nums[i] == nums[i-1]，说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。 双指针查找：令左指针 L = i + 1，右指针 R = n - 1。当 L \u0026lt; R 时： 计算 sum = nums[i] + nums[L] + nums[R]。 若 sum == 0：找到一组解，加入结果集。 内层去重：为了防止结果重复，需要将 L 向右移过所有重复值，将 R 向左移过所有重复值。 移动指针：L++, R--。 若 sum \u0026lt; 0：说明和太小，需要变大，因此 L++。 若 sum \u0026gt; 0：说明和太大，需要变小，因此 R--。 3. 去重的细节 这道题最容易出错的地方就是去重。 外层去重 (nums[i] == nums[i-1])：保证三元组的第一个位置不使用相同的值。 内层去重 (nums[left] == nums[left+1])：在找到一个解后，保证三元组的第二个（以及自然确定的第三个）位置不使用相同的值。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:3:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#3-去重的细节"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func threeSum(nums []int) [][]int { n := len(nums) if n \u0026lt; 3 { return [][]int{} } var ans [][]int sort.Ints(nums) for i := 0; i \u0026lt; n-2; i++ { // 因为数组已排序，如果 nums[i] \u0026gt; 0， // 那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。 if nums[i] \u0026gt; 0 { break } // 如果 i \u0026gt; 0 且 nums[i] == nums[i-1] // 说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。 if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } // 转化为求两数之和：寻找 nums[left] + nums[right] == -nums[i] target := -nums[i] left, right := i+1, n-1 for left \u0026lt; right { sum := nums[left] + nums[right] if sum == target { // 找到符合条件的三元组 ans = append(ans, []int{nums[i], nums[left], nums[right]}) // 无论如何先移动指针 left++ right-- // 内层去重：跳过重复的 left 和 right // 注意：必须在 left \u0026lt; right 的前提下比较 for left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left-1] { left++ } for left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right+1] { right-- } } else if sum \u0026gt; target { // 和太大，右指针左移 right-- } else { // 和太小，左指针右移 left++ } } } return ans }复杂度分析 时间复杂度: O(n2)O(n^2)O(n2)。数组排序的时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。双指针遍历的时间复杂度为 O(n2)O(n^2)O(n2)。总体复杂度由 O(n2)O(n^2)O(n2) 主导。 空间复杂度: O(log⁡n)O(\\log n)O(logn) 或 O(n)O(n)O(n)。取决于排序算法的实现细节。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:3:3","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#代码实现-2"},{"categories":["算法","LeetCode"],"collections":null,"content":"42. 接雨水 - Hard ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:4:0","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#42-接雨水---hard"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入： height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出： 6 解释： 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入： height = [4,2,0,3,2,5] 输出： 9 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:4:1","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#题目回顾-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：按列求值的动态规划 这道题是 LeetCode Top 100 中非常经典的 Hard 题目，也是大厂面试的常客。解决这道题的关键在于化繁为简：不要试图一次性算出所有雨水，而是思考每一根柱子上方能存多少水。 对于数组中索引为 i 的位置，它能接到的雨水量取决于什么？ 根据\u0026quot;木桶效应\u0026quot;，它能存的水，取决于它左边最高的柱子和右边最高的柱子中较矮的那一个，减去它自身的高度。 公式如下： water[i]=min⁡(maxleft[i],maxright[i])−height[i] \\text{water}[i] = \\min(\\text{maxleft}[i], \\text{maxright}[i]) - \\text{height}[i] water[i]=min(maxleft[i],maxright[i])−height[i]当然，如果计算结果小于 0，说明当前柱子比两边都高，存不了水，结果取 0。 为什么需要动态规划？ 如果我们对每个位置 i 都向左、向右扫描寻找最大值，时间复杂度会达到 O(N2)O(N^2)O(N2)，这在数据量大时会超时。 为了优化，我们可以使用空间换时间的策略（预处理）： 左侧最大值数组 (left)：从左往右遍历，left[i] 表示 [0...i] 区间内的最大高度。递推公式为 left[i] = max(left[i-1], height[i])。 右侧最大值数组 (right)：从右往左遍历，right[i] 表示 [i...n-1] 区间内的最大高度。递推公式为 right[i] = max(right[i+1], height[i])。 这样，我们在最后计算雨水时，只需要 O(1)O(1)O(1) 的时间就能获取到左右两边的限制高度。 具体的算法流程如下： 初始化两个长度为 n 的数组 left 和 right。 正向遍历生成 left 数组。 反向遍历生成 right 数组。 再次遍历数组，应用上述公式累加每一个位置的雨水量。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:4:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#核心思路按列求值的动态规划"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：按列求值的动态规划 这道题是 LeetCode Top 100 中非常经典的 Hard 题目，也是大厂面试的常客。解决这道题的关键在于化繁为简：不要试图一次性算出所有雨水，而是思考每一根柱子上方能存多少水。 对于数组中索引为 i 的位置，它能接到的雨水量取决于什么？ 根据\u0026quot;木桶效应\u0026quot;，它能存的水，取决于它左边最高的柱子和右边最高的柱子中较矮的那一个，减去它自身的高度。 公式如下： water[i]=min⁡(maxleft[i],maxright[i])−height[i] \\text{water}[i] = \\min(\\text{maxleft}[i], \\text{maxright}[i]) - \\text{height}[i] water[i]=min(maxleft[i],maxright[i])−height[i]当然，如果计算结果小于 0，说明当前柱子比两边都高，存不了水，结果取 0。 为什么需要动态规划？ 如果我们对每个位置 i 都向左、向右扫描寻找最大值，时间复杂度会达到 O(N2)O(N^2)O(N2)，这在数据量大时会超时。 为了优化，我们可以使用空间换时间的策略（预处理）： 左侧最大值数组 (left)：从左往右遍历，left[i] 表示 [0...i] 区间内的最大高度。递推公式为 left[i] = max(left[i-1], height[i])。 右侧最大值数组 (right)：从右往左遍历，right[i] 表示 [i...n-1] 区间内的最大高度。递推公式为 right[i] = max(right[i+1], height[i])。 这样，我们在最后计算雨水时，只需要 O(1)O(1)O(1) 的时间就能获取到左右两边的限制高度。 具体的算法流程如下： 初始化两个长度为 n 的数组 left 和 right。 正向遍历生成 left 数组。 反向遍历生成 right 数组。 再次遍历数组，应用上述公式累加每一个位置的雨水量。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:4:2","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#为什么需要动态规划"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func trap(height []int) int { n := len(height) if n \u0026lt;= 1 { return 0 } // left_i 表示0到i的最大值 left := make([]int, n) left[0] = height[0] // right_i 表示i到n-1的最大值 right := make([]int, n) right[n-1] = height[n-1] for i := 1; i \u0026lt; n; i++ { left[i] = max(left[i-1], height[i]) } for i := n - 2; i \u0026gt;= 0; i-- { right[i] = max(right[i+1], height[i]) } sum := 0 for i, v := range height { sum += min(left[i], right[i]) - v } return sum }复杂度分析 时间复杂度: O(N)O(N)O(N)。我们需要遍历数组三次（计算 left，计算 right，计算结果），每次操作都是线性的，所以总时间复杂度为线性。 空间复杂度: O(N)O(N)O(N)。我们需要两个额外的数组 left 和 right 来存储预处理结果。进阶思考：虽然 O(N)O(N)O(N) 的空间复杂度已经是可以接受的，但这道题其实还有空间复杂度为 O(1)O(1)O(1) 的双指针解法。其核心思想是在动态维护左右最大值的同时收缩左右指针，有兴趣的读者可以尝试自行推导。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-two-pointer/:4:3","tags":["Go","双指针","动态规划","题解"],"title":"[Golang] LeetCode 热题 100 - 双指针","uri":"/posts/2026-01-24-two-pointer/#代码实现-3"},{"categories":["算法","LeetCode"],"collections":null,"content":"哈希 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:0:0","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#哈希"},{"categories":["算法","LeetCode"],"collections":null,"content":"1. 两数之和 - Easy ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:1:0","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#1-两数之和---easy"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入： nums = [2,7,11,15], target = 9 输出： [0,1] 解释： 因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:1:1","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#题目回顾"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：用空间换时间 作为 LeetCode 的开篇之作，这道题完美地诠释了如何通过\u0026quot;空间换时间\u0026quot;的思想来优化算法。 暴力解法的瓶颈在于\u0026quot;寻找另一个数\u0026quot;的过程太慢。对于每个 nums[i]，我们都需要在数组中寻找是否存在一个数 target - nums[i]。这个寻找过程能否被加速呢？ 答案是肯定的，哈希表提供了近乎 O(1)O(1)O(1) 的查找效率。 我们可以使用一个哈希表（HashMap）来存储已经遍历过的数字及其对应的索引，即 Map\u0026lt;数值, 索引\u0026gt;。 具体的算法流程如下： 创建一个空的哈希表 map。 遍历 nums 数组，对于当前的元素 nums[i]： a. 计算我们需要寻找的\u0026quot;另一半\u0026quot;：complement = target - nums[i]。 b. 在哈希表中查找 complement 是否存在。 如果存在，说明我们找到了解！complement 的索引已经存在 map 中，当前元素的索引是 i。我们立即返回 [map.get(complement), i]。 如果不存在，说明到目前为止还没遇到能和 nums[i] 配对的数。我们将当前数字和它的索引存入哈希表 map.put(nums[i], i)，以便后续的元素能用它来配对。 遍历结束。由于题目保证有唯一解，所以在循环中一定会找到答案。 这个\u0026quot;一边遍历，一边查找，一边插入\u0026quot;的单遍哈希表解法，非常巧妙地在一次循环中完成了所有工作。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:1:2","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#核心思路用空间换时间"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func twoSum(nums []int, target int) []int { m := make(map[int]int) for i := 0; i \u0026lt; len(nums); i++ { if val, ok := m[target-nums[i]]; ok { return []int{val, i} } m[nums[i]] = i } return []int{-1, -1} }复杂度分析 时间复杂度: O(n)O(n)O(n)。我们只需遍历数组一次。哈希表的插入和查找操作的平均时间复杂度都是 O(1)O(1)O(1)。 空间复杂度: O(n)O(n)O(n)。在最坏情况下，我们需要将数组中的所有元素都存入哈希表中。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:1:3","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#代码实现"},{"categories":["算法","LeetCode"],"collections":null,"content":"49. 字母异位词分组 - Mid 题目回顾 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由相同字母按不同顺序排列组成的单词。 示例 1: 输入: strs = [\u0026quot;eat\u0026quot;, \u0026quot;tea\u0026quot;, \u0026quot;tan\u0026quot;, \u0026quot;ate\u0026quot;, \u0026quot;nat\u0026quot;, \u0026quot;bat\u0026quot;] 输出: [[\u0026quot;bat\u0026quot;],[\u0026quot;nat\u0026quot;,\u0026quot;tan\u0026quot;],[\u0026quot;ate\u0026quot;,\u0026quot;eat\u0026quot;,\u0026quot;tea\u0026quot;]] ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:2:0","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#49-字母异位词分组---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：寻找唯一标识 除了字母完全相同，字母异位词的另一个充要条件是每个字母出现的频率完全相同。因此，我们也可以根据一个单词的字符频率来生成 key。 例如，对于 \u0026quot;aab\u0026quot;，其字符频率可以表示为一个长度为 26 的数组 [2, 1, 0, 0, ...]。为了把这个数组用作哈希表的 key，我们需要将它转换成一个不可变的字符串。 我们可以简单地将计数拼接起来，例如用 \u0026quot;#\u0026quot; 分隔：\u0026quot;2#1#0#0#...\u0026quot;。这样，所有异位词（如 \u0026quot;aba\u0026quot;, \u0026quot;baa\u0026quot;）都会生成这个完全相同的字符串 key。 你提供的答案正是采用了这种思路，通过一个辅助函数 strToCount 将频率数组转换成一个固定格式的字符串，同样起到了唯一标识的作用。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:2:1","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#核心思路寻找唯一标识"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func groupAnagrams(strs []string) [][]string { // 直接使用 [26]int 数组作为 key，避免了复杂的字符串转换 m := make(map[[26]int][]string) for _, str := range strs { cnt := [26]int{} for i := 0; i \u0026lt; len(str); i++ { cnt[str[i]-\u0026#39;a\u0026#39;]++ } // 直接追加，无需判断是否存在 m[cnt] = append(m[cnt], str) } res := make([][]string, 0, len(m)) for _, list := range m { res = append(res, list) } return res }复杂度分析 设 N 是字符串数组 strs 的长度，K 是数组中字符串的最大长度。 时间复杂度: O(N⋅K)O(N \\cdot K)O(N⋅K)。我们需要遍历 N 个字符串，对于每个长度为 K 的字符串，计算其字符频率的时间是 O(K)O(K)O(K)。 空间复杂度: O(N⋅K)O(N \\cdot K)O(N⋅K)。用于存储哈希表和结果。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:2:2","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#代码实现-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"128. 最长连续序列 - Mid ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:3:0","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#128-最长连续序列---mid"},{"categories":["算法","LeetCode"],"collections":null,"content":"题目回顾 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n)O(n)O(n) 的算法解决此问题。 示例 1： 输入： nums = [100,4,200,1,3,2] 输出： 4 解释： 最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:3:1","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#题目回顾-1"},{"categories":["算法","LeetCode"],"collections":null,"content":"核心思路：哈希集合 + 智能枚举 这道题最核心的要求是 O(n)O(n)O(n) 的时间复杂度，这意味着我们不能使用排序 O(nlog⁡n)O(n \\log n)O(nlogn)。 要实现 O(n)O(n)O(n)，关键在于快速查找某个数是否存在。这让我们自然而然地想到了哈希表。我们可以用一个哈希集合 (HashSet) 来优化查找过程。 这题的关键是找出序列起点来剪枝 空间换时间，初始化哈希集合 创建一个 HashSet，并将数组 nums 中的所有元素都添加进去。 这一步有两个目的：一是方便后续以 O(1)O(1)O(1) 的时间复杂度快速查找某个数是否存在；二是自动处理了数组中的重复元素。 智能遍历，只从序列的起点开始计算 这是整个算法最精妙的地方。如果我们遍历集合中的每一个数，都尝试计算以它开头的序列长度，会有大量重复计算。例如，对于序列 [1, 2, 3, 4]，我们从 1 开始计算了一遍，又会从 2 开始再计算一遍 [2, 3, 4]，这是不必要的。 如何避免重复计算？ 答案是：只从一个连续序列的起点开始计算。 如何判断一个数 num 是不是起点？ 很简单，只要检查 num - 1 是否存在于哈希集合中。如果 num - 1 不存在，那么 num 就是一个潜在的序列起点。如果 num - 1 存在，那么 num 肯定不是起点，我们可以直接跳过它，因为它一定会被 num - 1 开始的计算所覆盖。 计算长度并更新结果 遍历哈希集合，对于每个元素 num： 判断是否为起点：if)if _, ok := s[num-1]; !ok 如果是起点：就从 num 开始，不断检查 num + 1, num + 2, \u0026hellip; 是否存在于集合中，以此计算出当前序列的长度。 更新最大值：将当前计算出的长度与全局的最大长度进行比较并更新。 通过这种\u0026quot;只从起点开始\u0026quot;的智能枚举，我们确保了每个数字作为序列的一部分，只会被内层循环访问一次，从而将总时间复杂度控制在 O(n)O(n)O(n)。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:3:2","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#核心思路哈希集合--智能枚举"},{"categories":["算法","LeetCode"],"collections":null,"content":"代码实现 func longestConsecutive(nums []int) int { // 1. 初始化哈希表，存入数组中的每一个数值 s := make(map[int]struct{}) for _, num := range nums { s[num] = struct{}{} } ans := 0 // 2. 遍历哈希表 for num := range s { // 只有当 num-1 不存在时，才将 num 视为序列的起点 // 如果num-1存在，说明在前面已经便利过了 直接跳过 if _, ok := s[num-1]; !ok { currentNum := num currentLen := 1 // 3. 检查后续数字是否存在 for { if _, ok := s[currentNum+1]; ok { currentLen++ currentNum++ } else { break } } // 4. 更新最大长度（比 math.Max 更高效, 因为math.Max需转换为float） if currentLen \u0026gt; ans { ans = currentLen } } } return ans }复杂度分析 时间复杂度: O(n)O(n)O(n)。 虽然代码里有嵌套的 for 循环，但它依然是线性的： 每个数字最多进入内层循环一次 。 只有序列的“最小元素”会触发内层循环。例如对于序列 [1, 2, 3, 4, 5]，只有当 num = 1 时才会进入 while 循环走 5 次；当 num 为 2, 3, 4, 5 时，都会因为 num-1 存在而被跳过。 结论： 每个元素在整个算法中最多被访问两次，时间复杂度为 O(n)O(n)O(n)。 空间复杂度: O(n)O(n)O(n)。在最坏情况下，数组中所有元素都不同，HashSet 需要存储 n 个元素。 ","date":"2026-01-24","objectID":"/posts/2026-01-24-hash/:3:3","tags":["Go","哈希","题解"],"title":"[Golang] LeetCode 热题 100 - 哈希","uri":"/posts/2026-01-24-hash/#代码实现-2"}]