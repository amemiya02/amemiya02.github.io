<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Golang] LeetCode 热题 100 - 回溯 | 个人技术博客</title>
<meta name="keywords" content="Go, 回溯, 题解">
<meta name="description" content="回溯
46. 全排列 - Medium
题目回顾

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

核心思路
回溯算法可以抽象为一个决策树的遍历过程：

路径与选择列表
路径 (Path)：已经做出的选择（代码中的 path）。

选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。


终止条件
当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。


撤销选择 (Backtrack)
这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。


代码实现
func permute(nums []int) [][]int {
    var res [][]int
    path := []int{}
    used := make([]bool, len(nums))

    var backtrack func()
    backtrack = func() {
        // 终止条件：路径长度等于数组长度
        if len(path) == len(nums) {
            // 注意：Go 中切片是引用传递，必须进行拷贝
            temp := make([]int, len(path))
            copy(temp, path)
            res = append(res, temp)
            return
        }

        for i := 0; i &lt; len(nums); i&#43;&#43; {
            // 如果该数字已经用过，跳过
            if used[i] {
                continue
            }

            // 1. 做选择
            used[i] = true
            path = append(path, nums[i])

            // 2. 递归进入下一层
            backtrack()

            // 3. 撤销选择（回溯）
            path = path[:len(path)-1]
            used[i] = false
        }
    }

    backtrack()
    return res
}
复杂度分析

时间复杂度：$O(n * n!)$，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。
空间复杂度：$O(n)$，用于存储递归栈和路径。

78. 子集 - Medium
题目回顾

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。">
<meta name="author" content="">
<link rel="canonical" href="https://amemiya02.github.io/posts/2026-02-03-backtracking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://amemiya02.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://amemiya02.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://amemiya02.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://amemiya02.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://amemiya02.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://amemiya02.github.io/posts/2026-02-03-backtracking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],
      inlineMath: [['\\(', '\\)'], ['$', '$']],
    },
    loader: { load: ['ui/safe'] },
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://amemiya02.github.io/posts/2026-02-03-backtracking/">
  <meta property="og:site_name" content="个人技术博客">
  <meta property="og:title" content="[Golang] LeetCode 热题 100 - 回溯">
  <meta property="og:description" content="回溯 46. 全排列 - Medium 题目回顾 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
核心思路 回溯算法可以抽象为一个决策树的遍历过程：
路径与选择列表 路径 (Path)：已经做出的选择（代码中的 path）。 选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。
终止条件 当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。
撤销选择 (Backtrack) 这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。
代码实现 func permute(nums []int) [][]int { var res [][]int path := []int{} used := make([]bool, len(nums)) var backtrack func() backtrack = func() { // 终止条件：路径长度等于数组长度 if len(path) == len(nums) { // 注意：Go 中切片是引用传递，必须进行拷贝 temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) return } for i := 0; i &lt; len(nums); i&#43;&#43; { // 如果该数字已经用过，跳过 if used[i] { continue } // 1. 做选择 used[i] = true path = append(path, nums[i]) // 2. 递归进入下一层 backtrack() // 3. 撤销选择（回溯） path = path[:len(path)-1] used[i] = false } } backtrack() return res } 复杂度分析 时间复杂度：$O(n * n!)$，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。 空间复杂度：$O(n)$，用于存储递归栈和路径。 78. 子集 - Medium 题目回顾 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-03T09:01:00+09:00">
    <meta property="article:modified_time" content="2026-02-03T09:01:00+09:00">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="回溯">
    <meta property="article:tag" content="题解">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Golang] LeetCode 热题 100 - 回溯">
<meta name="twitter:description" content="回溯
46. 全排列 - Medium
题目回顾

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

核心思路
回溯算法可以抽象为一个决策树的遍历过程：

路径与选择列表
路径 (Path)：已经做出的选择（代码中的 path）。

选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。


终止条件
当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。


撤销选择 (Backtrack)
这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。


代码实现
func permute(nums []int) [][]int {
    var res [][]int
    path := []int{}
    used := make([]bool, len(nums))

    var backtrack func()
    backtrack = func() {
        // 终止条件：路径长度等于数组长度
        if len(path) == len(nums) {
            // 注意：Go 中切片是引用传递，必须进行拷贝
            temp := make([]int, len(path))
            copy(temp, path)
            res = append(res, temp)
            return
        }

        for i := 0; i &lt; len(nums); i&#43;&#43; {
            // 如果该数字已经用过，跳过
            if used[i] {
                continue
            }

            // 1. 做选择
            used[i] = true
            path = append(path, nums[i])

            // 2. 递归进入下一层
            backtrack()

            // 3. 撤销选择（回溯）
            path = path[:len(path)-1]
            used[i] = false
        }
    }

    backtrack()
    return res
}
复杂度分析

时间复杂度：$O(n * n!)$，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。
空间复杂度：$O(n)$，用于存储递归栈和路径。

78. 子集 - Medium
题目回顾

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://amemiya02.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Golang] LeetCode 热题 100 - 回溯",
      "item": "https://amemiya02.github.io/posts/2026-02-03-backtracking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Golang] LeetCode 热题 100 - 回溯",
  "name": "[Golang] LeetCode 热题 100 - 回溯",
  "description": "回溯 46. 全排列 - Medium 题目回顾 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n核心思路 回溯算法可以抽象为一个决策树的遍历过程：\n路径与选择列表 路径 (Path)：已经做出的选择（代码中的 path）。 选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。\n终止条件 当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。\n撤销选择 (Backtrack) 这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。\n代码实现 func permute(nums []int) [][]int { var res [][]int path := []int{} used := make([]bool, len(nums)) var backtrack func() backtrack = func() { // 终止条件：路径长度等于数组长度 if len(path) == len(nums) { // 注意：Go 中切片是引用传递，必须进行拷贝 temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) return } for i := 0; i \u0026lt; len(nums); i++ { // 如果该数字已经用过，跳过 if used[i] { continue } // 1. 做选择 used[i] = true path = append(path, nums[i]) // 2. 递归进入下一层 backtrack() // 3. 撤销选择（回溯） path = path[:len(path)-1] used[i] = false } } backtrack() return res } 复杂度分析 时间复杂度：$O(n * n!)$，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。 空间复杂度：$O(n)$，用于存储递归栈和路径。 78. 子集 - Medium 题目回顾 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n",
  "keywords": [
    "Go", "回溯", "题解"
  ],
  "articleBody": "回溯 46. 全排列 - Medium 题目回顾 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n核心思路 回溯算法可以抽象为一个决策树的遍历过程：\n路径与选择列表 路径 (Path)：已经做出的选择（代码中的 path）。 选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。\n终止条件 当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。\n撤销选择 (Backtrack) 这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。\n代码实现 func permute(nums []int) [][]int { var res [][]int path := []int{} used := make([]bool, len(nums)) var backtrack func() backtrack = func() { // 终止条件：路径长度等于数组长度 if len(path) == len(nums) { // 注意：Go 中切片是引用传递，必须进行拷贝 temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) return } for i := 0; i \u003c len(nums); i++ { // 如果该数字已经用过，跳过 if used[i] { continue } // 1. 做选择 used[i] = true path = append(path, nums[i]) // 2. 递归进入下一层 backtrack() // 3. 撤销选择（回溯） path = path[:len(path)-1] used[i] = false } } backtrack() return res } 复杂度分析 时间复杂度：$O(n * n!)$，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。 空间复杂度：$O(n)$，用于存储递归栈和路径。 78. 子集 - Medium 题目回顾 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n核心思路 子集问题可以看作是在一棵多叉树上收集所有节点，而排列/组合问题通常只收集叶子节点。\n为什么用 start 参数？ 在全排列中我们使用 used 数组，因为顺序不同是不同的排列。但在子集中，[1, 2] 和 [2, 1] 是同一个集合。为了去重，我们规定搜索顺序：只选取当前元素之后的元素。\n拷贝的重要性 和全排列一样，res = append(res, temp) 这一步必须拷贝 path。Go 的切片底层共享数组，如果不拷贝，回溯操作会修改 res 中已经存储的内容。\n代码实现 func subsets(nums []int) [][]int { var res [][]int var path []int // 定义回溯函数，start 保证我们只往后看，避免重复 var backtrack func(start int) backtrack = func(start int) { // 1. 每一个节点都是一个子集，直接加入结果集 // 注意：必须进行深拷贝 temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) // 2. 遍历候选列表 for i := start; i \u003c len(nums); i++ { // 做选择 path = append(path, nums[i]) // 递归：从当前元素的下一个开始，避免元素重复使用 backtrack(i + 1) // 撤销选择（回溯） path = path[:len(path)-1] } } backtrack(0) return res } 复杂度分析 时间复杂度：$O(n * 2^n)$，其中 n 是数组的长度。子集的数量是 2^n，每个子集需要 O(n) 的时间来构建和复制到结果中。 空间复杂度：$O(n)$，用于存储递归栈和路径。 17. 电话号码的字母组合 - Medium 题目回顾 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n核心思路 映射关系 我们建立了一个从数字字符（如 ‘2’）到字符串（如 “abc”）的映射。这决定了搜索每一层时的“分支数量”。\n决策树结构 树的深度：由输入 digits 的长度决定。\n每一层的宽度：由对应数字包含的字母数量（3 或 4 个）决定。\n为什么不需要 used 数组？ 在全排列中，我们需要 used 来防止同一个元素被多次选取。但在电话组合中，由于每一层递归处理的是不同的数字集合，我们只需要一个 index 记录当前处理到 digits 的第几个字符，天然地保证了不会重复使用同一个位置。 代码实现 func letterCombinations(digits string) []string { if len(digits) == 0 { return nil } // 1. 定义数字与字母的映射表 phoneMap := map[byte]string{ '2': \"abc\", '3': \"def\", '4': \"ghi\", '5': \"jkl\", '6': \"mno\", '7': \"pqrs\", '8': \"tuv\", '9': \"wxyz\", } var res []string var path []byte // 2. 定义回溯函数 var backtrack func(index int) backtrack = func(index int) { // 终止条件：路径长度等于输入数字的长度 if index == len(digits) { res = append(res, string(path)) return } // 取出当前数字对应的所有字母 digit := digits[index] letters := phoneMap[digit] // 遍历当前数字对应的每一个字母 for i := 0; i \u003c len(letters); i++ { // 做选择 path = append(path, letters[i]) // 递归：处理下一个数字 backtrack(index + 1) // 撤销选择（回溯） path = path[:len(path)-1] } } backtrack(0) return res } 复杂度分析 时间复杂度：$O(3^m * 4^n)$，其中 m 是输入数字中对应 3 个字母的数字个数，n 是对应 4 个字母的数字个数。每个组合需要 O(m + n) 的时间来构建和复制到结果中。 空间复杂度：$O(m + n)$，用于存储递归栈和路径。 39. 组合总和 - Medium 题目回顾 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字 可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两个组合是不同的。对于给定的输入，保证和为 target 的不同组合数量少于 150 个。\n核心思路 核心要点解析\n如何实现“无限制重复选取”？ 在 dfs(…, i) 这一步。 如果是 i + 1：代表每个元素只能选一次（如“子集”问题）。\n如果是 i：代表在当前的决策树分支下，下一层依然可以从当前这个元素开始选，从而实现重复。\n为什么需要 start 变量？ 为了去重。如果我们每一层都从索引 0 开始遍历，就会出现 [2, 2, 3] 和 [2, 3, 2]、[3, 2, 2] 这种由于顺序不同而产生的重复组合。通过 start 确保我们只选取“当前或之后”的元素，强制了结果集的顺序性。\n剪枝优化 (Pruning) 在循环中，如果发现 remain - candidates[i] \u003c 0，由于数组是升序的，后面的 candidates[i+1] 肯定也会让结果小于 0。直接 break 掉当前循环，可以减少大量的递归调用。\n代码实现 import \"sort\" func combinationSum(candidates []int, target int) [][]int { var res [][]int var path []int // 1. 排序是为了后续的剪枝优化 sort.Ints(candidates) var backtrack func(remain int, start int) backtrack = func(remain int, start int) { // 终止条件：正好凑成目标金额 if remain == 0 { temp := make([]int, len(path)) copy(temp, path) res = append(res, temp) return } // 从 start 开始遍历，避免产生 [2, 3] 和 [3, 2] 这种重复组合 for i := start; i \u003c len(candidates); i++ { // 2. 剪枝：由于数组已排序，如果当前数字已大于剩余值，后续数字也一定大于 if remain - candidates[i] \u003c 0 { break } // 做选择 path = append(path, candidates[i]) // 3. 递归：关键点在于传递 i 而不是 i + 1，表示当前数字可以重复使用 backtrack(remain - candidates[i], i) // 撤销选择（回溯） path = path[:len(path)-1] } } backtrack(target, 0) return res } 复杂度分析 时间复杂度：$O(2^t)$，其中 t 是目标值 target。最坏情况下，每个数字都可以被多次选择，导致递归树的高度接近 t。 空间复杂度：$O(t)$，用于存储递归栈和路径。 22. 括号生成 - Medium 题目回顾 给你一个整数 n ，请你生成所有由 n 对括号组成的有效括号组合。\n核心思路 有效性剪枝\n生成有效括号的核心其实只有两条“潜规则”：\n左括号优先：只要还没放满 $n$ 个，随时可以放左括号 (。\n右括号限制：右括号 ) 必须在有对应的左括号等待匹配时才能放。也就是说，当前已放的右括号数量必须严格小于左括号数量。\n通过这两个简单的 if 限制，我们生成的每一条路径最终到达叶子节点时，都必然是一个完美的括号匹配字符串。\n代码实现 func generateParenthesis(n int) []string { var res []string var path []byte // left: 当前已使用的左括号数量 // right: 当前已使用的右括号数量 var backtrack func(left, right int) backtrack = func(left, right int) { // 终止条件：路径长度达到 2n if len(path) == 2*n { res = append(res, string(path)) return } // 核心规则 1：只要左括号没用完，就可以放左括号 if left \u003c n { path = append(path, '(') backtrack(left+1, right) path = path[:len(path)-1] // 回溯 } // 核心规则 2：只有当右括号数量小于左括号时，才能放右括号 // 这样可以保证任意时刻右括号都不会比左括号多（有效性保证） if right \u003c left { path = append(path, ')') backtrack(left, right+1) path = path[:len(path)-1] // 回溯 } } backtrack(0, 0) return res } 复杂度分析 时间复杂度：$O(\\frac{4^n}{\\sqrt{n}})$，这是生成所有有效括号组合的卡特兰数复杂度。 空间复杂度：$O(n)$，用于存储递归栈和路径。 79. 单词搜索 - Medium 题目回顾 给定一个 m x n 二维字符网格 board 和一个字符串单词 word ，如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n核心思路 状态重置 (The “Back” in Backtracking)当你访问 board[i][j] 后，必须暂时标记它。如果不标记，搜索路径可能会在同一个格子上打转（例如单词是 ABA，路径可能在两个相邻的 A 和 B 之间反复横跳）。在 DFS 返回后，必须将 board[i][j] 改回原值，确保 下一轮从不同起点开始的搜索 能够正常使用这个格子。\n通过 board[i][j] = ‘#’ 这种原地修改法，将额外空间复杂度降到了 $O(1)$（不计递归栈空间）。这是面试中加分的优化技巧。\n短路逻辑 (Short-circuiting)在 Go 实现中，res := dfs(…) || dfs(…) || … 利用了逻辑或的短路特性。一旦第一个 dfs 返回 true，后面的方向就不会再执行，这比显式判断 if found { return } 更加简洁高效。\n代码实现 func exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) // 定义 DFS 闭包 var dfs func(i, j, k int) bool dfs = func(i, j, k int) bool { // 1. 终止条件：匹配完单词所有字符 if k == len(word) { return true } // 2. 越界检查、字符不匹配检查 if i \u003c 0 || i \u003e= m || j \u003c 0 || j \u003e= n || board[i][j] != word[k] { return false } // 3. 标记当前单元格已访问（避免重复使用同一字母） // 这是一个地道的技巧：将其修改为一个非字母字符，省去 used 数组 temp := board[i][j] board[i][j] = '#' // 4. 向四个方向递归探索 // 只要有一个方向成功，就返回 true res := dfs(i+1, j, k+1) || dfs(i-1, j, k+1) || dfs(i, j+1, k+1) || dfs(i, j-1, k+1) // 5. 回溯：恢复现场 board[i][j] = temp return res } // 遍历起点 for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { if board[i][j] == word[0] { if dfs(i, j, 0) { return true } } } } return false } 复杂度分析 时间复杂度：$O(m * n * 3^l)$，其中 m 和 n 分别是网格的行数和列数，l 是单词的长度。每个单元格作为起点进行 DFS，最多有 3 个方向可选（因为不能回到来时的路）。 空间复杂度：$O(l)$，用于存储递归栈，最坏情况下递归深度为单词长度 l。 131. 分割回文串 - Medium 题目回顾 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n核心思路 决策树模型 每一层递归：代表在当前剩余字符串中选择一个前缀。 分支：如果前缀是回文，则进入下一层；如果不是，则剪枝（不继续往下走）。\n路径收集：当指针移动到字符串末尾，说明找到了一种完整的分割方案。\n状态重置 在 Go 中，path = path[:len(path)-1] 完成了回溯。这保证了在尝试不同的切割长度时，path 始终保持干净。 代码实现 func partition(s string) [][]string { var res [][]string var path []string // backtrack 逻辑：从 index 开始尝试切割 var backtrack func(index int) backtrack = func(index int) { // 1. 终止条件：如果已经切到了字符串末尾 if index == len(s) { // 拷贝 path 存入结果 temp := make([]string, len(path)) copy(temp, path) res = append(res, temp) return } // 2. 尝试从 index 到 i 进行切割 for i := index; i \u003c len(s); i++ { // 3. 剪枝：只有当前切割出的子串 [index, i] 是回文，才继续递归 if isPalindrome(s, index, i) { // 做选择 path = append(path, s[index:i+1]) // 递归：从 i+1 位置继续切割剩余字符串 backtrack(i + 1) // 撤销选择（回溯） path = path[:len(path)-1] } } } backtrack(0) return res } // 辅助函数：判断 s[left:right+1] 是否为回文 func isPalindrome(s string, left, right int) bool { for left \u003c right { if s[left] != s[right] { return false } left++ right-- } return true } 性能优化：动态规划预处理 在上面的代码中，isPalindrome 可能会被重复调用多次。如果面试官要求优化时间，我们可以先用 动态规划 预处理出一个二维数组 dp[i][j]，用来记录 s[i:j+1] 是否为回文。\nfunc partition(s string) [][]string { n := len(s) // dp[i][j] 表示 s[i..j] 是否是回文 dp := make([][]bool, n) for i := range dp { dp[i] = make([]bool, n) } // 预处理回文状态 for j := 0; j \u003c n; j++ { for i := 0; i \u003c= j; i++ { if s[i] == s[j] \u0026\u0026 (j-i \u003c= 2 || dp[i+1][j-1]) { dp[i][j] = true } } } var res [][]string var path []string var backtrack func(int) backtrack = func(start int) { if start == n { res = append(res, append([]string(nil), path...)) return } for i := start; i \u003c n; i++ { if dp[start][i] { path = append(path, s[start:i+1]) backtrack(i + 1) path = path[:len(path)-1] } } } backtrack(0) return res } 复杂度分析 时间复杂度：$O(n * 2^n)$，其中 n 是字符串的长度。最坏情况下，每个字符都可以单独成一个回文子串，导致组合数量达到 2^n。 空间复杂度：$O(n)$，用于存储递归栈和路径。 51. N 皇后 - Hard 题目回顾 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。\n核心思路 处理行和列的冲突很简单，但处理斜线是这道题的精髓。\n捺斜线 (Backslash )在同一条撇向斜线上，所有的坐标 $(row, col)$ 都满足 $row - col$ 是常数。例如：$(0,0), (1,1), (2,2)$ 的差值都是 $0$。注意：差值可能为负，但 Go 的 map 支持负数 key。\n撇斜线 (Slash /)在同一条正向斜线上，所有的坐标 $(row, col)$ 都满足 $row + col$ 是常数。例如：$(0,2), (1,1), (2,0)$ 的和都是 $2$。\n代码实现 func solveNQueens(n int) [][]string { var res [][]string // 棋盘初始化 board := make([][]byte, n) for i := range board { board[i] = make([]byte, n) for j := range board[i] { board[i][j] = '.' } } // 用于快速检查冲突的状态记录 cols := make(map[int]bool) // 列冲突 diag1 := make(map[int]bool) // 捺冲突 (\\): 行-列 = 定值 diag2 := make(map[int]bool) // 撇冲突 (/): 行+列 = 定值 var backtrack func(row int) backtrack = func(row int) { // 1. 终止条件：成功放置了 n 个皇后 if row == n { res = append(res, formatBoard(board)) return } // 2. 尝试在当前行的每一列放置皇后 for col := 0; col \u003c n; col++ { // 3. 剪枝：检查当前位置是否会被之前的皇后攻击 if cols[col] || diag1[row-col] || diag2[row+col] { continue } // 4. 做选择 board[row][col] = 'Q' cols[col], diag1[row-col], diag2[row+col] = true, true, true // 5. 进入下一行递归 backtrack(row + 1) // 6. 撤销选择（回溯） board[row][col] = '.' delete(cols, col) delete(diag1, row-col) delete(diag2, row+col) } } backtrack(0) return res } // 辅助函数：将二维 byte 棋盘转换为题目要求的字符串切片 func formatBoard(board [][]byte) []string { var s []string for _, row := range board { s = append(s, string(row)) } return s } 复杂度分析 时间复杂度：$O(N!)$，其中 N 是棋盘的大小。 每一行有 N 个选择，第二行有 N-1 个选择，依此类推，整体复杂度近似为 N!。 空间复杂度：$O(N)$，用于存储递归栈和棋盘状态。 ",
  "wordCount" : "1509",
  "inLanguage": "en",
  "datePublished": "2026-02-03T09:01:00+09:00",
  "dateModified": "2026-02-03T09:01:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://amemiya02.github.io/posts/2026-02-03-backtracking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "个人技术博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://amemiya02.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://amemiya02.github.io/" accesskey="h" title="个人技术博客 (Alt + H)">个人技术博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://amemiya02.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://amemiya02.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [Golang] LeetCode 热题 100 - 回溯
    </h1>
    <div class="post-meta"><span title='2026-02-03 09:01:00 +0900 +0900'>February 3, 2026</span>&nbsp;·&nbsp;<span>8 min</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%9b%9e%e6%ba%af" aria-label="回溯">回溯</a><ul>
                        
                <li>
                    <a href="#46-%e5%85%a8%e6%8e%92%e5%88%97---medium" aria-label="46. 全排列 - Medium">46. 全排列 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#78-%e5%ad%90%e9%9b%86---medium" aria-label="78. 子集 - Medium">78. 子集 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-1" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-1" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-1" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#17-%e7%94%b5%e8%af%9d%e5%8f%b7%e7%a0%81%e7%9a%84%e5%ad%97%e6%af%8d%e7%bb%84%e5%90%88---medium" aria-label="17. 电话号码的字母组合 - Medium">17. 电话号码的字母组合 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-2" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-2" aria-label="核心思路">核心思路</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2" aria-label="代码实现">代码实现</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-2" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#39-%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8c---medium" aria-label="39. 组合总和 - Medium">39. 组合总和 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-3" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-3" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-3" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#22-%e6%8b%ac%e5%8f%b7%e7%94%9f%e6%88%90---medium" aria-label="22. 括号生成 - Medium">22. 括号生成 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-4" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-4" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-4" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-4" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#79-%e5%8d%95%e8%af%8d%e6%90%9c%e7%b4%a2---medium" aria-label="79. 单词搜索 - Medium">79. 单词搜索 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-5" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-5" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-5" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-5" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#131-%e5%88%86%e5%89%b2%e5%9b%9e%e6%96%87%e4%b8%b2---medium" aria-label="131. 分割回文串 - Medium">131. 分割回文串 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-6" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-6" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-6" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-6" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#51-n-%e7%9a%87%e5%90%8e---hard" aria-label="51. N 皇后 - Hard">51. N 皇后 - Hard</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-7" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-7" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-7" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-7" aria-label="复杂度分析">复杂度分析</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="回溯">回溯<a hidden class="anchor" aria-hidden="true" href="#回溯">#</a></h1>
<h2 id="46-全排列---medium"><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#46-全排列---medium">#</a></h2>
<h3 id="题目回顾">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾">#</a></h3>
<blockquote>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
</blockquote>
<h3 id="核心思路">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路">#</a></h3>
<p>回溯算法可以抽象为一个决策树的遍历过程：</p>
<ol>
<li>路径与选择列表
路径 (Path)：已经做出的选择（代码中的 path）。</li>
</ol>
<p>选择列表 (Used)：当前还可以做的选择（代码中的 !used[i]）。</p>
<ol start="2">
<li>
<p>终止条件
当到达叶子节点（len(path) == len(nums)），说明找到了一组完整的排列。</p>
</li>
<li>
<p>撤销选择 (Backtrack)
这是最关键的一步。在递归返回后，我们需要把最后加入 path 的元素弹出，并将 used 标记改回 false。这就像是在走迷宫时，发现死胡同后退回到上一个分叉口。</p>
</li>
</ol>
<h3 id="代码实现">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">permute</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">path</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">used</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">bool</span>, len(<span style="color:#a6e22e">nums</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 终止条件：路径长度等于数组长度</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">path</span>) <span style="color:#f92672">==</span> len(<span style="color:#a6e22e">nums</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 注意：Go 中切片是引用传递，必须进行拷贝</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">temp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">path</span>))
</span></span><span style="display:flex;"><span>            copy(<span style="color:#a6e22e">temp</span>, <span style="color:#a6e22e">path</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">temp</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">nums</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果该数字已经用过，跳过</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">used</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 1. 做选择</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">used</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 2. 递归进入下一层</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">backtrack</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 3. 撤销选择（回溯）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">used</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析">#</a></h3>
<ul>
<li>时间复杂度：$O(n * n!)$，其中 n 是数组的长度。全排列的数量是 n!，每个排列需要 O(n) 的时间来构建和复制到结果中。</li>
<li>空间复杂度：$O(n)$，用于存储递归栈和路径。</li>
</ul>
<h2 id="78-子集---medium"><a href="https://leetcode-cn.com/problems/subsets/">78. 子集 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#78-子集---medium">#</a></h2>
<h3 id="题目回顾-1">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-1">#</a></h3>
<blockquote>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
</blockquote>
<h3 id="核心思路-1">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-1">#</a></h3>
<p>子集问题可以看作是在一棵多叉树上收集所有节点，而排列/组合问题通常只收集叶子节点。</p>
<ol>
<li>
<p>为什么用 start 参数？
在全排列中我们使用 used 数组，因为顺序不同是不同的排列。但在子集中，[1, 2] 和 [2, 1] 是同一个集合。为了去重，我们规定搜索顺序：只选取当前元素之后的元素。</p>
</li>
<li>
<p>拷贝的重要性
和全排列一样，res = append(res, temp) 这一步必须拷贝 path。Go 的切片底层共享数组，如果不拷贝，回溯操作会修改 res 中已经存储的内容。</p>
</li>
</ol>
<h3 id="代码实现-1">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">subsets</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">path</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义回溯函数，start 保证我们只往后看，避免重复</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">start</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">start</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 每一个节点都是一个子集，直接加入结果集</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 注意：必须进行深拷贝</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">temp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">path</span>))
</span></span><span style="display:flex;"><span>        copy(<span style="color:#a6e22e">temp</span>, <span style="color:#a6e22e">path</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">temp</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 遍历候选列表</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">nums</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 做选择</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 递归：从当前元素的下一个开始，避免元素重复使用</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 撤销选择（回溯）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-1">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-1">#</a></h3>
<ul>
<li>时间复杂度：$O(n * 2^n)$，其中 n 是数组的长度。子集的数量是 2^n，每个子集需要 O(n) 的时间来构建和复制到结果中。</li>
<li>空间复杂度：$O(n)$，用于存储递归栈和路径。</li>
</ul>
<h2 id="17-电话号码的字母组合---medium"><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#17-电话号码的字母组合---medium">#</a></h2>
<h3 id="题目回顾-2">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-2">#</a></h3>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
<h3 id="核心思路-2">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-2">#</a></h3>
<ol>
<li>
<p>映射关系
我们建立了一个从数字字符（如 &lsquo;2&rsquo;）到字符串（如 &ldquo;abc&rdquo;）的映射。这决定了搜索每一层时的“分支数量”。</p>
</li>
<li>
<p>决策树结构
树的深度：由输入 digits 的长度决定。</p>
</li>
</ol>
<p>每一层的宽度：由对应数字包含的字母数量（3 或 4 个）决定。</p>
<ol start="3">
<li>为什么不需要 used 数组？
在全排列中，我们需要 used 来防止同一个元素被多次选取。但在电话组合中，由于每一层递归处理的是不同的数字集合，我们只需要一个 index 记录当前处理到 digits 的第几个字符，天然地保证了不会重复使用同一个位置。</li>
</ol>
<h4 id="代码实现-2">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-2">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">letterCombinations</span>(<span style="color:#a6e22e">digits</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">digits</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 定义数字与字母的映射表</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">phoneMap</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">byte</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;2&#39;</span>: <span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#e6db74">&#39;3&#39;</span>: <span style="color:#e6db74">&#34;def&#34;</span>, <span style="color:#e6db74">&#39;4&#39;</span>: <span style="color:#e6db74">&#34;ghi&#34;</span>, <span style="color:#e6db74">&#39;5&#39;</span>: <span style="color:#e6db74">&#34;jkl&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;6&#39;</span>: <span style="color:#e6db74">&#34;mno&#34;</span>, <span style="color:#e6db74">&#39;7&#39;</span>: <span style="color:#e6db74">&#34;pqrs&#34;</span>, <span style="color:#e6db74">&#39;8&#39;</span>: <span style="color:#e6db74">&#34;tuv&#34;</span>, <span style="color:#e6db74">&#39;9&#39;</span>: <span style="color:#e6db74">&#34;wxyz&#34;</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">path</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 定义回溯函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 终止条件：路径长度等于输入数字的长度</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">==</span> len(<span style="color:#a6e22e">digits</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, string(<span style="color:#a6e22e">path</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 取出当前数字对应的所有字母</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">digit</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">digits</span>[<span style="color:#a6e22e">index</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">letters</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">phoneMap</span>[<span style="color:#a6e22e">digit</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历当前数字对应的每一个字母</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">letters</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 做选择</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">letters</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 递归：处理下一个数字</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">index</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 撤销选择（回溯）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-2">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-2">#</a></h3>
<ul>
<li>时间复杂度：$O(3^m * 4^n)$，其中 m 是输入数字中对应 3 个字母的数字个数，n 是对应 4 个字母的数字个数。每个组合需要 O(m + n) 的时间来构建和复制到结果中。</li>
<li>空间复杂度：$O(m + n)$，用于存储递归栈和路径。</li>
</ul>
<h2 id="39-组合总和---medium"><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#39-组合总和---medium">#</a></h2>
<h3 id="题目回顾-3">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-3">#</a></h3>
<blockquote>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字 可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两个组合是不同的。对于给定的输入，保证和为 target 的不同组合数量少于 150 个。</p>
</blockquote>
<h3 id="核心思路-3">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-3">#</a></h3>
<p>核心要点解析</p>
<ol>
<li>如何实现“无限制重复选取”？
在 dfs(&hellip;, i) 这一步。</li>
</ol>
<p>如果是 i + 1：代表每个元素只能选一次（如“子集”问题）。</p>
<p>如果是 i：代表在当前的决策树分支下，下一层依然可以从当前这个元素开始选，从而实现重复。</p>
<ol start="2">
<li>
<p>为什么需要 start 变量？
为了去重。如果我们每一层都从索引 0 开始遍历，就会出现 [2, 2, 3] 和 [2, 3, 2]、[3, 2, 2] 这种由于顺序不同而产生的重复组合。通过 start 确保我们只选取“当前或之后”的元素，强制了结果集的顺序性。</p>
</li>
<li>
<p>剪枝优化 (Pruning)
在循环中，如果发现 remain - candidates[i] &lt; 0，由于数组是升序的，后面的 candidates[i+1] 肯定也会让结果小于 0。直接 break 掉当前循环，可以减少大量的递归调用。</p>
</li>
</ol>
<h3 id="代码实现-3">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-3">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;sort&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">combinationSum</span>(<span style="color:#a6e22e">candidates</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">path</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 排序是为了后续的剪枝优化</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Ints</span>(<span style="color:#a6e22e">candidates</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">remain</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">start</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">remain</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">start</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 终止条件：正好凑成目标金额</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">remain</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">temp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">path</span>))
</span></span><span style="display:flex;"><span>            copy(<span style="color:#a6e22e">temp</span>, <span style="color:#a6e22e">path</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">temp</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从 start 开始遍历，避免产生 [2, 3] 和 [3, 2] 这种重复组合</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">candidates</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 2. 剪枝：由于数组已排序，如果当前数字已大于剩余值，后续数字也一定大于</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">remain</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">candidates</span>[<span style="color:#a6e22e">i</span>] &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 做选择</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">candidates</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 3. 递归：关键点在于传递 i 而不是 i + 1，表示当前数字可以重复使用</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">remain</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">candidates</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 撤销选择（回溯）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">target</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-3">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-3">#</a></h3>
<ul>
<li>时间复杂度：$O(2^t)$，其中 t 是目标值 target。最坏情况下，每个数字都可以被多次选择，导致递归树的高度接近 t。</li>
<li>空间复杂度：$O(t)$，用于存储递归栈和路径。</li>
</ul>
<h2 id="22-括号生成---medium"><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#22-括号生成---medium">#</a></h2>
<h3 id="题目回顾-4">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-4">#</a></h3>
<blockquote>
<p>给你一个整数 n ，请你生成所有由 n 对括号组成的有效括号组合。</p>
</blockquote>
<h3 id="核心思路-4">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-4">#</a></h3>
<p>有效性剪枝</p>
<p>生成有效括号的核心其实只有两条“潜规则”：</p>
<ol>
<li>
<p>左括号优先：只要还没放满 $n$ 个，随时可以放左括号 (。</p>
</li>
<li>
<p>右括号限制：右括号 ) 必须在有对应的左括号等待匹配时才能放。也就是说，当前已放的右括号数量必须严格小于左括号数量。</p>
</li>
</ol>
<p>通过这两个简单的 if 限制，我们生成的每一条路径最终到达叶子节点时，都必然是一个完美的括号匹配字符串。</p>
<h3 id="代码实现-4">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-4">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">generateParenthesis</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">path</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// left: 当前已使用的左括号数量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// right: 当前已使用的右括号数量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 终止条件：路径长度达到 2n</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">path</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">n</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, string(<span style="color:#a6e22e">path</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 核心规则 1：只要左括号没用完，就可以放左括号</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> &lt; <span style="color:#a6e22e">n</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#e6db74">&#39;(&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">left</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e">// 回溯</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 核心规则 2：只有当右括号数量小于左括号时，才能放右括号</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这样可以保证任意时刻右括号都不会比左括号多（有效性保证）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &lt; <span style="color:#a6e22e">left</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#e6db74">&#39;)&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e">// 回溯</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-4">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-4">#</a></h3>
<ul>
<li>时间复杂度：$O(\frac{4^n}{\sqrt{n}})$，这是生成所有有效括号组合的卡特兰数复杂度。</li>
<li>空间复杂度：$O(n)$，用于存储递归栈和路径。</li>
</ul>
<h2 id="79-单词搜索---medium"><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#79-单词搜索---medium">#</a></h2>
<h3 id="题目回顾-5">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-5">#</a></h3>
<blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word ，如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
</blockquote>
<h3 id="核心思路-5">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-5">#</a></h3>
<ol>
<li>
<p>状态重置 (The &ldquo;Back&rdquo; in Backtracking)当你访问 board[i][j] 后，必须暂时标记它。如果不标记，搜索路径可能会在同一个格子上打转（例如单词是 ABA，路径可能在两个相邻的 A 和 B 之间反复横跳）。在 DFS 返回后，必须将 board[i][j] 改回原值，确保 下一轮从不同起点开始的搜索 能够正常使用这个格子。</p>
</li>
<li>
<p>通过 board[i][j] = &lsquo;#&rsquo; 这种原地修改法，将额外空间复杂度降到了 $O(1)$（不计递归栈空间）。这是面试中加分的优化技巧。</p>
</li>
<li>
<p>短路逻辑 (Short-circuiting)在 Go 实现中，res := dfs(&hellip;) || dfs(&hellip;) || &hellip; 利用了逻辑或的短路特性。一旦第一个 dfs 返回 true，后面的方向就不会再执行，这比显式判断 if found { return } 更加简洁高效。</p>
</li>
</ol>
<h3 id="代码实现-5">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-5">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">exist</span>(<span style="color:#a6e22e">board</span> [][]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">word</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">board</span>), len(<span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义 DFS 闭包</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">dfs</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dfs</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 终止条件：匹配完单词所有字符</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">==</span> len(<span style="color:#a6e22e">word</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 越界检查、字符不匹配检查</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">word</span>[<span style="color:#a6e22e">k</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 标记当前单元格已访问（避免重复使用同一字母）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这是一个地道的技巧：将其修改为一个非字母字符，省去 used 数组</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">temp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#e6db74">&#39;#&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 4. 向四个方向递归探索</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 只要有一个方向成功，就返回 true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>               <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 5. 回溯：恢复现场</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">temp</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历起点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">m</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">word</span>[<span style="color:#ae81ff">0</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-5">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-5">#</a></h3>
<ul>
<li>时间复杂度：$O(m * n * 3^l)$，其中 m 和 n 分别是网格的行数和列数，l 是单词的长度。每个单元格作为起点进行 DFS，最多有 3 个方向可选（因为不能回到来时的路）。</li>
<li>空间复杂度：$O(l)$，用于存储递归栈，最坏情况下递归深度为单词长度 l。</li>
</ul>
<h2 id="131-分割回文串---medium"><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#131-分割回文串---medium">#</a></h2>
<h3 id="题目回顾-6">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-6">#</a></h3>
<blockquote>
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
</blockquote>
<h3 id="核心思路-6">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-6">#</a></h3>
<ol>
<li>决策树模型
每一层递归：代表在当前剩余字符串中选择一个前缀。</li>
</ol>
<p>分支：如果前缀是回文，则进入下一层；如果不是，则剪枝（不继续往下走）。</p>
<p>路径收集：当指针移动到字符串末尾，说明找到了一种完整的分割方案。</p>
<ol start="2">
<li>状态重置
在 Go 中，path = path[:len(path)-1] 完成了回溯。这保证了在尝试不同的切割长度时，path 始终保持干净。</li>
</ol>
<h3 id="代码实现-6">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-6">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) [][]<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">path</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// backtrack 逻辑：从 index 开始尝试切割</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 终止条件：如果已经切到了字符串末尾</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">==</span> len(<span style="color:#a6e22e">s</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 拷贝 path 存入结果</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">temp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, len(<span style="color:#a6e22e">path</span>))
</span></span><span style="display:flex;"><span>            copy(<span style="color:#a6e22e">temp</span>, <span style="color:#a6e22e">path</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">temp</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 尝试从 index 到 i 进行切割</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">index</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 3. 剪枝：只有当前切割出的子串 [index, i] 是回文，才继续递归</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isPalindrome</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">i</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 做选择</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">index</span>:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 递归：从 i+1 位置继续切割剩余字符串</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 撤销选择（回溯）</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 辅助函数：判断 s[left:right+1] 是否为回文</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isPalindrome</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">left</span> &lt; <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">left</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">right</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">right</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>性能优化：动态规划预处理
在上面的代码中，isPalindrome 可能会被重复调用多次。如果面试官要求优化时间，我们可以先用 动态规划 预处理出一个二维数组 dp[i][j]，用来记录 s[i:j+1] 是否为回文。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) [][]<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// dp[i][j] 表示 s[i..j] 是否是回文</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">dp</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 预处理回文状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">j</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">j</span>] <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">path</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">start</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">n</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, append([]string(<span style="color:#66d9ef">nil</span>), <span style="color:#a6e22e">path</span><span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">start</span>][<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">path</span> = append(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">path</span> = <span style="color:#a6e22e">path</span>[:len(<span style="color:#a6e22e">path</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-6">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-6">#</a></h3>
<ul>
<li>时间复杂度：$O(n * 2^n)$，其中 n 是字符串的长度。最坏情况下，每个字符都可以单独成一个回文子串，导致组合数量达到 2^n。</li>
<li>空间复杂度：$O(n)$，用于存储递归栈和路径。</li>
</ul>
<h2 id="51-n-皇后---hard"><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后 - Hard</a><a hidden class="anchor" aria-hidden="true" href="#51-n-皇后---hard">#</a></h2>
<h3 id="题目回顾-7">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-7">#</a></h3>
<blockquote>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &lsquo;Q&rsquo; 和 &lsquo;.&rsquo; 分别代表了皇后和空位。</p>
</blockquote>
<h3 id="核心思路-7">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-7">#</a></h3>
<p>处理行和列的冲突很简单，但处理斜线是这道题的精髓。</p>
<ol>
<li>
<p>捺斜线 (Backslash )在同一条撇向斜线上，所有的坐标 $(row, col)$ 都满足 $row - col$ 是常数。例如：$(0,0), (1,1), (2,2)$ 的差值都是 $0$。注意：差值可能为负，但 Go 的 map 支持负数 key。</p>
</li>
<li>
<p>撇斜线 (Slash /)在同一条正向斜线上，所有的坐标 $(row, col)$ 都满足 $row + col$ 是常数。例如：$(0,2), (1,1), (2,0)$ 的和都是 $2$。</p>
</li>
</ol>
<h3 id="代码实现-7">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-7">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">solveNQueens</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 棋盘初始化</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">board</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">board</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#e6db74">&#39;.&#39;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用于快速检查冲突的状态记录</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cols</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>)      <span style="color:#75715e">// 列冲突</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">diag1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>)     <span style="color:#75715e">// 捺冲突 (\): 行-列 = 定值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">diag2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>)     <span style="color:#75715e">// 撇冲突 (/): 行+列 = 定值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">backtrack</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">row</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">row</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 终止条件：成功放置了 n 个皇后</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">row</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">n</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">formatBoard</span>(<span style="color:#a6e22e">board</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 尝试在当前行的每一列放置皇后</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">col</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">col</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">col</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 3. 剪枝：检查当前位置是否会被之前的皇后攻击</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cols</span>[<span style="color:#a6e22e">col</span>] <span style="color:#f92672">||</span> <span style="color:#a6e22e">diag1</span>[<span style="color:#a6e22e">row</span><span style="color:#f92672">-</span><span style="color:#a6e22e">col</span>] <span style="color:#f92672">||</span> <span style="color:#a6e22e">diag2</span>[<span style="color:#a6e22e">row</span><span style="color:#f92672">+</span><span style="color:#a6e22e">col</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 4. 做选择</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">row</span>][<span style="color:#a6e22e">col</span>] = <span style="color:#e6db74">&#39;Q&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">cols</span>[<span style="color:#a6e22e">col</span>], <span style="color:#a6e22e">diag1</span>[<span style="color:#a6e22e">row</span><span style="color:#f92672">-</span><span style="color:#a6e22e">col</span>], <span style="color:#a6e22e">diag2</span>[<span style="color:#a6e22e">row</span><span style="color:#f92672">+</span><span style="color:#a6e22e">col</span>] = <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 5. 进入下一行递归</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">backtrack</span>(<span style="color:#a6e22e">row</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 6. 撤销选择（回溯）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">row</span>][<span style="color:#a6e22e">col</span>] = <span style="color:#e6db74">&#39;.&#39;</span>
</span></span><span style="display:flex;"><span>            delete(<span style="color:#a6e22e">cols</span>, <span style="color:#a6e22e">col</span>)
</span></span><span style="display:flex;"><span>            delete(<span style="color:#a6e22e">diag1</span>, <span style="color:#a6e22e">row</span><span style="color:#f92672">-</span><span style="color:#a6e22e">col</span>)
</span></span><span style="display:flex;"><span>            delete(<span style="color:#a6e22e">diag2</span>, <span style="color:#a6e22e">row</span><span style="color:#f92672">+</span><span style="color:#a6e22e">col</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backtrack</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 辅助函数：将二维 byte 棋盘转换为题目要求的字符串切片</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">formatBoard</span>(<span style="color:#a6e22e">board</span> [][]<span style="color:#66d9ef">byte</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">row</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">board</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, string(<span style="color:#a6e22e">row</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-7">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-7">#</a></h3>
<ul>
<li>时间复杂度：$O(N!)$，其中 N 是棋盘的大小。 每一行有 N 个选择，第二行有 N-1 个选择，依此类推，整体复杂度近似为 N!。</li>
<li>空间复杂度：$O(N)$，用于存储递归栈和棋盘状态。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://amemiya02.github.io/tags/go/">Go</a></li>
      <li><a href="https://amemiya02.github.io/tags/%E5%9B%9E%E6%BA%AF/">回溯</a></li>
      <li><a href="https://amemiya02.github.io/tags/%E9%A2%98%E8%A7%A3/">题解</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://amemiya02.github.io/posts/2026-02-05-binary-search/">
    <span class="title">« Prev</span>
    <br>
    <span>[Golang] LeetCode 热题 100 - 二分查找</span>
  </a>
  <a class="next" href="https://amemiya02.github.io/posts/2026-02-03-graph/">
    <span class="title">Next »</span>
    <br>
    <span>[Golang] LeetCode 热题 100 - 图论</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 回溯 on x"
            href="https://x.com/intent/tweet/?text=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e5%9b%9e%e6%ba%af&amp;url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f&amp;hashtags=Go%2c%e5%9b%9e%e6%ba%af%2c%e9%a2%98%e8%a7%a3">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 回溯 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f&amp;title=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e5%9b%9e%e6%ba%af&amp;summary=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e5%9b%9e%e6%ba%af&amp;source=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 回溯 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f&title=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e5%9b%9e%e6%ba%af">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 回溯 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 回溯 on whatsapp"
            href="https://api.whatsapp.com/send?text=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e5%9b%9e%e6%ba%af%20-%20https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 回溯 on telegram"
            href="https://telegram.me/share/url?text=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e5%9b%9e%e6%ba%af&amp;url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 回溯 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e5%9b%9e%e6%ba%af&u=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-02-03-backtracking%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://amemiya02.github.io/">个人技术博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
