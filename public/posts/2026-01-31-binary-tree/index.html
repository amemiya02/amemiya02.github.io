<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Golang] LeetCode 热题 100 - 二叉树 | 个人技术博客</title>
<meta name="keywords" content="Go, 二叉树, 题解">
<meta name="description" content="二叉树
94. 二叉树的中序遍历 - Easy
题目回顾

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

核心思路
递归或者迭代
代码实现

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    res := []int{}
    stack := []*TreeNode{}
    curr := root

    for curr != nil || len(stack) &gt; 0 {
        // 1. 一路向左，把所有左孩子入栈
        for curr != nil {
            stack = append(stack, curr)
            curr = curr.Left
        }

        // 2. 弹出栈顶（当前最左的节点）
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        // 3. 记录结果
        res = append(res, curr.Val)

        // 4. 转向右子树
        curr = curr.Right
    }

    return res
}
复杂度分析

时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。
空间复杂度：$O(H)$，其中 H 是二叉树的高度。

104. 二叉树的最大深度 - Easy
题目回顾

给定一个二叉树，找出其最大深度。">
<meta name="author" content="">
<link rel="canonical" href="https://amemiya02.github.io/posts/2026-01-31-binary-tree/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://amemiya02.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://amemiya02.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://amemiya02.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://amemiya02.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://amemiya02.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://amemiya02.github.io/posts/2026-01-31-binary-tree/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],
      inlineMath: [['\\(', '\\)'], ['$', '$']],
    },
    loader: { load: ['ui/safe'] },
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://amemiya02.github.io/posts/2026-01-31-binary-tree/">
  <meta property="og:site_name" content="个人技术博客">
  <meta property="og:title" content="[Golang] LeetCode 热题 100 - 二叉树">
  <meta property="og:description" content="二叉树 94. 二叉树的中序遍历 - Easy 题目回顾 给定一个二叉树的根节点 root ，返回它的 中序 遍历。
核心思路 递归或者迭代
代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { res := []int{} stack := []*TreeNode{} curr := root for curr != nil || len(stack) &gt; 0 { // 1. 一路向左，把所有左孩子入栈 for curr != nil { stack = append(stack, curr) curr = curr.Left } // 2. 弹出栈顶（当前最左的节点） curr = stack[len(stack)-1] stack = stack[:len(stack)-1] // 3. 记录结果 res = append(res, curr.Val) // 4. 转向右子树 curr = curr.Right } return res } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。 104. 二叉树的最大深度 - Easy 题目回顾 给定一个二叉树，找出其最大深度。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-31T09:00:00+09:00">
    <meta property="article:modified_time" content="2026-01-31T09:00:00+09:00">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="二叉树">
    <meta property="article:tag" content="题解">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Golang] LeetCode 热题 100 - 二叉树">
<meta name="twitter:description" content="二叉树
94. 二叉树的中序遍历 - Easy
题目回顾

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

核心思路
递归或者迭代
代码实现

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    res := []int{}
    stack := []*TreeNode{}
    curr := root

    for curr != nil || len(stack) &gt; 0 {
        // 1. 一路向左，把所有左孩子入栈
        for curr != nil {
            stack = append(stack, curr)
            curr = curr.Left
        }

        // 2. 弹出栈顶（当前最左的节点）
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        // 3. 记录结果
        res = append(res, curr.Val)

        // 4. 转向右子树
        curr = curr.Right
    }

    return res
}
复杂度分析

时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。
空间复杂度：$O(H)$，其中 H 是二叉树的高度。

104. 二叉树的最大深度 - Easy
题目回顾

给定一个二叉树，找出其最大深度。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://amemiya02.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Golang] LeetCode 热题 100 - 二叉树",
      "item": "https://amemiya02.github.io/posts/2026-01-31-binary-tree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Golang] LeetCode 热题 100 - 二叉树",
  "name": "[Golang] LeetCode 热题 100 - 二叉树",
  "description": "二叉树 94. 二叉树的中序遍历 - Easy 题目回顾 给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n核心思路 递归或者迭代\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { res := []int{} stack := []*TreeNode{} curr := root for curr != nil || len(stack) \u0026gt; 0 { // 1. 一路向左，把所有左孩子入栈 for curr != nil { stack = append(stack, curr) curr = curr.Left } // 2. 弹出栈顶（当前最左的节点） curr = stack[len(stack)-1] stack = stack[:len(stack)-1] // 3. 记录结果 res = append(res, curr.Val) // 4. 转向右子树 curr = curr.Right } return res } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。 104. 二叉树的最大深度 - Easy 题目回顾 给定一个二叉树，找出其最大深度。\n",
  "keywords": [
    "Go", "二叉树", "题解"
  ],
  "articleBody": "二叉树 94. 二叉树的中序遍历 - Easy 题目回顾 给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n核心思路 递归或者迭代\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { res := []int{} stack := []*TreeNode{} curr := root for curr != nil || len(stack) \u003e 0 { // 1. 一路向左，把所有左孩子入栈 for curr != nil { stack = append(stack, curr) curr = curr.Left } // 2. 弹出栈顶（当前最左的节点） curr = stack[len(stack)-1] stack = stack[:len(stack)-1] // 3. 记录结果 res = append(res, curr.Val) // 4. 转向右子树 curr = curr.Right } return res } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。 104. 二叉树的最大深度 - Easy 题目回顾 给定一个二叉树，找出其最大深度。\n核心思路 递归求解\n递归过程详解 触底：递归会一直深入到叶子节点的左右孩子（即 nil），此时返回 0。\n回溯：\n叶子节点的深度：max(0, 0) + 1 = 1。\n父节点的深度：max(左子树深度, 右子树深度) + 1。\n总结：每一层都将结果向上汇报，直到根节点。\n虽然递归（DFS）最简洁，但在面试中，面试官有时会问：“如果这棵树非常深，导致栈溢出怎么办？” 这时可以使用 BFS（广度优先搜索），通过队列按层统计。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { // 基准情况：如果节点为空，深度为 0 if root == nil { return 0 } // 递归计算左子树深度 leftHeight := maxDepth(root.Left) // 递归计算右子树深度 rightHeight := maxDepth(root.Right) // 返回左右子树中的最大值 + 1（当前层） if leftHeight \u003e rightHeight { return leftHeight + 1 } return rightHeight + 1 } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 226. 翻转二叉树 - Easy 题目回顾 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n核心思路 递归交换每个节点的左右子节点\n翻转二叉树的本质是：遍历每一个节点，并交换其左右孩子。\n为什么这个解法有效？ 递归分解：我们要翻转以 root 为根的树，其实就是先把它的左右子树分别翻转好，然后再把翻转后的左子树接到右边，翻转后的右子树接到左边。\n多重赋值：Go 的 a, b = b, a 特性在这里非常强大。它会先计算等号右边的两个递归调用（即先处理好子问题），然后再一次性赋值给左边的 root.Left 和 root.Right。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { // 基准情况：如果是空节点，直接返回 if root == nil { return nil } // 递归地翻转左右子树 // 在 Go 中，我们可以直接在一行内交换两个指针 root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) return root } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 101. 对称二叉树 - Easy 题目回顾 给你一个二叉树的根节点 root ， 检查它是否是镜像对称的。\n核心思路 判断对称并不是简单地看左右节点是否相等，而是要像“照镜子”一样进行外侧与外侧、内侧与内侧的比较。\n递归判断的三个条件： 节点状态：左节点和右节点必须同时存在或同时为空。\n数值相等：如果都存在，它们的值必须相等。\n镜像递归：\nLeft.Left 对比 Right.Right\nLeft.Right 对比 Right.Left\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSymmetric(root *TreeNode) bool { // 根节点为空是对称的 if root == nil { return true } // 检查左子树和右子树是否镜像对称 return check(root.Left, root.Right) } func check(p, q *TreeNode) bool { // 1. 如果都为空，是对称的 if p == nil \u0026\u0026 q == nil { return true } // 2. 如果只有一个为空，或者值不相等，则不对称 if p == nil || q == nil || p.Val != q.Val { return false } // 3. 递归比较： // p 的左子树 必须等于 q 的右子树 (外侧比较) // p 的右子树 必须等于 q 的左子树 (内侧比较) return check(p.Left, q.Right) \u0026\u0026 check(p.Right, q.Left) } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 543. 二叉树的直径 - Easy 题目回顾 给定一棵二叉树的根节点 root ，返回该树的 直径 。 二叉树的 直径 是指任意两个节点 之间路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。\n核心思路 我们可以通过计算每个节点的左右子树深度之和来更新最大直径。\n深度与直径的关系深度 (Depth)：从当前节点到最远叶子节点的节点数（或边数）。在上面的代码中，我们定义 nil 为 0，叶子节点深度为1。直径 (Diameter)：对于节点 u，经过它的最长路径长度等于 height(u.left) + height(u.right)。\n为什么在计算深度的同时更新？如果我们先求深度再算直径，时间复杂度会变成 $O(n^2)$。通过在递归后序遍历（Bottom-up）时顺便记录 left + right，我们只需要 一次遍历 就能得到结果。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func diameterOfBinaryTree(root *TreeNode) int { ans := 0 // 定义辅助函数计算深度 var depth func(*TreeNode) int depth = func(node *TreeNode) int { if node == nil { return 0 } // 递归计算左右子树的深度 left := depth(node.Left) right := depth(node.Right) // 更新全局最大直径：左子树深度 + 右子树深度 if left + right \u003e ans { ans = left + right } // 返回该节点的深度，供父节点使用 if left \u003e right { return left + 1 } return right + 1 } depth(root) return ans } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 102. 二叉树的层序遍历 - Medium 题目回顾 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n核心思路 队列驱动的 BFS\n层序遍历的核心在于先进先出 (FIFO)。我们使用队列来保证每一层都被顺序处理。\n为什么用 levelSize？ 在进入内层 for 循环之前，队列中正好包含了且仅包含了当前层的所有节点。通过固定 levelSize := len(queue)，我们可以确保只处理属于该层的节点，而新加入队列的孩子节点（属于下一层）则会在下一次外层循环中被处理。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { var res [][]int if root == nil { return res } // 使用切片模拟队列 queue := []*TreeNode{root} for len(queue) \u003e 0 { // 关键点：获取当前层的节点数量 levelSize := len(queue) // 用于存储当前层节点值的切片 currentLevel := make([]int, 0, levelSize) // 遍历当前层的所有节点 for i := 0; i \u003c levelSize; i++ { // 出队：取出第一个元素 node := queue[0] queue = queue[1:] // 记录当前节点的值 currentLevel = append(currentLevel, node.Val) // 将下一层的节点加入队列 if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } // 将当前层的结果加入最终结果集 res = append(res, currentLevel) } return res } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数 空间复杂度：$O(N)$，最坏情况下队列中会存储整棵树的一层节点（例如完全二叉树的最后一层）。 108. 将有序数组转换为二叉搜索树 - Easy 题目回顾 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n核心思路 为什么选择中间节点？ 平衡性：BST 的特性是 左子树 \u003c 根 \u003c 右子树。在有序数组中，中间节点的左侧刚好是所有比它小的数，右侧是所有比它大的数。\n高度控制：每次从中间切分，左右子树的节点数差值不会超过 1，这完美符合“高度平衡二叉树”的定义。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { // 直接调用递归辅助函数 return build(nums, 0, len(nums)-1) } func build(nums []int, left int, right int) *TreeNode { // 基准情况：如果左边界大于右边界，说明当前区间没有元素，返回 nil if left \u003e right { return nil } // 选择中间位置的数字作为根节点 // 使用 left + (right-left)/2 是为了防止整数溢出（虽然在数组索引中较少见） mid := left + (right-left)/2 // 创建根节点 root := \u0026TreeNode{Val: nums[mid]} // 递归构造左子树：使用中间节点左侧的区间 root.Left = build(nums, left, mid-1) // 递归构造右子树：使用中间节点右侧的区间 root.Right = build(nums, mid+1, right) return root } 简单写法\nfunc sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := len(nums) / 2 return \u0026TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), // 利用切片截取 Right: sortedArrayToBST(nums[mid+1:]), } } 复杂度分析 时间复杂度：$O(N)$，其中 N 是数组的长度。 空间复杂度：$O(\\log N)$，递归调用栈的最大深度为 $\\log N$。 98. 验证二叉搜索树 - Medium 题目回顾 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n核心思路 二叉搜索树的一个核心特性是：它的中序遍历序列一定是严格递增的。 我们只需要在遍历时记录前一个节点的值，与当前节点比较即可。\n代码实现 func isValidBST(root *TreeNode) bool { var prev *int // 使用指针记录前一个节点的值，方便处理初始化 var inorder func(*TreeNode) bool inorder = func(node *TreeNode) bool { if node == nil { return true } // 1. 遍历左子树 if !inorder(node.Left) { return false } // 2. 检查当前节点：必须大于前一个节点 if prev != nil \u0026\u0026 node.Val \u003c= *prev { return false } val := node.Val prev = \u0026val // 更新前一个节点的值 // 3. 遍历右子树 return inorder(node.Right) } return inorder(root) } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 230. 二叉搜索树中第 K 小的元素 - Medium 题目回顾 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小的元素（从 1 开始计数）。\n核心思路 为什么选择中序遍历？\nBST 的定义：左子树 \u003c 根节点 \u003c 右子树。\n中序遍历顺序：左 -\u003e 根 -\u003e 右。\n结果：按照中序遍历访问 BST 节点的顺序，正好就是数值从小到大的顺序。\n优化点：\n空间优化：原方案空间复杂度 $O(n)$ 用于存储数组，优化后为 $O(h)$（递归栈深度），其中 $h$ 是树高。\n时间优化：一旦计数器 count == k，我们就不再处理后续节点，在 $k$ 很小时效率提升显著。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func kthSmallest(root *TreeNode, k int) int { var res int count := 0 // 定义闭包递归函数 var inorder func(*TreeNode) inorder = func(node *TreeNode) { // 如果已经找到结果或节点为空，直接返回 if node == nil || count \u003e= k { return } // 1. 递归左子树 inorder(node.Left) // 2. 处理当前节点 count++ if count == k { res = node.Val return } // 3. 递归右子树 inorder(node.Right) } inorder(root) return res } 复杂度分析 时间复杂度：$O(H + k)$，其中 H 是树的高度。在最坏情况下，我们可能需要遍历到树的最深处（高度 H），然后再访问 k 个节点。 空间复杂度：$O(H)$，递归调用栈的最大深度为 H。 199. 二叉树的右视图 - Medium 题目回顾 给定一个二叉树的根节点 root ，想象自己站在它的右侧，返回从顶部到底部所能看到的节点值。\n核心思路 BFS 逻辑 想象你站在二叉树的右侧。每一层中，物理位置最靠右的那个节点会挡住同一层左边的所有节点。因此，只要我们按层遍历，并记录下每一层的最后一个元素，就能得到右视图。\n除了 BFS，其实用 深度优先搜索（DFS） 也能解，而且代码更短。思路是：按照 “根 -\u003e 右 -\u003e 左” 的顺序访问节点，并记录当前深度。如果我们第一次到达某个深度，那么当前节点一定是该深度的最右节点。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { var ans []int if root == nil { return ans } // 使用切片模拟队列 queue := []*TreeNode{root} for len(queue) \u003e 0 { // 当前层的节点个数 levelSize := len(queue) for i := 0; i \u003c levelSize; i++ { // 出队 node := queue[0] queue = queue[1:] // 如果是当前层的最后一个节点，它就是从右侧看到的节点 if i == levelSize-1 { ans = append(ans, node.Val) } // 将子节点加入队列（注意：先左后右，保证 i == levelSize-1 是最右边的） if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return ans } DFS解法\nfunc rightSideView(root *TreeNode) []int { var ans []int var dfs func(*TreeNode, int) dfs = func(node *TreeNode, depth int) { if node == nil { return } // 如果当前深度等于结果集的长度，说明该深度还没记录过节点 // 因为我们先递归右子树，所以第一个进来的肯定是该层最右边的 if depth == len(ans) { ans = append(ans, node.Val) } dfs(node.Right, depth+1) // 优先访问右子树 dfs(node.Left, depth+1) } dfs(root, 0) return ans } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(M)$，其中 M 是二叉树的最大宽度（即某一层节点的最大数量）。在最坏情况下，队列中会存储整棵树的一层节点（例如完全二叉树的最后一层）。 114. 二叉树展开为链表 - Medium 题目回顾 给你二叉树的根节点 root ，请你将它展开为一个单链表：\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个节点，而 left 子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 核心思路 寻找“前驱节点” 展开后的链表顺序其实就是二叉树的 先序遍历（根 -\u003e 左 -\u003e 右）。\n为什么这个逻辑有效？ 先序遍历的性质：在先序遍历中，root 的右子树一定紧跟在左子树的最后一个节点（左子树的最右节点）后面。\n原地转移：\n我们先找到左子树的“最右节点” pre。\n把整个 curr.Right 挪动到 pre.Right。\n这时，原来的左子树就可以安全地变成右子树，同时把左边清空。\n循环往复：通过 curr = curr.Right 不断向下推进，直到整棵树变成一个细长的“右斜杆”。\n除了上述思路外，还有递归的写法。递归的关键在于我们需要从下往上处理节点（即后序遍历的变种），这样才能确保在处理当前节点时，已经处理好了它的右子树和左子树。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func flatten(root *TreeNode) { curr := root for curr != nil { if curr.Left != nil { // 1. 找到左子树中最右边的节点（即左子树中序遍历的最后一个节点） pre := curr.Left for pre.Right != nil { pre = pre.Right } // 2. 将原先的右子树接到左子树最右节点的右边 pre.Right = curr.Right // 3. 将左子树插到右边，并将左边置空 curr.Right = curr.Left curr.Left = nil } // 4. 继续处理下一个右节点 curr = curr.Right } } 递归写法\nfunc flatten(root *TreeNode) { var prev *TreeNode var dfs func(*TreeNode) dfs = func(node *TreeNode) { if node == nil { return } // 按照 右 -\u003e 左 -\u003e 根 的顺序倒着处理 dfs(node.Right) dfs(node.Left) node.Right = prev node.Left = nil prev = node } dfs(root) } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(1)$，我们只使用了常数级别的额外空间。递归写法的空间复杂度为 $O(H)$，其中 H 是二叉树的高度。 105. 从前序与中序遍历序列构造二叉树 - Medium 题目回顾 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的前序遍历，inorder 是同一棵树的中序遍历，请你构造并返回这棵二叉树。\n核心思路 分治策略 核心步骤： 确定根节点：从 preorder 数组中按顺序取出元素作为根。\n划分区间：在 inorder 数组中找到该根节点的位置 mid。\n[inLeft, mid-1] 构成左子树的中序序列。\n[mid+1, inRight] 构成右子树的中序序列。\n递归填充：\n由于前序遍历的顺序是“根-左-右”，我们在递归时必须先调用 build(左区间)，再调用 build(右区间)。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { // 1. 使用 map 存储中序遍历的值与索引的映射，提高查找效率 indexMap := make(map[int]int) for i, v := range inorder { indexMap[v] = i } // preorderIdx 用于记录当前处理到前序遍历的第几个节点 preorderIdx := 0 // 2. 定义递归函数 var build func(inLeft, inRight int) *TreeNode build = func(inLeft, inRight int) *TreeNode { // 如果左边界大于右边界，说明该子树为空 if inLeft \u003e inRight { return nil } // 前序遍历的第一个节点就是当前的根节点 rootVal := preorder[preorderIdx] preorderIdx++ root := \u0026TreeNode{Val: rootVal} // 在中序遍历中找到根节点的索引，以此划分左右子树 mid := indexMap[rootVal] // 3. 递归构造左右子树 // 注意：必须先构造左子树，因为前序遍历中根节点后面紧跟的是左子树 root.Left = build(inLeft, mid-1) root.Right = build(mid+1, inRight) return root } return build(0, len(inorder)-1) } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(N)$，用于存储中序遍历的值与索引的映射，以及递归调用栈的空间。 437. 路径总和 III - Medium 题目回顾 给定一个二叉树的根节点 root ，和一个整数目标和 targetSum ，求该二叉树中 和为目标和 的路径数\n核心思路 前缀和在树的路径中，如果“根节点到当前节点 A”的路径和为 $S_1$， 而“根节点到其祖先节点 B”的路径和为 $S_2$，那么 B 到 A 的路径和 就是 $S_1 - S_2$。 我们要找的是 $S_1 - S_2 = targetSum$，即在当前路径的祖先节点中， 有多少个节点的前缀和等于 $S_1 - targetSum$。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, targetSum int) int { // prefixSumMap 存储从根节点开始的路径和及其出现的次数 // key: 前缀和, value: 出现次数 prefixSumMap := make(map[int64]int) // 初始化：前缀和为 0 的路径默认有 1 条（代表从根节点开始的路径） prefixSumMap[0] = 1 return dfs(root, 0, int64(targetSum), prefixSumMap) } func dfs(node *TreeNode, currSum int64, target int64, prefixSumMap map[int64]int) int { if node == nil { return 0 } // 1. 更新当前路径和 currSum += int64(node.Val) // 2. 检查是否存在满足条件的前缀和 // currSum - target = 祖先节点的前缀和 count := prefixSumMap[currSum-target] // 3. 将当前前缀和加入 map，供子节点使用 prefixSumMap[currSum]++ // 4. 递归处理左右子树 count += dfs(node.Left, currSum, target, prefixSumMap) count += dfs(node.Right, currSum, target, prefixSumMap) // 5. 回溯：在返回父节点前，移除当前节点的前缀和 // 这是为了防止“左子树”的前缀和影响到“右子树”的路径计算 prefixSumMap[currSum]-- return count } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(N)$，用于存储前缀和的哈希表，以及递归调用栈的空间。 236. 二叉树的最近公共祖先 - Medium 题目回顾 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n核心思路 三种情况的博弈我们在递归回溯的过程中，\nleft 和 right 的含义是：在该子树中找到的 $p$ 或 $q$（或者它们的公共祖先）。\n左右逢源：如果 left 和 right 同时不为空，说明 $p$ 和 $q$ 分别分布在当前节点的左右子树中，那么当前节点 root 必然是 LCA。\n一侧全包：如果一边为空，另一边不为空，说明 $p$ 和 $q$ 都在不为空的那一侧。此时我们继续向上返回那个不为空的节点。\n空手而归：如果两边都为空，说明这棵子树里既没有 $p$ 也没有 $q$，返回 nil。为什么 root == p || root == q 时直接返回？这是一个巧妙的提前阻断。如果我们在某个节点遇到了 $p$，即使 $q$ 在 $p$ 的子树下面，根据 LCA 的定义，$p$ 本身就是它们的最近公共祖先。所以我们不需要再往下找了，直接把 $p$ 向上返回即可。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { // 1. 基准情况：如果节点为空，或者找到了 p 或 q，直接返回当前节点 if root == nil || root == p || root == q { return root } // 2. 递归在左右子树中寻找 p 和 q left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) // 3. 根据左右子树的返回值进行逻辑判断： // 如果左子树没找到，说明 p 和 q 都在右子树，返回右子树的结果 if left == nil { return right } // 如果右子树没找到，说明都在左子树，返回左子树的结果 if right == nil { return left } // 如果左、右子树都各找到了一个（都不为 nil）， // 说明当前 root 就是它们分叉的地方，即最近公共祖先 return root } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 124. 二叉树中的最大路径和 - Hard 题目回顾 给你一个二叉树的根节点 root ，返回其 最大路径和 。 二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。\n核心思路 单边贡献 vs. 完整路径\n概念区分完整路径 (Current PathSum)：以当前节点为“转折点”的路径，即 leftGain + node.Val + rightGain。我们用它来更新全局的 maxSum。单边贡献 (Gain)：当前节点向上级汇报的值。由于路径不能有分叉，所以汇报给父节点时，只能选 node.Val + leftGain 或 node.Val + rightGain。\n负数处理（贪心）如果某个子树的路径和算出来是 $-5$，那么根节点加上它只会让结果变小。此时 max(0, gain) 的逻辑就会起作用，将其视为 $0$，相当于“斩断”了通往该子树的路径。\n代码实现 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ import \"math\" func maxPathSum(root *TreeNode) int { // 初始化为最小整数，防止树中全是负数 maxSum := math.MinInt32 var gain func(*TreeNode) int gain = func(node *TreeNode) int { if node == nil { return 0 } // 1. 递归计算左右子树能提供的最大贡献 // 如果贡献是负数，我们直接取 0（表示不经过该子树） leftGain := max(0, gain(node.Left)) rightGain := max(0, gain(node.Right)) // 2. 计算经过当前节点的最大路径和（左 + 根 + 右） // 并尝试更新全局最大值 currentPathSum := node.Val + leftGain + rightGain if currentPathSum \u003e maxSum { maxSum = currentPathSum } // 3. 返回该节点能提供给父节点的最大单侧路径 // 因为路径不能分支，所以只能选左或右其中一条 return node.Val + max(leftGain, rightGain) } gain(root) return maxSum } // 辅助函数：返回两个整数中的较大值 func max(a, b int) int { if a \u003e b { return a } return b } 复杂度分析 时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。 空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。 ",
  "wordCount" : "2192",
  "inLanguage": "en",
  "datePublished": "2026-01-31T09:00:00+09:00",
  "dateModified": "2026-01-31T09:00:00+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://amemiya02.github.io/posts/2026-01-31-binary-tree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "个人技术博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://amemiya02.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://amemiya02.github.io/" accesskey="h" title="个人技术博客 (Alt + H)">个人技术博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://amemiya02.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://amemiya02.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [Golang] LeetCode 热题 100 - 二叉树
    </h1>
    <div class="post-meta"><span title='2026-01-31 09:00:00 +0900 +0900'>January 31, 2026</span>&nbsp;·&nbsp;<span>11 min</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="二叉树">二叉树</a><ul>
                        
                <li>
                    <a href="#94-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86---easy" aria-label="94. 二叉树的中序遍历 - Easy">94. 二叉树的中序遍历 - Easy</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#104-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6---easy" aria-label="104. 二叉树的最大深度 - Easy">104. 二叉树的最大深度 - Easy</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-1" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-1" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-1" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#226-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91---easy" aria-label="226. 翻转二叉树 - Easy">226. 翻转二叉树 - Easy</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-2" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-2" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-2" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#101-%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91---easy" aria-label="101. 对称二叉树 - Easy">101. 对称二叉树 - Easy</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-3" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-3" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-3" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#543-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84---easy" aria-label="543. 二叉树的直径 - Easy">543. 二叉树的直径 - Easy</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-4" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-4" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-4" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-4" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#102-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86---medium" aria-label="102. 二叉树的层序遍历 - Medium">102. 二叉树的层序遍历 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-5" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-5" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-5" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-5" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#108-%e5%b0%86%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e8%bd%ac%e6%8d%a2%e4%b8%ba%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91---easy" aria-label="108. 将有序数组转换为二叉搜索树 - Easy">108. 将有序数组转换为二叉搜索树 - Easy</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-6" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-6" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-6" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-6" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#98-%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91---medium" aria-label="98. 验证二叉搜索树 - Medium">98. 验证二叉搜索树 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-7" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-7" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-7" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-7" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#230-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%ac%ac-k-%e5%b0%8f%e7%9a%84%e5%85%83%e7%b4%a0---medium" aria-label="230. 二叉搜索树中第 K 小的元素 - Medium">230. 二叉搜索树中第 K 小的元素 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-8" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-8" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-8" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-8" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#199-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%8f%b3%e8%a7%86%e5%9b%be---medium" aria-label="199. 二叉树的右视图 - Medium">199. 二叉树的右视图 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-9" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-9" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-9" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-9" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#114-%e4%ba%8c%e5%8f%89%e6%a0%91%e5%b1%95%e5%bc%80%e4%b8%ba%e9%93%be%e8%a1%a8---medium" aria-label="114. 二叉树展开为链表 - Medium">114. 二叉树展开为链表 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-10" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-10" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-10" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-10" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#105-%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91---medium" aria-label="105. 从前序与中序遍历序列构造二叉树 - Medium">105. 从前序与中序遍历序列构造二叉树 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-11" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-11" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-11" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-11" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#437-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-iii---medium" aria-label="437. 路径总和 III - Medium">437. 路径总和 III - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-12" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-12" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-12" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-12" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88---medium" aria-label="236. 二叉树的最近公共祖先 - Medium">236. 二叉树的最近公共祖先 - Medium</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-13" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-13" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-13" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-13" aria-label="复杂度分析">复杂度分析</a></li></ul>
                </li>
                <li>
                    <a href="#124-%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e7%9a%84%e6%9c%80%e5%a4%a7%e8%b7%af%e5%be%84%e5%92%8c---hard" aria-label="124. 二叉树中的最大路径和 - Hard">124. 二叉树中的最大路径和 - Hard</a><ul>
                        
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-14" aria-label="题目回顾">题目回顾</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af-14" aria-label="核心思路">核心思路</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-14" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90-14" aria-label="复杂度分析">复杂度分析</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="二叉树">二叉树<a hidden class="anchor" aria-hidden="true" href="#二叉树">#</a></h1>
<h2 id="94-二叉树的中序遍历---easy"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - Easy</a><a hidden class="anchor" aria-hidden="true" href="#94-二叉树的中序遍历---easy">#</a></h2>
<h3 id="题目回顾">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾">#</a></h3>
<blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
</blockquote>
<h3 id="核心思路">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路">#</a></h3>
<p>递归或者迭代</p>
<h3 id="代码实现">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">inorderTraversal</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stack</span> <span style="color:#f92672">:=</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">curr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">curr</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">stack</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 一路向左，把所有左孩子入栈</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">curr</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">stack</span> = append(<span style="color:#a6e22e">stack</span>, <span style="color:#a6e22e">curr</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">curr</span> = <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Left</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 弹出栈顶（当前最左的节点）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">curr</span> = <span style="color:#a6e22e">stack</span>[len(<span style="color:#a6e22e">stack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">stack</span> = <span style="color:#a6e22e">stack</span>[:len(<span style="color:#a6e22e">stack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 记录结果</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 4. 转向右子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">curr</span> = <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Right</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。</li>
</ul>
<h2 id="104-二叉树的最大深度---easy"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - Easy</a><a hidden class="anchor" aria-hidden="true" href="#104-二叉树的最大深度---easy">#</a></h2>
<h3 id="题目回顾-1">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-1">#</a></h3>
<blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
</blockquote>
<h3 id="核心思路-1">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-1">#</a></h3>
<p>递归求解</p>
<p>递归过程详解
触底：递归会一直深入到叶子节点的左右孩子（即 nil），此时返回 0。</p>
<p>回溯：</p>
<p>叶子节点的深度：max(0, 0) + 1 = 1。</p>
<p>父节点的深度：max(左子树深度, 右子树深度) + 1。</p>
<p>总结：每一层都将结果向上汇报，直到根节点。</p>
<p>虽然递归（DFS）最简洁，但在面试中，面试官有时会问：“如果这棵树非常深，导致栈溢出怎么办？” 这时可以使用 BFS（广度优先搜索），通过队列按层统计。</p>
<h3 id="代码实现-1">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 基准情况：如果节点为空，深度为 0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 递归计算左子树深度</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">leftHeight</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 递归计算右子树深度</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rightHeight</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回左右子树中的最大值 + 1（当前层）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">leftHeight</span> &gt; <span style="color:#a6e22e">rightHeight</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">leftHeight</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rightHeight</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-1">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-1">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。</li>
</ul>
<h2 id="226-翻转二叉树---easy"><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - Easy</a><a hidden class="anchor" aria-hidden="true" href="#226-翻转二叉树---easy">#</a></h2>
<h3 id="题目回顾-2">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-2">#</a></h3>
<blockquote>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
</blockquote>
<h3 id="核心思路-2">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-2">#</a></h3>
<p>递归交换每个节点的左右子节点</p>
<p>翻转二叉树的本质是：遍历每一个节点，并交换其左右孩子。</p>
<p>为什么这个解法有效？
递归分解：我们要翻转以 root 为根的树，其实就是先把它的左右子树分别翻转好，然后再把翻转后的左子树接到右边，翻转后的右子树接到左边。</p>
<p>多重赋值：Go 的 a, b = b, a 特性在这里非常强大。它会先计算等号右边的两个递归调用（即先处理好子问题），然后再一次性赋值给左边的 root.Left 和 root.Right。</p>
<h3 id="代码实现-2">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-2">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">invertTree</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 基准情况：如果是空节点，直接返回</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 递归地翻转左右子树</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在 Go 中，我们可以直接在一行内交换两个指针</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">invertTree</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>), <span style="color:#a6e22e">invertTree</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-2">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-2">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。</li>
</ul>
<h2 id="101-对称二叉树---easy"><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - Easy</a><a hidden class="anchor" aria-hidden="true" href="#101-对称二叉树---easy">#</a></h2>
<h3 id="题目回顾-3">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-3">#</a></h3>
<blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否是镜像对称的。</p>
</blockquote>
<h3 id="核心思路-3">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-3">#</a></h3>
<p>判断对称并不是简单地看左右节点是否相等，而是要像“照镜子”一样进行外侧与外侧、内侧与内侧的比较。</p>
<p>递归判断的三个条件：
节点状态：左节点和右节点必须同时存在或同时为空。</p>
<p>数值相等：如果都存在，它们的值必须相等。</p>
<p>镜像递归：</p>
<p>Left.Left 对比 Right.Right</p>
<p>Left.Right 对比 Right.Left</p>
<h3 id="代码实现-3">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-3">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isSymmetric</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 根节点为空是对称的</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查左子树和右子树是否镜像对称</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 如果都为空，是对称的</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 如果只有一个为空，或者值不相等，则不对称</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Val</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3. 递归比较：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// p 的左子树 必须等于 q 的右子树 (外侧比较)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// p 的右子树 必须等于 q 的左子树 (内侧比较)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Right</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-3">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-3">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。</li>
</ul>
<h2 id="543-二叉树的直径---easy"><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径 - Easy</a><a hidden class="anchor" aria-hidden="true" href="#543-二叉树的直径---easy">#</a></h2>
<h3 id="题目回顾-4">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-4">#</a></h3>
<blockquote>
<p>给定一棵二叉树的根节点 <code>root</code> ，返回该树的 直径 。
二叉树的 直径 是指任意两个节点
之间路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。</p>
</blockquote>
<h3 id="核心思路-4">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-4">#</a></h3>
<p>我们可以通过计算每个节点的左右子树深度之和来更新最大直径。</p>
<ol>
<li>
<p>深度与直径的关系深度 (Depth)：从当前节点到最远叶子节点的节点数（或边数）。在上面的代码中，我们定义 nil 为 0，叶子节点深度为1。直径 (Diameter)：对于节点 u，经过它的最长路径长度等于 height(u.left) + height(u.right)。</p>
</li>
<li>
<p>为什么在计算深度的同时更新？如果我们先求深度再算直径，时间复杂度会变成 $O(n^2)$。通过在递归后序遍历（Bottom-up）时顺便记录 left + right，我们只需要 一次遍历 就能得到结果。</p>
</li>
</ol>
<h3 id="代码实现-4">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-4">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">diameterOfBinaryTree</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ans</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义辅助函数计算深度</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">depth</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">depth</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 递归计算左右子树的深度</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新全局最大直径：左子树深度 + 右子树深度</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">right</span> &gt; <span style="color:#a6e22e">ans</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ans</span> = <span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">right</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回该节点的深度，供父节点使用</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> &gt; <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">depth</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ans</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-4">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-4">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。</li>
</ul>
<h2 id="102-二叉树的层序遍历---medium"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#102-二叉树的层序遍历---medium">#</a></h2>
<h3 id="题目回顾-5">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-5">#</a></h3>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<h3 id="核心思路-5">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-5">#</a></h3>
<p>队列驱动的 BFS</p>
<p>层序遍历的核心在于先进先出 (FIFO)。我们使用队列来保证每一层都被顺序处理。</p>
<p>为什么用 levelSize？
在进入内层 for 循环之前，队列中正好包含了且仅包含了当前层的所有节点。通过固定 levelSize := len(queue)，我们可以确保只处理属于该层的节点，而新加入队列的孩子节点（属于下一层）则会在下一次外层循环中被处理。</p>
<h3 id="代码实现-5">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-5">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">levelOrder</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) [][]<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> [][]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用切片模拟队列</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">root</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关键点：获取当前层的节点数量</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">levelSize</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">queue</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 用于存储当前层节点值的切片</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentLevel</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">levelSize</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历当前层的所有节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">levelSize</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 出队：取出第一个元素</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 记录当前节点的值</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">currentLevel</span> = append(<span style="color:#a6e22e">currentLevel</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将下一层的节点加入队列</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将当前层的结果加入最终结果集</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">currentLevel</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-5">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-5">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数</li>
<li>空间复杂度：$O(N)$，最坏情况下队列中会存储整棵树的一层节点（例如完全二叉树的最后一层）。</li>
</ul>
<h2 id="108-将有序数组转换为二叉搜索树---easy"><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - Easy</a><a hidden class="anchor" aria-hidden="true" href="#108-将有序数组转换为二叉搜索树---easy">#</a></h2>
<h3 id="题目回顾-6">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-6">#</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
</blockquote>
<h3 id="核心思路-6">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-6">#</a></h3>
<p>为什么选择中间节点？
平衡性：BST 的特性是 左子树 &lt; 根 &lt; 右子树。在有序数组中，中间节点的左侧刚好是所有比它小的数，右侧是所有比它大的数。</p>
<p>高度控制：每次从中间切分，左右子树的节点数差值不会超过 1，这完美符合“高度平衡二叉树”的定义。</p>
<h3 id="代码实现-6">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-6">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sortedArrayToBST</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 直接调用递归辅助函数</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">build</span>(<span style="color:#a6e22e">nums</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">nums</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">build</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">left</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">right</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 基准情况：如果左边界大于右边界，说明当前区间没有元素，返回 nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> &gt; <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 选择中间位置的数字作为根节点</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用 left + (right-left)/2 是为了防止整数溢出（虽然在数组索引中较少见）</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mid</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> (<span style="color:#a6e22e">right</span><span style="color:#f92672">-</span><span style="color:#a6e22e">left</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 创建根节点</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">mid</span>]}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 递归构造左子树：使用中间节点左侧的区间</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">build</span>(<span style="color:#a6e22e">nums</span>, <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">mid</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 递归构造右子树：使用中间节点右侧的区间</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">build</span>(<span style="color:#a6e22e">nums</span>, <span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>简单写法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sortedArrayToBST</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mid</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Val</span>:   <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">mid</span>],
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Left</span>:  <span style="color:#a6e22e">sortedArrayToBST</span>(<span style="color:#a6e22e">nums</span>[:<span style="color:#a6e22e">mid</span>]),   <span style="color:#75715e">// 利用切片截取</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Right</span>: <span style="color:#a6e22e">sortedArrayToBST</span>(<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-6">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-6">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是数组的长度。</li>
<li>空间复杂度：$O(\log N)$，递归调用栈的最大深度为 $\log N$。</li>
</ul>
<h2 id="98-验证二叉搜索树---medium"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#98-验证二叉搜索树---medium">#</a></h2>
<h3 id="题目回顾-7">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-7">#</a></h3>
<blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
</blockquote>
<h3 id="核心思路-7">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-7">#</a></h3>
<p>二叉搜索树的一个核心特性是：它的中序遍历序列一定是严格递增的。 我们只需要在遍历时记录前一个节点的值，与当前节点比较即可。</p>
<h3 id="代码实现-7">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-7">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isValidBST</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">prev</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> <span style="color:#75715e">// 使用指针记录前一个节点的值，方便处理初始化</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">inorder</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inorder</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 遍历左子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">inorder</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 检查当前节点：必须大于前一个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">prev</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">prev</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prev</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">val</span> <span style="color:#75715e">// 更新前一个节点的值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 遍历右子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">inorder</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">inorder</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-7">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-7">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。</li>
</ul>
<h2 id="230-二叉搜索树中第-k-小的元素---medium"><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#230-二叉搜索树中第-k-小的元素---medium">#</a></h2>
<h3 id="题目回顾-8">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-8">#</a></h3>
<blockquote>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 k 个最小的元素（从 1 开始计数）。</p>
</blockquote>
<h3 id="核心思路-8">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-8">#</a></h3>
<p>为什么选择中序遍历？</p>
<p>BST 的定义：左子树 &lt; 根节点 &lt; 右子树。</p>
<p>中序遍历顺序：左 -&gt; 根 -&gt; 右。</p>
<p>结果：按照中序遍历访问 BST 节点的顺序，正好就是数值从小到大的顺序。</p>
<p>优化点：</p>
<ul>
<li>
<p>空间优化：原方案空间复杂度 $O(n)$ 用于存储数组，优化后为 $O(h)$（递归栈深度），其中 $h$ 是树高。</p>
</li>
<li>
<p>时间优化：一旦计数器 count == k，我们就不再处理后续节点，在 $k$ 很小时效率提升显著。</p>
</li>
</ul>
<h3 id="代码实现-8">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-8">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">kthSmallest</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义闭包递归函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">inorder</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inorder</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果已经找到结果或节点为空，直接返回</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">count</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">k</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 递归左子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">inorder</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 处理当前节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">count</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">k</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 递归右子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">inorder</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inorder</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-8">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-8">#</a></h3>
<ul>
<li>时间复杂度：$O(H + k)$，其中 H 是树的高度。在最坏情况下，我们可能需要遍历到树的最深处（高度 H），然后再访问 k 个节点。</li>
<li>空间复杂度：$O(H)$，递归调用栈的最大深度为 H。</li>
</ul>
<h2 id="199-二叉树的右视图---medium"><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#199-二叉树的右视图---medium">#</a></h2>
<h3 id="题目回顾-9">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-9">#</a></h3>
<blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，想象自己站在它的右侧，返回从顶部到底部所能看到的节点值。</p>
</blockquote>
<h3 id="核心思路-9">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-9">#</a></h3>
<p>BFS 逻辑
想象你站在二叉树的右侧。每一层中，物理位置最靠右的那个节点会挡住同一层左边的所有节点。因此，只要我们按层遍历，并记录下每一层的最后一个元素，就能得到右视图。</p>
<p>除了 BFS，其实用 深度优先搜索（DFS） 也能解，而且代码更短。思路是：按照 “根 -&gt; 右 -&gt; 左” 的顺序访问节点，并记录当前深度。如果我们第一次到达某个深度，那么当前节点一定是该深度的最右节点。</p>
<h3 id="代码实现-9">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-9">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rightSideView</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ans</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ans</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用切片模拟队列</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">root</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 当前层的节点个数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">levelSize</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">queue</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">levelSize</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 出队</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果是当前层的最后一个节点，它就是从右侧看到的节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">levelSize</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">ans</span> = append(<span style="color:#a6e22e">ans</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将子节点加入队列（注意：先左后右，保证 i == levelSize-1 是最右边的）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ans</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>DFS解法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rightSideView</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ans</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">dfs</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dfs</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">depth</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果当前深度等于结果集的长度，说明该深度还没记录过节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 因为我们先递归右子树，所以第一个进来的肯定是该层最右边的</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">depth</span> <span style="color:#f92672">==</span> len(<span style="color:#a6e22e">ans</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ans</span> = append(<span style="color:#a6e22e">ans</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">depth</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 优先访问右子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">depth</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">root</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ans</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-9">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-9">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(M)$，其中 M 是二叉树的最大宽度（即某一层节点的最大数量）。在最坏情况下，队列中会存储整棵树的一层节点（例如完全二叉树的最后一层）。</li>
</ul>
<h2 id="114-二叉树展开为链表---medium"><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#114-二叉树展开为链表---medium">#</a></h2>
<h3 id="题目回顾-10">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-10">#</a></h3>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个节点，而 <code>left</code> 子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</li>
</ul>
</blockquote>
<h3 id="核心思路-10">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-10">#</a></h3>
<p>寻找“前驱节点”
展开后的链表顺序其实就是二叉树的 先序遍历（根 -&gt; 左 -&gt; 右）。</p>
<p>为什么这个逻辑有效？
先序遍历的性质：在先序遍历中，root 的右子树一定紧跟在左子树的最后一个节点（左子树的最右节点）后面。</p>
<p>原地转移：</p>
<p>我们先找到左子树的“最右节点” pre。</p>
<p>把整个 curr.Right 挪动到 pre.Right。</p>
<p>这时，原来的左子树就可以安全地变成右子树，同时把左边清空。</p>
<p>循环往复：通过 curr = curr.Right 不断向下推进，直到整棵树变成一个细长的“右斜杆”。</p>
<p>除了上述思路外，还有递归的写法。递归的关键在于我们需要从下往上处理节点（即后序遍历的变种），这样才能确保在处理当前节点时，已经处理好了它的右子树和左子树。</p>
<h3 id="代码实现-10">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-10">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">curr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">curr</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 1. 找到左子树中最右边的节点（即左子树中序遍历的最后一个节点）</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pre</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Left</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">pre</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">pre</span> = <span style="color:#a6e22e">pre</span>.<span style="color:#a6e22e">Right</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 2. 将原先的右子树接到左子树最右节点的右边</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pre</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Right</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 3. 将左子树插到右边，并将左边置空</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Left</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 4. 继续处理下一个右节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">curr</span> = <span style="color:#a6e22e">curr</span>.<span style="color:#a6e22e">Right</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>递归写法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">prev</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">dfs</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dfs</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 按照 右 -&gt; 左 -&gt; 根 的顺序倒着处理</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">prev</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-10">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-10">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(1)$，我们只使用了常数级别的额外空间。递归写法的空间复杂度为 $O(H)$，其中 H 是二叉树的高度。</li>
</ul>
<h2 id="105-从前序与中序遍历序列构造二叉树---medium"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#105-从前序与中序遍历序列构造二叉树---medium">#</a></h2>
<h3 id="题目回顾-11">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-11">#</a></h3>
<blockquote>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的前序遍历，<code>inorder</code> 是同一棵树的中序遍历，请你构造并返回这棵二叉树。</p>
</blockquote>
<h3 id="核心思路-11">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-11">#</a></h3>
<p>分治策略
核心步骤：
确定根节点：从 preorder 数组中按顺序取出元素作为根。</p>
<p>划分区间：在 inorder 数组中找到该根节点的位置 mid。</p>
<p>[inLeft, mid-1] 构成左子树的中序序列。</p>
<p>[mid+1, inRight] 构成右子树的中序序列。</p>
<p>递归填充：</p>
<p>由于前序遍历的顺序是“根-左-右”，我们在递归时必须先调用 build(左区间)，再调用 build(右区间)。</p>
<h3 id="代码实现-11">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-11">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">preorder</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">inorder</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 使用 map 存储中序遍历的值与索引的映射，提高查找效率</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">indexMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">inorder</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">indexMap</span>[<span style="color:#a6e22e">v</span>] = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// preorderIdx 用于记录当前处理到前序遍历的第几个节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">preorderIdx</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 定义递归函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">build</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">inLeft</span>, <span style="color:#a6e22e">inRight</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">build</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">inLeft</span>, <span style="color:#a6e22e">inRight</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果左边界大于右边界，说明该子树为空</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">inLeft</span> &gt; <span style="color:#a6e22e">inRight</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 前序遍历的第一个节点就是当前的根节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rootVal</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">preorder</span>[<span style="color:#a6e22e">preorderIdx</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">preorderIdx</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">rootVal</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在中序遍历中找到根节点的索引，以此划分左右子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mid</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">indexMap</span>[<span style="color:#a6e22e">rootVal</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 递归构造左右子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 注意：必须先构造左子树，因为前序遍历中根节点后面紧跟的是左子树</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">build</span>(<span style="color:#a6e22e">inLeft</span>, <span style="color:#a6e22e">mid</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">build</span>(<span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">inRight</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">build</span>(<span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">inorder</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-11">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-11">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(N)$，用于存储中序遍历的值与索引的映射，以及递归调用栈的空间。</li>
</ul>
<h2 id="437-路径总和-iii---medium"><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III - Medium</a><a hidden class="anchor" aria-hidden="true" href="#437-路径总和-iii---medium">#</a></h2>
<h3 id="题目回顾-12">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-12">#</a></h3>
<blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数目标和 <code>targetSum</code> ，求该二叉树中 <strong>和为目标和</strong> 的路径数</p>
</blockquote>
<h3 id="核心思路-12">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-12">#</a></h3>
<p>前缀和在树的路径中，如果“根节点到当前节点 A”的路径和为 $S_1$，
而“根节点到其祖先节点 B”的路径和为 $S_2$，那么 B 到 A 的路径和 就是 $S_1 - S_2$。
我们要找的是 $S_1 - S_2 = targetSum$，即在当前路径的祖先节点中，
有多少个节点的前缀和等于 $S_1 - targetSum$。</p>
<h3 id="代码实现-12">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-12">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pathSum</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">targetSum</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// prefixSumMap 存储从根节点开始的路径和及其出现的次数</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// key: 前缀和, value: 出现次数</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prefixSumMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int64</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 初始化：前缀和为 0 的路径默认有 1 条（代表从根节点开始的路径）</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prefixSumMap</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">root</span>, <span style="color:#ae81ff">0</span>, int64(<span style="color:#a6e22e">targetSum</span>), <span style="color:#a6e22e">prefixSumMap</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">currSum</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">prefixSumMap</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int64</span>]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 1. 更新当前路径和</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">currSum</span> <span style="color:#f92672">+=</span> int64(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 2. 检查是否存在满足条件的前缀和</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// currSum - target = 祖先节点的前缀和</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">prefixSumMap</span>[<span style="color:#a6e22e">currSum</span><span style="color:#f92672">-</span><span style="color:#a6e22e">target</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 3. 将当前前缀和加入 map，供子节点使用</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prefixSumMap</span>[<span style="color:#a6e22e">currSum</span>]<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 4. 递归处理左右子树</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">currSum</span>, <span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">prefixSumMap</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">currSum</span>, <span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">prefixSumMap</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 5. 回溯：在返回父节点前，移除当前节点的前缀和</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 这是为了防止“左子树”的前缀和影响到“右子树”的路径计算</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prefixSumMap</span>[<span style="color:#a6e22e">currSum</span>]<span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-12">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-12">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(N)$，用于存储前缀和的哈希表，以及递归调用栈的空间。</li>
</ul>
<h2 id="236-二叉树的最近公共祖先---medium"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - Medium</a><a hidden class="anchor" aria-hidden="true" href="#236-二叉树的最近公共祖先---medium">#</a></h2>
<h3 id="题目回顾-13">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-13">#</a></h3>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<h3 id="核心思路-13">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-13">#</a></h3>
<p>三种情况的博弈我们在递归回溯的过程中，</p>
<p>left 和 right 的含义是：在该子树中找到的 $p$ 或 $q$（或者它们的公共祖先）。</p>
<ul>
<li>
<p>左右逢源：如果 left 和 right 同时不为空，说明 $p$ 和 $q$ 分别分布在当前节点的左右子树中，那么当前节点 root 必然是 LCA。</p>
</li>
<li>
<p>一侧全包：如果一边为空，另一边不为空，说明 $p$ 和 $q$ 都在不为空的那一侧。此时我们继续向上返回那个不为空的节点。</p>
</li>
<li>
<p>空手而归：如果两边都为空，说明这棵子树里既没有 $p$ 也没有 $q$，返回 nil。为什么 root == p || root == q 时直接返回？这是一个巧妙的提前阻断。如果我们在某个节点遇到了 $p$，即使 $q$ 在 $p$ 的子树下面，根据 LCA 的定义，$p$ 本身就是它们的最近公共祖先。所以我们不需要再往下找了，直接把 $p$ 向上返回即可。</p>
</li>
</ul>
<h3 id="代码实现-13">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-13">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val   int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left  *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 基准情况：如果节点为空，或者找到了 p 或 q，直接返回当前节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">q</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 递归在左右子树中寻找 p 和 q</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3. 根据左右子树的返回值进行逻辑判断：</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果左子树没找到，说明 p 和 q 都在右子树，返回右子树的结果</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">right</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果右子树没找到，说明都在左子树，返回左子树的结果</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果左、右子树都各找到了一个（都不为 nil），</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 说明当前 root 就是它们分叉的地方，即最近公共祖先</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-13">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-13">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。</li>
</ul>
<h2 id="124-二叉树中的最大路径和---hard"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和 - Hard</a><a hidden class="anchor" aria-hidden="true" href="#124-二叉树中的最大路径和---hard">#</a></h2>
<h3 id="题目回顾-14">题目回顾<a hidden class="anchor" aria-hidden="true" href="#题目回顾-14">#</a></h3>
<blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 最大路径和 。
二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
</blockquote>
<h3 id="核心思路-14">核心思路<a hidden class="anchor" aria-hidden="true" href="#核心思路-14">#</a></h3>
<p>单边贡献 vs. 完整路径</p>
<ol>
<li>
<p>概念区分完整路径 (Current PathSum)：以当前节点为“转折点”的路径，即 leftGain + node.Val + rightGain。我们用它来更新全局的 maxSum。单边贡献 (Gain)：当前节点向上级汇报的值。由于路径不能有分叉，所以汇报给父节点时，只能选 node.Val + leftGain 或 node.Val + rightGain。</p>
</li>
<li>
<p>负数处理（贪心）如果某个子树的路径和算出来是 $-5$，那么根节点加上它只会让结果变小。此时 max(0, gain) 的逻辑就会起作用，将其视为 $0$，相当于“斩断”了通往该子树的路径。</p>
</li>
</ol>
<h3 id="代码实现-14">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-14">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * type TreeNode struct {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Val int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Left *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Right *TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;math&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxPathSum</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化为最小整数，防止树中全是负数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxSum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MinInt32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gain</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gain</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 递归计算左右子树能提供的最大贡献</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果贡献是负数，我们直接取 0（表示不经过该子树）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">leftGain</span> <span style="color:#f92672">:=</span> max(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">gain</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rightGain</span> <span style="color:#f92672">:=</span> max(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">gain</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 计算经过当前节点的最大路径和（左 + 根 + 右）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 并尝试更新全局最大值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentPathSum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">leftGain</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rightGain</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentPathSum</span> &gt; <span style="color:#a6e22e">maxSum</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">maxSum</span> = <span style="color:#a6e22e">currentPathSum</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 返回该节点能提供给父节点的最大单侧路径</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 因为路径不能分支，所以只能选左或右其中一条</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">+</span> max(<span style="color:#a6e22e">leftGain</span>, <span style="color:#a6e22e">rightGain</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gain</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxSum</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 辅助函数：返回两个整数中的较大值</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> max(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#a6e22e">b</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="复杂度分析-14">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析-14">#</a></h3>
<ul>
<li>时间复杂度：$O(N)$，其中 N 是二叉树的节点数。每个节点恰好被访问一次。</li>
<li>空间复杂度：$O(H)$，其中 H 是二叉树的高度。递归调用栈的最大深度为 H。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://amemiya02.github.io/tags/go/">Go</a></li>
      <li><a href="https://amemiya02.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></li>
      <li><a href="https://amemiya02.github.io/tags/%E9%A2%98%E8%A7%A3/">题解</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://amemiya02.github.io/posts/2026-02-03-graph/">
    <span class="title">« Prev</span>
    <br>
    <span>[Golang] LeetCode 热题 100 - 图论</span>
  </a>
  <a class="next" href="https://amemiya02.github.io/posts/2026-01-28-linked-list/">
    <span class="title">Next »</span>
    <br>
    <span>[Golang] LeetCode 热题 100 - 链表</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 二叉树 on x"
            href="https://x.com/intent/tweet/?text=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e4%ba%8c%e5%8f%89%e6%a0%91&amp;url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f&amp;hashtags=Go%2c%e4%ba%8c%e5%8f%89%e6%a0%91%2c%e9%a2%98%e8%a7%a3">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 二叉树 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f&amp;title=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e4%ba%8c%e5%8f%89%e6%a0%91&amp;summary=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e4%ba%8c%e5%8f%89%e6%a0%91&amp;source=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 二叉树 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f&title=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e4%ba%8c%e5%8f%89%e6%a0%91">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 二叉树 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 二叉树 on whatsapp"
            href="https://api.whatsapp.com/send?text=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e4%ba%8c%e5%8f%89%e6%a0%91%20-%20https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 二叉树 on telegram"
            href="https://telegram.me/share/url?text=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e4%ba%8c%e5%8f%89%e6%a0%91&amp;url=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [Golang] LeetCode 热题 100 - 二叉树 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%5bGolang%5d%20LeetCode%20%e7%83%ad%e9%a2%98%20100%20-%20%e4%ba%8c%e5%8f%89%e6%a0%91&u=https%3a%2f%2famemiya02.github.io%2fposts%2f2026-01-31-binary-tree%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://amemiya02.github.io/">个人技术博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
