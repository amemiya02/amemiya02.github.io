# [Golang] LeetCode 热题 100 - 哈希

# 哈希

## [1. 两数之和 - Easy](https://leetcode.cn/problems/two-sum/)

### 题目回顾

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值 `target`** 的那 **两个** 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。

**示例 1：**

**输入：** `nums = [2,7,11,15]`, `target = 9`
**输出：** `[0,1]`
**解释：** 因为 `nums[0] + nums[1] == 9` ，返回 `[0, 1]` 。

### 核心思路：用空间换时间

作为 LeetCode 的开篇之作，这道题完美地诠释了如何通过"空间换时间"的思想来优化算法。

暴力解法的瓶颈在于"寻找另一个数"的过程太慢。对于每个 `nums[i]`，我们都需要在数组中寻找是否存在一个数 `target - nums[i]`。这个寻找过程能否被加速呢？

答案是肯定的，**哈希表**提供了近乎 $O(1)$ 的查找效率。

我们可以使用一个哈希表（HashMap）来存储已经遍历过的数字及其对应的索引，即 `Map<数值, 索引>`。

具体的算法流程如下：

1. 创建一个空的哈希表 `map`。
2. 遍历 `nums` 数组，对于当前的元素 `nums[i]`：
   a.  计算我们需要寻找的"另一半"：`complement = target - nums[i]`。
   b.  **在哈希表中查找** `complement` 是否存在。
   * **如果存在**，说明我们找到了解！`complement` 的索引已经存在 `map` 中，当前元素的索引是 `i`。我们立即返回 `[map.get(complement), i]`。
   * **如果不存在**，说明到目前为止还没遇到能和 `nums[i]` 配对的数。我们将当前数字和它的索引存入哈希表 `map.put(nums[i], i)`，以便后续的元素能用它来配对。
3. 遍历结束。由于题目保证有唯一解，所以在循环中一定会找到答案。

这个"一边遍历，一边查找，一边插入"的**单遍哈希表**解法，非常巧妙地在一次循环中完成了所有工作。

### 代码实现

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i := 0; i < len(nums); i++ {
        if val, ok := m[target-nums[i]]; ok {
            return []int{val, i}
        }
        m[nums[i]] = i
    }
    return []int{-1, -1}
}
```

**复杂度分析**

* 时间复杂度: $O(n)$。我们只需遍历数组一次。哈希表的插入和查找操作的平均时间复杂度都是 $O(1)$。
* 空间复杂度: $O(n)$。在最坏情况下，我们需要将数组中的所有元素都存入哈希表中。

## [49. 字母异位词分组 - Mid](https://leetcode.cn/problems/group-anagrams/)

题目回顾

> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。
>
> **字母异位词** 是由相同字母按不同顺序排列组成的单词。

**示例 1:**

**输入:** `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`
**输出:** `[["bat"],["nat","tan"],["ate","eat","tea"]]`

### 核心思路：寻找唯一标识

除了字母完全相同，字母异位词的另一个充要条件是**每个字母出现的频率完全相同**。因此，我们也可以根据一个单词的字符频率来生成 `key`。

例如，对于 `"aab"`，其字符频率可以表示为一个长度为 26 的数组 `[2, 1, 0, 0, ...]`。为了把这个数组用作哈希表的 `key`，我们需要将它转换成一个不可变的字符串。

我们可以简单地将计数拼接起来，例如用 `"#"` 分隔：`"2#1#0#0#..."`。这样，所有异位词（如 `"aba"`, `"baa"`）都会生成这个完全相同的字符串 `key`。

你提供的答案正是采用了这种思路，通过一个辅助函数 `strToCount` 将频率数组转换成一个固定格式的字符串，同样起到了唯一标识的作用。

### 代码实现

```go

func groupAnagrams(strs []string) [][]string {
    // 直接使用 [26]int 数组作为 key，避免了复杂的字符串转换
    m := make(map[[26]int][]string)

    for _, str := range strs {
        cnt := [26]int{}
        for i := 0; i < len(str); i++ {
            cnt[str[i]-'a']++
        }
        // 直接追加，无需判断是否存在
        m[cnt] = append(m[cnt], str)
    }

    res := make([][]string, 0, len(m))
    for _, list := range m {
        res = append(res, list)
    }
    return res
}

```

**复杂度分析**
设 N 是字符串数组 strs 的长度，K 是数组中字符串的最大长度。

* 时间复杂度: $O(N \cdot K)$。我们需要遍历 N 个字符串，对于每个长度为 K 的字符串，计算其字符频率的时间是 $O(K)$。
* 空间复杂度: $O(N \cdot K)$。用于存储哈希表和结果。

## [128. 最长连续序列 - Mid](https://leetcode.cn/problems/longest-consecutive-sequence/)

### 题目回顾

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> 请你设计并实现时间复杂度为 $O(n)$ 的算法解决此问题。

**示例 1：**

**输入：** `nums = [100,4,200,1,3,2]`
**输出：** `4`
**解释：** 最长数字连续序列是 `[1, 2, 3, 4]`。它的长度为 4。

### 核心思路：哈希集合 + 智能枚举

这道题最核心的要求是 $O(n)$ 的时间复杂度，这意味着我们不能使用排序 $O(n \log n)$。

要实现 $O(n)$，关键在于**快速查找**某个数是否存在。这让我们自然而然地想到了哈希表。我们可以用一个**哈希集合 (HashSet)** 来优化查找过程。

**这题的关键是找出序列起点来剪枝**

1. **空间换时间，初始化哈希集合**

   * 创建一个 `HashSet`，并将数组 `nums` 中的所有元素都添加进去。
   * 这一步有两个目的：一是方便后续以 $O(1)$ 的时间复杂度快速查找某个数是否存在；二是自动处理了数组中的重复元素。
2. **智能遍历，只从序列的起点开始计算**

   * 这是整个算法最精妙的地方。如果我们遍历集合中的每一个数，都尝试计算以它开头的序列长度，会有大量重复计算。例如，对于序列 `[1, 2, 3, 4]`，我们从 `1` 开始计算了一遍，又会从 `2` 开始再计算一遍 `[2, 3, 4]`，这是不必要的。
   * **如何避免重复计算？** 答案是：**只从一个连续序列的起点开始计算**。
   * **如何判断一个数 `num` 是不是起点？** 很简单，只要检查 `num - 1` 是否存在于哈希集合中。如果 `num - 1` **不存在**，那么 `num` 就是一个潜在的序列起点。如果 `num - 1` **存在**，那么 `num` 肯定不是起点，我们可以直接跳过它，因为它一定会被 `num - 1` 开始的计算所覆盖。
3. **计算长度并更新结果**

   * 遍历哈希集合，对于每个元素 `num`：
     * **判断是否为起点**：`if)if _, ok := s[num-1]; !ok`
     * **如果是起点**：就从 `num` 开始，不断检查 `num + 1`, `num + 2`, ... 是否存在于集合中，以此计算出当前序列的长度。
     * **更新最大值**：将当前计算出的长度与全局的最大长度进行比较并更新。

通过这种"只从起点开始"的智能枚举，我们确保了每个数字作为序列的一部分，只会被内层循环访问一次，从而将总时间复杂度控制在 $O(n)$。

### 代码实现

```go
func longestConsecutive(nums []int) int {
    // 1. 初始化哈希表，存入数组中的每一个数值
    s := make(map[int]struct{})
    for _, num := range nums {
        s[num] = struct{}{}
    }

    ans := 0
    // 2. 遍历哈希表
    for num := range s {
        // 只有当 num-1 不存在时，才将 num 视为序列的起点
        // 如果num-1存在，说明在前面已经便利过了 直接跳过
        if _, ok := s[num-1]; !ok {
            currentNum := num
            currentLen := 1

            // 3. 检查后续数字是否存在
            for {
                if _, ok := s[currentNum+1]; ok {
                    currentLen++
                    currentNum++
                } else {
                    break
                }
            }

            // 4. 更新最大长度（比 math.Max 更高效, 因为math.Max需转换为float）
            if currentLen > ans {
                ans = currentLen
            }
        }
    }
    return ans
}

```

**复杂度分析**

* 时间复杂度: $O(n)$。

  虽然代码里有嵌套的 `for` 循环，但它依然是线性的：

  * **每个数字最多进入内层循环一次** 。
  * 只有序列的“最小元素”会触发内层循环。例如对于序列 `[1, 2, 3, 4, 5]`，只有当 `num = 1` 时才会进入 `while` 循环走 5 次；当 `num` 为 2, 3, 4, 5 时，都会因为 `num-1` 存在而被跳过。
  * **结论：** 每个元素在整个算法中最多被访问两次，时间复杂度为 **$O(n)$**。
* 空间复杂度: $O(n)$。在最坏情况下，数组中所有元素都不同，HashSet 需要存储 n 个元素。


---

> 作者: Amemiya  
> URL: https://amemiya02.github.io/posts/2026-01-24-hash/  

