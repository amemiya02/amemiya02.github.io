# [Golang] LeetCode 热题 100 - 技巧

# 技巧

## [136. 只出现一次的数字 - Easy](https://leetcode-cn.com/problems/single-number/)


### 题目回顾

> 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

### 核心思路
异或运算有三个核心性质，恰好适配这道题的场景：
1. 任何数和 0 异或，结果为自身：a ^ 0 = a；
2. 任何数和自身异或，结果为 0：a ^ a = 0；
3. 异或满足交换律和结合律：a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b。
基于这些性质，遍历数组并将所有元素依次异或：
- 成对出现的元素会相互抵消（异或结果为 0）；
- 最终剩下的结果就是唯一只出现一次的元素。

该思路的时间复杂度为 O (n)（仅一次遍历），空间复杂度为 O (1)（仅用一个变量存储结果），完全满足题目要求。

### 代码实现

```go


func singleNumber(nums []int) int {
    // 初始化结果为0，因为0异或任何数不改变其值
    result := 0
    // 遍历数组，所有元素依次异或
    for _, num := range nums {
        result ^= num
    }
    // 最终结果即为唯一出现一次的元素
    return result
}
```
### 复杂度分析
- 时间复杂度：$O (n)$，其中 n 是数组 nums 的长度。
- 空间复杂度：$O (1)$，我们只使用了一个变量 result。

## [169. 多数元素 - Easy](https://leetcode-cn.com/problems/majority-element/)

### 题目回顾

> 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。

### 核心思路

1. 摩尔投票法（最优）
- 核心思想是 **抵消**：由于多数元素出现次数超过一半，遍历数组时用 “计数” 来抵消不同元素，最终剩下的候选元素必然是多数元素：
- 初始化：candidate（候选元素）为任意值，count（计数）为 0；
- 遍历逻辑：
  - 若 count = 0，将当前元素设为 candidate；
  - 若当前元素 == candidate，count += 1；否则 count -= 1；
- 结果：遍历结束后，candidate 即为多数元素（题目保证存在，无需额外验证）。
2. 哈希表法（易理解）
- 核心思想是统计频次：遍历数组用哈希表记录每个元素的出现次数，再遍历哈希表找到次数 > n/2 的元素。

### 代码实现

```go


func majorityElement(nums []int) int {
    // 初始化候选元素和计数
    candidate := 0
    count := 0

    for _, num := range nums {
        // 计数为0时，更新候选元素为当前元素
        if count == 0 {
            candidate = num
        }
        // 相同元素计数+1，不同则-1
        if num == candidate {
            count++
        } else {
            count--
        }
    }

    // 题目保证存在多数元素，直接返回候选
    return candidate
}

```

### 复杂度分析
- 时间复杂度：$O (n)$，其中 n 是数组 nums 的长度。
- 空间复杂度：$O (1)$，我们只使用了两个变量 candidate 和 count。

## [75. 颜色分类 - Mid](https://leetcode-cn.com/problems/sort-colors/)

### 题目回顾

> 给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
>
> 必须在不使用库内置的 sort 函数的情况下解决这个问题。

### 核心思路


1. 三路快排法（最优，一次遍历）
核心思想是用三个指针划分数组区域：
- left：0 的右边界（left 左侧所有元素都是 0）；
- cur：当前遍历的指针（从左到右扫描）；
- right：2 的左边界（right 右侧所有元素都是 2）。

遍历规则：
- 若 nums[cur] == 0：交换 nums[cur] 和 nums[left]，left++、cur++（left 右移扩大 0 区域，cur 继续遍历）；
- 若 nums[cur] == 1：cur++（1 是中间值，无需交换，直接遍历下一个）；
- 若 nums[cur] == 2：交换 nums[cur] 和 nums[right]，right--（right 左移扩大 2 区域，cur 不 ++，因为交换后 cur 位置可能是 0/1，需重新检查）。
- 终止条件：cur > right（right 右侧已全是 2，无需继续遍历）。
2. 计数排序法（易理解，两次遍历）

核心思想是 “统计频次 + 原地填充”：
- 第一步：遍历数组，统计 0、1、2 的出现次数；
- 第二步：按 “先填 0、再填 1、最后填 2” 的顺序，覆盖原数组（原地操作）。

### 代码实现

```go


func sortColors(nums []int) {
    n := len(nums)
    if n <= 1 {
        return // 空数组或单元素无需排序
    }

    left := 0       // 0的右边界
    cur := 0        // 当前遍历指针
    right := n - 1  // 2的左边界

    // 遍历直到cur超过right（right右侧全是2）
    for cur <= right {
        switch nums[cur] {
        case 0:
            // 交换cur和left位置的元素，扩大0的区域
            nums[cur], nums[left] = nums[left], nums[cur]
            left++
            cur++ // 交换后cur位置是1，可继续遍历
        case 1:
            // 1在中间，无需交换，直接下一个
            cur++
        case 2:
            // 交换cur和right位置的元素，扩大2的区域
            nums[cur], nums[right] = nums[right], nums[cur]
            right-- // 交换后cur位置可能是0/1，需重新检查，cur不++
        }
    }
}
```

### 复杂度分析
- 时间复杂度：$O (n)$，其中 n 是数组 nums 的长度（仅一次遍历）。
- 空间复杂度：$O (1)$，我们只使用了常数级别的额外空间（left、cur、right 三个指针）。

## [31. 下一个排列 - Mid](https://leetcode-cn.com/problems/next-permutation/)

### 题目回顾

> 整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
>
> 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
> 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
>
> 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
> 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
> 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
> 给你一个整数数组 nums ，找出 nums 的下一个排列。
>
> 必须 原地 修改，只允许使用额外常数空间。

### 核心思路

下一个排列的本质是 “找到最小的增大”，核心逻辑分为 4 步（保证原地操作且字典序最小增大）：
1. 找 “增大起点”：从后向前遍历，找到第一个满足 nums[i] < nums[i+1] 的下标 i（此时 i 之后的元素是降序，无法再增大，i 是唯一能增大的位置）；
2. 找 “最小增大值”：若找到 i，再从后向前找第一个大于 nums[i] 的下标 j，交换 nums[i] 和 nums[j]（让 i 位置的数变大，且是 “最小的变大”，保证字典序增量最小）；
3. 反转降序段：反转 i+1 到数组末尾的元素（i 之后原本是降序，反转后变为升序，这是该位置下最小的排列）；
4. 无增大点处理：若未找到 i（数组整体降序），直接反转整个数组，得到字典序最小的升序排列。

### 代码实现

```go


func nextPermutation(nums []int) {
    n := len(nums)
    if n <= 1 {
        return
    }

    // 步骤1：从后向前找第一个 nums[i] < nums[i+1] 的下标i
    i := n - 2
    for i >= 0 && nums[i] >= nums[i+1] {
        i--
    }

    // 步骤2：若找到i，从后向前找第一个大于nums[i]的j，交换i和j
    if i >= 0 {
        j := n - 1
        for nums[j] <= nums[i] {
            j--
        }
        nums[i], nums[j] = nums[j], nums[i]
    }

    // 步骤3：反转i+1到末尾的元素（若i=-1，反转整个数组）
    reverse(nums, i+1, n-1)
}

// 辅助函数：原地反转nums中[left, right]区间的元素
func reverse(nums []int, left, right int) {
    for left < right {
        nums[left], nums[right] = nums[right], nums[left]
        left++
        right--
    }
}
```

### 复杂度分析
- 时间复杂度：$O (n)$，其中 n 是数组 nums 的长度（最多三次遍历）。
- 空间复杂度：$O (1)$，我们只使用了常数级别的额外空间（几个变量和反转函数）。

## [287. 寻找重复数 - Mid](https://leetcode-cn.com/problems/find-the-duplicate-number/)

### 题目回顾
> 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
>
> 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
>
> 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

### 核心思路

核心背景：数组→环形链表

数组长度为 n+1，元素范围是 [1,n]，可将数组视作索引→值的链表映射：
- 索引 i 的 “下一个节点” 是 nums[i]（比如 nums[0]=2，则 0 → 2；nums[2]=3，则 2 → 3）；
- 由于存在唯一重复数，这个链表必然形成环，且环的入口点就是重复的数（重复数对应多个索引指向它，是环的起点）。

快慢指针法（最优，O (n) 时间 + O (1) 空间）
- 核心逻辑（弗洛伊德龟兔赛跑算法，找环的入口）：
- 第一步（找相遇点）：慢指针（龟）每次走 1 步（slow = nums[slow]），快指针（兔）每次走 2 步（fast = nums[nums[fast]]），直到两者相遇（此时快指针走的步数是慢指针的 2 倍，且都在环内）；
- 第二步（找环入口）：重置慢指针到起点（slow=0），快慢指针均每次走 1 步，再次相遇的位置就是环的入口（即重复数）。

### 代码实现

```go


func findDuplicate(nums []int) int {
    // 第一步：快慢指针找环内相遇点
    slow, fast := 0, 0
    for {
        slow = nums[slow]       // 慢指针走1步
        fast = nums[nums[fast]] // 快指针走2步
        if slow == fast {
            break // 相遇，退出循环
        }
    }

    // 第二步：重置慢指针到起点，同速找环入口（重复数）
    slow = 0
    for slow != fast {
        slow = nums[slow]
        fast = nums[fast]
    }

    return slow // 相遇点即为重复数
}
```

### 复杂度分析
- 时间复杂度：$O (n)$，快慢指针最多遍历两次数组。
- 空间复杂度：$O (1)$，仅使用了常数级别的额外空间（几个变量）。

---

> 作者: Amemiya  
> URL: http://localhost:1313/posts/2026-02-11-trick/  

