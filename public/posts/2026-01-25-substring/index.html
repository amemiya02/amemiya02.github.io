<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>[Golang] LeetCode 热题 100 - 子串 - 个人技术博客</title><meta name="author" content="">
<meta name="description" content="子串 560. 和为 K 的子数组 - Mid 题目回顾 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
"><meta name="keywords" content='Go, 子串, 题解'>
  <meta itemprop="name" content="[Golang] LeetCode 热题 100 - 子串">
  <meta itemprop="description" content="子串 560. 和为 K 的子数组 - Mid 题目回顾 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。">
  <meta itemprop="datePublished" content="2026-01-25T10:00:00+09:00">
  <meta itemprop="dateModified" content="2026-01-25T10:00:00+09:00">
  <meta itemprop="wordCount" content="797">
  <meta itemprop="keywords" content="Go,子串,题解"><meta property="og:url" content="https://amemiya02.github.io/posts/2026-01-25-substring/">
  <meta property="og:site_name" content="个人技术博客">
  <meta property="og:title" content="[Golang] LeetCode 热题 100 - 子串">
  <meta property="og:description" content="子串 560. 和为 K 的子数组 - Mid 题目回顾 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-25T10:00:00+09:00">
    <meta property="article:modified_time" content="2026-01-25T10:00:00+09:00">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="子串">
    <meta property="article:tag" content="题解">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[Golang] LeetCode 热题 100 - 子串">
  <meta name="twitter:description" content="子串 560. 和为 K 的子数组 - Mid 题目回顾 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" type="text/html" href="https://amemiya02.github.io/posts/2026-01-25-substring/" title="[Golang] LeetCode 热题 100 - 子串 - 个人技术博客" /><link rel="prev" type="text/html" href="https://amemiya02.github.io/posts/2026-01-25-sliding-window/" title="[Golang] LeetCode 热题 100 - 滑动窗口" /><link rel="next" type="text/html" href="https://amemiya02.github.io/posts/2026-01-26-array/" title="[Golang] LeetCode 热题 100 - 普通数组" /><link rel="stylesheet" href="/css/config.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "[Golang] LeetCode 热题 100 - 子串",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/amemiya02.github.io\/posts\/2026-01-25-substring\/"
    },"genre": "posts","keywords": "Go, 子串, 题解","wordcount":  797 ,
    "url": "https:\/\/amemiya02.github.io\/posts\/2026-01-25-substring\/","datePublished": "2026-01-25T10:00:00+09:00","dateModified": "2026-01-25T10:00:00+09:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "作者"
      },"description": ""
  }
  </script><script src="/js/head/color-scheme.min.js"></script></head>
  <body data-instant-intensity="viewport" data-header-desktop="sticky" data-header-mobile="auto"><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="个人技术博客"><span class="header-title-text">个人技术博客</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a class="menu-link" href="/archives/"><i class="fa-solid fa-archive fa-sm" aria-hidden="true"></i> Archives</a></li><li class="menu-item">
              <a class="menu-link" href="/categories/"><i class="fa-solid fa-folder-tree fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item">
              <a class="menu-link" href="/tags/"><i class="fa-solid fa-tags fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" role="button" aria-label="切换主题" title="切换主题"><i class="fa-solid fa-adjust" aria-hidden="true"></i></li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="个人技术博客"><span class="header-title-text">个人技术博客</span></a><span class="header-subtitle"></span></div>
      <div class="theme-switch" role="button" aria-label="切换主题"><i class="fa-solid fa-adjust" aria-hidden="true"></i></div>
      <div class="menu-toggle" id="menu-toggle-mobile" role="button" aria-labelledby="menu-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="menu-item"><a class="menu-link" href="/archives/"><i class="fa-solid fa-archive fa-sm" aria-hidden="true"></i> Archives</a></li><li class="menu-item"><a class="menu-link" href="/categories/"><i class="fa-solid fa-folder-tree fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item"><a class="menu-link" href="/tags/"><i class="fa-solid fa-tags fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item menu-system"></li>
      </ul>
    </nav>
  </div>
</header><main class="fi-container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>[Golang] LeetCode 热题 100 - 子串</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      Anonymous</span></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category" title="分类 - 算法"><i class="fa-regular fa-folder" aria-hidden="true"></i> 算法</a>&ensp;<a href="/categories/leetcode/" class="post-category" title="分类 - LeetCode"><i class="fa-regular fa-folder" aria-hidden="true"></i> LeetCode</a></span></div><div class="post-meta-line"><span title="发布于 2026-01-25 10:00:00"><i class="fa-solid fa-calendar-days me-1" aria-hidden="true"></i><time datetime="2026-01-25">2026-01-25</time></span>&nbsp;<span title="797 字"><i class="fa-solid fa-pencil-alt me-1" aria-hidden="true"></i>约 800 字</span>&nbsp;<span><i class="fa-regular fa-clock me-1" aria-hidden="true"></i>预计阅读 4 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#560-和为-k-的子数组---mid">560. 和为 K 的子数组 - Mid</a>
      <ul>
        <li><a href="#题目回顾">题目回顾</a></li>
        <li><a href="#核心思路前缀和--哈希表优化">核心思路：前缀和 + 哈希表优化</a>
          <ul>
            <li><a href="#1-前缀和转化">1. 前缀和转化</a></li>
            <li><a href="#2-哈希表优化">2. 哈希表优化</a></li>
            <li><a href="#3-算法流程">3. 算法流程</a></li>
          </ul>
        </li>
        <li><a href="#代码实现">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#239-滑动窗口最大值---hard">239. 滑动窗口最大值 - Hard</a>
      <ul>
        <li><a href="#题目回顾-1">题目回顾</a></li>
        <li><a href="#核心思路单调队列monotonic-deque">核心思路：单调队列（Monotonic Deque）</a>
          <ul>
            <li><a href="#-单调递减队列从队首到队尾值递减存储下标">✅ 单调递减队列（从队首到队尾：值递减，存储下标）</a></li>
            <li><a href="#为什么可以弹出比当前元素小的">为什么可以弹出“比当前元素小的”？</a></li>
            <li><a href="#算法流程">算法流程</a></li>
          </ul>
        </li>
        <li><a href="#代码实现-1">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#76-最小覆盖子串---hard">76. 最小覆盖子串 - Hard</a>
      <ul>
        <li><a href="#题目回顾-2">题目回顾</a></li>
        <li><a href="#核心思路滑动窗口--哈希计数">核心思路：滑动窗口 + 哈希计数</a>
          <ul>
            <li><a href="#关键观察点">关键观察点</a></li>
            <li><a href="#实现细节">实现细节</a></li>
          </ul>
        </li>
        <li><a href="#代码实现-2">代码实现</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h1 class="heading-element" id="子串"><span>子串</span>
  <a href="#%e5%ad%90%e4%b8%b2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><h2 class="heading-element" id="560-和为-k-的子数组---mid"><span><a href="https://leetcode.cn/problems/subarray-sum-equals-k/" target="_blank" rel="external nofollow noopener noreferrer">560. 和为 K 的子数组 - Mid</a></span>
  <a href="#560-%e5%92%8c%e4%b8%ba-k-%e7%9a%84%e5%ad%90%e6%95%b0%e7%bb%84---mid" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 class="heading-element" id="题目回顾"><span>题目回顾</span>
  <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <strong>该数组中和为 <code>k</code> 的子数组的个数</strong> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> <code>nums = [1,1,1], k = 2</code>
<strong>输出：</strong> <code>2</code></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> <code>nums = [1,2,3], k = 3</code>
<strong>输出：</strong> <code>2</code></p>
<h3 class="heading-element" id="核心思路前缀和--哈希表优化"><span>核心思路：前缀和 + 哈希表优化</span>
  <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af%e5%89%8d%e7%bc%80%e5%92%8c--%e5%93%88%e5%b8%8c%e8%a1%a8%e4%bc%98%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 甚至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，无法通过所有测试用例。我们需要利用<strong>前缀和</strong>的性质进行优化。</p>
<h4 class="heading-element" id="1-前缀和转化"><span>1. 前缀和转化</span>
  <a href="#1-%e5%89%8d%e7%bc%80%e5%92%8c%e8%bd%ac%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>定义 <code>pre[i]</code> 为 <code>[0..i]</code> 里所有数的和。那么 <code>[j..i]</code> 这个子数组的和可以表示为：
</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>j</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
sum[j..i] = pre[i] - pre[j-1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">..</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span><p>
题目要求找到和为 <code>k</code> 的子数组，即寻找满足以下条件的 <code>j</code> 和 <code>i</code>：
</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">
pre[i] - pre[j-1] == k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span><p>
移项得：
</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">
pre[j-1] == pre[i] - k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span><h4 class="heading-element" id="2-哈希表优化"><span>2. 哈希表优化</span>
  <a href="#2-%e5%93%88%e5%b8%8c%e8%a1%a8%e4%bc%98%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这意味着，当我们遍历到位置 <code>i</code> 时，我们需要统计<strong>在 <code>i</code> 之前</strong>，有多少个位置 <code>j-1</code> 的前缀和等于 <code>pre[i] - k</code>。</p>
<p>为了快速查找和统计，我们可以使用一个 <strong>哈希表 (HashMap)</strong>：</p>
<ul>
<li><strong>Key</strong>: 前缀和的值。</li>
<li><strong>Value</strong>: 该前缀和出现的次数。</li>
</ul>
<h4 class="heading-element" id="3-算法流程"><span>3. 算法流程</span>
  <a href="#3-%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ol>
<li>初始化变量 <code>sum = 0</code> (当前前缀和) 和 <code>count = 0</code> (结果计数)。</li>
<li>初始化哈希表 <code>map</code>，并<strong>预先插入 <code>map.put(0, 1)</code></strong>。
<ul>
<li><strong>重点解释</strong>：这是为了处理那些从数组下标 0 开始的子数组。如果某个子数组就是 <code>nums[0..i]</code> 且和为 <code>k</code>，那么 <code>pre[i] - k</code> 将等于 <code>0</code>。我们需要保证这种情况下能找到匹配项。</li>
</ul>
</li>
<li>遍历数组 <code>nums</code>：
<ul>
<li>累加计算当前前缀和 <code>sum</code>。</li>
<li>查询 <code>map</code> 中是否存在 <code>sum - k</code>。如果存在，说明找到了对应个数的子数组，将 <code>map.get(sum - k)</code> 累加到 <code>count</code> 中。</li>
<li>将当前的 <code>sum</code> 存入 <code>map</code>，更新其出现次数。</li>
</ul>
</li>
</ol>
<h3 class="heading-element" id="代码实现"><span>代码实现</span>
  <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="code-block highlight line-nos-hidden" data-mode="classic" data-copyable="true"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">subarraySum</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// countMap: key 是前缀和, value 是该前缀和出现的次数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">countMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化：前缀和为 0 默认出现 1 次</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这是为了处理从数组第一个元素开始就满足和为 k 的情况</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">countMap</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">preSum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">preSum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">num</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果 preSum - k 在 map 中存在，说明从某个旧的前缀和到当前位置的子数组和为 k</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">countMap</span>[<span style="color:#a6e22e">preSum</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新当前前缀和出现的次数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">countMap</span>[<span style="color:#a6e22e">preSum</span>]<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。我们只需要遍历数组一次，哈希表的插入和查询操作平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
<li>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。哈希表在最坏情况下（所有前缀和都不同）需要存储 n 个键值对。</li>
</ul>
<h2 class="heading-element" id="239-滑动窗口最大值---hard"><span><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="external nofollow noopener noreferrer">239. 滑动窗口最大值 - Hard</a></span>
  <a href="#239-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%9c%80%e5%a4%a7%e5%80%bc---hard" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 class="heading-element" id="题目回顾-1"><span>题目回顾</span>
  <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
</blockquote>
<p><strong>示例：</strong></p>
<p><strong>输入：</strong> <code>nums = [1,3,-1,-3,5,3,6,7]</code>, <code>k = 3</code>
<strong>输出：</strong> <code>[3,3,5,5,6,7]</code>
<strong>解释：</strong>
滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7</p>
<hr>
<h3 class="heading-element" id="核心思路单调队列monotonic-deque"><span>核心思路：单调队列（Monotonic Deque）</span>
  <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97monotonic-deque" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>本题的难点在于：<strong>如何在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内动态维护滑动窗口的最大值？</strong></p>
<p>若对每个窗口都遍历求最大值，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span>，在 <code>k</code> 较大时会超时（<code>n = 10^5</code> 级别）。我们需要一种能“快速淘汰无用元素 + 快速获取最大值”的数据结构。</p>
<h4 class="heading-element" id="-单调递减队列从队首到队尾值递减存储下标"><span>✅ 单调递减队列（从队首到队尾：值递减，存储下标）</span>
  <a href="#-%e5%8d%95%e8%b0%83%e9%80%92%e5%87%8f%e9%98%9f%e5%88%97%e4%bb%8e%e9%98%9f%e9%a6%96%e5%88%b0%e9%98%9f%e5%b0%be%e5%80%bc%e9%80%92%e5%87%8f%e5%ad%98%e5%82%a8%e4%b8%8b%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>队首</strong>：始终是当前窗口中的<strong>最大值对应下标</strong></li>
<li><strong>队尾</strong>：用于插入新元素，并在插入前<strong>弹出所有比它小的元素</strong>（因为这些元素不可能成为后续窗口的最大值——它们更小、且更早被移出窗口）</li>
</ul>
<h4 class="heading-element" id="为什么可以弹出比当前元素小的"><span>为什么可以弹出“比当前元素小的”？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%af%e4%bb%a5%e5%bc%b9%e5%87%ba%e6%af%94%e5%bd%93%e5%89%8d%e5%85%83%e7%b4%a0%e5%b0%8f%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><blockquote>
<p>假设 <code>j &lt; i</code> 且 <code>nums[j] ≤ nums[i]</code>，那么对于<strong>所有包含 <code>i</code> 的后续窗口</strong>，<code>nums[j]</code> 都不可能成为最大值：</p>
<ul>
<li>它比 <code>nums[i]</code> 小</li>
<li>它比 <code>nums[i]</code> 更早离开窗口
→ <code>j</code> 是“无用”的，可安全丢弃。</li>
</ul>
</blockquote>
<h4 class="heading-element" id="算法流程"><span>算法流程</span>
  <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ol>
<li>初始化一个<strong>双端队列 <code>q</code></strong>（Deque），用于存储<strong>下标</strong>，维护窗口内元素对应的下标单调递减（对应值单调递减）。</li>
<li>先处理前 <code>k</code> 个元素（第一个窗口）：
<ul>
<li>入队前，从队尾弹出所有 <code>nums[q.peekLast()] &lt; nums[i]</code> 的下标；</li>
<li>将当前下标 <code>i</code> 入队尾。</li>
<li>此时队首即为第一个窗口最大值下标。</li>
</ul>
</li>
<li>从 <code>i = k</code> 开始滑动窗口：
<ul>
<li><strong>维护队列单调性</strong>：从队尾弹出所有小于 <code>nums[i]</code> 的元素；</li>
<li><strong>移除过期元素</strong>：若队首下标 <code>≤ i - k</code>（已不在窗口内），则从队首弹出；</li>
<li>将 <code>i</code> 入队尾；</li>
<li>当前窗口最大值为 <code>nums[q.peekFirst()]</code>，存入结果数组。</li>
</ul>
</li>
</ol>
<blockquote>
<p>⚠️ 注意：<strong>队列中存的是下标而非值</strong>，便于判断元素是否过期。</p>
</blockquote>
<hr>
<h3 class="heading-element" id="代码实现-1"><span>代码实现</span>
  <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="code-block highlight line-nos-hidden" data-mode="classic" data-copyable="true"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxSlidingWindow</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 边界条件处理</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 预分配结果数组，容量为 n-k+1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// q 是单调队列，仅存储数组的【下标】</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 保证队列头部 q[0] 对应的数值 nums[q[0]] 永远是当前窗口的最大值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 维护单调性（递减）：</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果队尾元素对应的值小于当前值 v，说明队尾元素不可能是最大值了，弹出</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">q</span>) &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">q</span>[len(<span style="color:#a6e22e">q</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] &lt; <span style="color:#a6e22e">v</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">q</span> = <span style="color:#a6e22e">q</span>[:len(<span style="color:#a6e22e">q</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e">// 弹出队尾</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 入队：将当前元素下标加入队尾</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">q</span> = append(<span style="color:#a6e22e">q</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 移除过期元素：</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查队首下标是否已经滑出窗口范围 (应当 &gt; i-k)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">q</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">q</span> = <span style="color:#a6e22e">q</span>[<span style="color:#ae81ff">1</span>:] <span style="color:#75715e">// 弹出队首</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 4. 记录结果：</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 当窗口完全形成（下标 i &gt;= k-1）时，队首即为当前窗口最大值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">k</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">q</span>[<span style="color:#ae81ff">0</span>]])
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>. 每个元素最多入队一次、出队一次，总操作数为 2n，均摊 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
<li>空间复杂度： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>. 队列中最多存放 k 个元素（窗口大小）。</li>
</ul>
<h2 class="heading-element" id="76-最小覆盖子串---hard"><span>76. <a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="external nofollow noopener noreferrer">最小覆盖子串 - Hard</a></span>
  <a href="#76-%e6%9c%80%e5%b0%8f%e8%a6%86%e7%9b%96%e5%ad%90%e4%b8%b2---hard" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 class="heading-element" id="题目回顾-2"><span>题目回顾</span>
  <a href="#%e9%a2%98%e7%9b%ae%e5%9b%9e%e9%a1%be-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p>给定两个字符串 <code>s</code> 和 <code>t</code>，长度分别是 <code>m</code> 和 <code>n</code>，返回 <code>s</code> 中的 <strong>最短窗口</strong> 子串，使得该子串包含 <code>t</code> 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 <code>&quot;&quot;</code>。</p>
<p>测试用例保证答案唯一。</p>
</blockquote>
<p><strong>示例：</strong></p>
<p><strong>输入：</strong> <code>s = &quot;ADOBECODEBANC&quot;</code>, <code>t = &quot;ABC&quot;</code>
<strong>输出：</strong> <code>&quot;BANC&quot;</code>
<strong>解释：</strong> 最小覆盖子串 <code>&quot;BANC&quot;</code> 包含 <code>t</code> 中所有字符 <code>'A'</code>, <code>'B'</code>, <code>'C'</code>。</p>
<hr>
<h3 class="heading-element" id="核心思路滑动窗口--哈希计数"><span>核心思路：滑动窗口 + 哈希计数</span>
  <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3--%e5%93%88%e5%b8%8c%e8%ae%a1%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>本题是「滑动窗口」的经典应用，核心目标是：在 <code>s</code> 中找到一个<strong>最短连续子串</strong>，使其<strong>字符频次 ≥ <code>t</code> 的字符频次</strong>（即完全覆盖 <code>t</code>）。</p>
<h4 class="heading-element" id="关键观察点"><span>关键观察点</span>
  <a href="#%e5%85%b3%e9%94%ae%e8%a7%82%e5%af%9f%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ol>
<li><strong>窗口有效性判定</strong>：不能只看字符是否出现，而要看<strong>频次是否足够</strong>。例如 <code>t = &quot;AAB&quot;</code>，窗口中至少要有 2 个 <code>'A'</code> 和 1 个 <code>'B'</code>。</li>
<li><strong>扩展与收缩策略</strong>：
<ul>
<li><strong>右指针 <code>r</code> 扩展窗口</strong>：直到窗口<strong>首次满足覆盖条件</strong>；</li>
<li><strong>左指针 <code>l</code> 收缩窗口</strong>：在满足条件的前提下，尽可能缩小窗口，尝试找到更优解；</li>
<li>重复上述过程，维护全局最小窗口。</li>
</ul>
</li>
</ol>
<h4 class="heading-element" id="实现细节"><span>实现细节</span>
  <a href="#%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>改用「需匹配字符种类数」+「当前达标种类数」实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 判断</p>
<hr>
<h3 class="heading-element" id="代码实现-2"><span>代码实现</span>
  <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="code-block highlight line-nos-hidden" data-mode="classic" data-copyable="true"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">minWindow</span>(s string, t string) string {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 边界检查</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(s) <span style="color:#f92672">&lt;</span> len(t) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 频次统计</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//由于是 ASCII 字符，使用数组代替 map 性能更高 (index 0-127)</span>
</span></span><span style="display:flex;"><span>    need :<span style="color:#f92672">=</span> <span style="color:#f92672">[</span>128<span style="color:#f92672">]</span><span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i :<span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> len(t); i<span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        need<span style="color:#f92672">[</span>t<span style="color:#f92672">[</span>i<span style="color:#f92672">]]++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// needCnt: 还需要匹配多少个字符才能完全覆盖 t</span>
</span></span><span style="display:flex;"><span>    needCnt :<span style="color:#f92672">=</span> len(t)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录最小覆盖子串的起始位置和长度</span>
</span></span><span style="display:flex;"><span>    start, minLen :<span style="color:#f92672">=</span> 0, len(s)<span style="color:#f92672">+</span>1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 滑动窗口：[l, r) 左闭右开区间</span>
</span></span><span style="display:flex;"><span>    l, r :<span style="color:#f92672">=</span> 0, 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> r <span style="color:#f92672">&lt;</span> len(s) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// === 1. 进窗口逻辑 ===</span>
</span></span><span style="display:flex;"><span>        ch :<span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>r<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果当前字符 ch 是 t 中需要的 (即 need[ch] &gt; 0)，</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 那么我们将 needCnt 减 1，表示&#34;还缺少的字符数&#34;少了一个</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> need<span style="color:#f92672">[</span>ch<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> 0 {
</span></span><span style="display:flex;"><span>            needCnt<span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 无论是否需要，都将该字符在 need 数组中的计数减 1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// need[ch] &gt; 0 表示还缺这个字符</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// need[ch] &lt;= 0 表示窗口内该字符已经足够，甚至多余了 (负数表示多余个数)</span>
</span></span><span style="display:flex;"><span>        need<span style="color:#f92672">[</span>ch<span style="color:#f92672">]--</span>
</span></span><span style="display:flex;"><span>        r<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// === 2. 窗口满足条件，尝试收缩左边界 ===</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// needCnt == 0 意味着 t 中所有字符都已被覆盖</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> needCnt <span style="color:#f92672">==</span> 0 {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新最小结果</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> r<span style="color:#f92672">-</span>l <span style="color:#f92672">&lt;</span> minLen {
</span></span><span style="display:flex;"><span>                minLen <span style="color:#f92672">=</span> r <span style="color:#f92672">-</span> l
</span></span><span style="display:flex;"><span>                start <span style="color:#f92672">=</span> l
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// === 3. 出窗口逻辑 ===</span>
</span></span><span style="display:flex;"><span>            removeChar :<span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>l<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 恢复 need 数组计数</span>
</span></span><span style="display:flex;"><span>            need<span style="color:#f92672">[</span>removeChar<span style="color:#f92672">]++</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 核心逻辑：判断是否破坏了覆盖条件</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果 need[removeChar] 变回 &gt; 0，说明刚才移除的那个字符是&#34;必须&#34;的，</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 且移除后窗口内数量不足了，所以 needCnt + 1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> need<span style="color:#f92672">[</span>removeChar<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> 0 {
</span></span><span style="display:flex;"><span>                needCnt<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            l<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> minLen <span style="color:#f92672">==</span> len(s)<span style="color:#f92672">+</span>1 {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s<span style="color:#f92672">[</span>start : start<span style="color:#f92672">+</span>minLen<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><strong>复杂度分析</strong></p>
<ul>
<li>
<p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>
其中 <code>m = s.length()</code>, <code>n = t.length()</code></p>
</li>
<li>
<p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
</ul>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod"><span title="更新于 2026-01-25 10:00:00">更新于 2026-01-25&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="分享到 X" data-sharer="twitter" data-url="https://amemiya02.github.io/posts/2026-01-25-substring/" data-title="[Golang] LeetCode 热题 100 - 子串" data-hashtags="Go,子串,题解"><i class="fa-brands fa-x-twitter" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://amemiya02.github.io/posts/2026-01-25-substring/" data-hashtag="Go"><i class="fa-brands fa-facebook-square" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://amemiya02.github.io/posts/2026-01-25-substring/" data-title="[Golang] LeetCode 热题 100 - 子串"><i class="fa-brands fa-weibo" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags me-1" aria-hidden="true"></i><a href="/tags/go/" class="post-tag" title="标签 - Go">Go</a><a href="/tags/%E5%AD%90%E4%B8%B2/" class="post-tag" title="标签 - 子串">子串</a><a href="/tags/%E9%A2%98%E8%A7%A3/" class="post-tag" title="标签 - 题解">题解</a></section>
    <section><span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div><div class="post-nav"><a href="/posts/2026-01-25-sliding-window/" class="post-nav-item" rel="prev" title="[Golang] LeetCode 热题 100 - 滑动窗口"><i class="fa-solid fa-angle-left" aria-hidden="true"></i>[Golang] LeetCode 热题 100 - 滑动窗口</a><a href="/posts/2026-01-26-array/" class="post-nav-item" rel="next" title="[Golang] LeetCode 热题 100 - 普通数组">[Golang] LeetCode 热题 100 - 普通数组<i class="fa-solid fa-angle-right" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside><dialog id="toc-dialog" aria-labelledby="toc-dialog-title" role="dialog">
      <div class="toc">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-drawer"><nav >
  <ul>
    <li><a href="#560-和为-k-的子数组---mid">560. 和为 K 的子数组 - Mid</a>
      <ul>
        <li><a href="#题目回顾">题目回顾</a></li>
        <li><a href="#核心思路前缀和--哈希表优化">核心思路：前缀和 + 哈希表优化</a>
          <ul>
            <li><a href="#1-前缀和转化">1. 前缀和转化</a></li>
            <li><a href="#2-哈希表优化">2. 哈希表优化</a></li>
            <li><a href="#3-算法流程">3. 算法流程</a></li>
          </ul>
        </li>
        <li><a href="#代码实现">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#239-滑动窗口最大值---hard">239. 滑动窗口最大值 - Hard</a>
      <ul>
        <li><a href="#题目回顾-1">题目回顾</a></li>
        <li><a href="#核心思路单调队列monotonic-deque">核心思路：单调队列（Monotonic Deque）</a>
          <ul>
            <li><a href="#-单调递减队列从队首到队尾值递减存储下标">✅ 单调递减队列（从队首到队尾：值递减，存储下标）</a></li>
            <li><a href="#为什么可以弹出比当前元素小的">为什么可以弹出“比当前元素小的”？</a></li>
            <li><a href="#算法流程">算法流程</a></li>
          </ul>
        </li>
        <li><a href="#代码实现-1">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#76-最小覆盖子串---hard">76. 最小覆盖子串 - Hard</a>
      <ul>
        <li><a href="#题目回顾-2">题目回顾</a></li>
        <li><a href="#核心思路滑动窗口--哈希计数">核心思路：滑动窗口 + 哈希计数</a>
          <ul>
            <li><a href="#关键观察点">关键观察点</a></li>
            <li><a href="#实现细节">实现细节</a></li>
          </ul>
        </li>
        <li><a href="#代码实现-2">代码实现</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div>
    </dialog></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.154.1"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.4.3-20260130042349-e23a50d7"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2026</span><span class="author" itemprop="copyrightHolder">
              <a href="/"></a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons"><div class="fixed-button back-to-top animate__faster d-none" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up" aria-hidden="true"></i></div><div id="toc-drawer-button" class="fixed-button toc-drawer-button d-none" role="button" aria-label="目录"><i class="fa-solid fa-bars" aria-hidden="true"></i></div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">该网站在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="/js/config/84de0d12abb0293817dd9ad83ff309be.js" defer></script><script src="/js/theme.min.js" defer></script></body>
</html>
