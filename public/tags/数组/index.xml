<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数组 on 个人技术博客</title>
    <link>https://amemiya02.github.io/tags/%E6%95%B0%E7%BB%84/</link>
    <description>Recent content in 数组 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 02 Jan 2026 23:00:00 +0900</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/tags/%E6%95%B0%E7%BB%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/矩阵】LeetCode 240. 搜索二维矩阵 II</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-240-search-a-2d-matrix-ii/</link>
      <pubDate>Fri, 02 Jan 2026 23:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-240-search-a-2d-matrix-ii/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个高效的算法来搜索 &lt;code&gt;m x n&lt;/code&gt; 矩阵 &lt;code&gt;matrix&lt;/code&gt; 中的一个目标值 &lt;code&gt;target&lt;/code&gt; 。该矩阵具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行的元素从左到右升序排列。&lt;/li&gt;
&lt;li&gt;每列的元素从上到下升序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = ... (同上), target = 20&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路抽象-bst-从角落出发&#34;&gt;核心思路：抽象 BST (从角落出发)&lt;/h2&gt;
&lt;p&gt;如果把矩阵的每一个位置看作一个节点，我们要利用&amp;quot;行有序&amp;quot;和&amp;quot;列有序&amp;quot;这两个条件来快速缩小查找范围。&lt;/p&gt;
&lt;p&gt;如果我们从&lt;strong&gt;左上角&lt;/strong&gt;出发，当前值小于 &lt;code&gt;target&lt;/code&gt; 时，我们既可以向右走（变大），也可以向下走（变大），这就产生了歧义，无法确定唯一的搜索方向。&lt;/p&gt;
&lt;p&gt;但是，如果我们选择&lt;strong&gt;左下角&lt;/strong&gt;（或者右上角）作为起点，情况就完全不同了。&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;左下角&lt;/strong&gt; &lt;code&gt;(m-1, 0)&lt;/code&gt; 为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当前值 &amp;gt; target&lt;/strong&gt;：
因为当前行是升序的，左下角已经是该行最小的数了，如果连它都比 &lt;code&gt;target&lt;/code&gt; 大，说明&lt;strong&gt;这一行所有的数都比 &lt;code&gt;target&lt;/code&gt; 大&lt;/strong&gt;。
-&amp;gt; 结论：&lt;strong&gt;排除当前行&lt;/strong&gt;，向上移动 (&lt;code&gt;i--&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当前值 &amp;lt; target&lt;/strong&gt;：
因为当前列是升序的，左下角已经是该列最大的数了（在剩下的范围内），如果连它都比 &lt;code&gt;target&lt;/code&gt; 小，说明&lt;strong&gt;这一列所有的数都比 &lt;code&gt;target&lt;/code&gt; 小&lt;/strong&gt;。
-&amp;gt; 结论：&lt;strong&gt;排除当前列&lt;/strong&gt;，向右移动 (&lt;code&gt;j++&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个过程就像是在遍历一棵&lt;strong&gt;二叉搜索树 (BST)&lt;/strong&gt;，左下角就是根节点，往上走是找更小的（类似左子树），往右走是找更大的（类似右子树）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/矩阵】LeetCode 48. 旋转图像</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-48-rotate-image/</link>
      <pubDate>Fri, 02 Jan 2026 22:15:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-48-rotate-image/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;code&gt;n × n&lt;/code&gt; 的二维矩阵 &lt;code&gt;matrix&lt;/code&gt; 表示一个图像。请你将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;你必须在 &lt;strong&gt;原地&lt;/strong&gt; 旋转图像，这意味着你需要直接修改输入的二维矩阵。&lt;strong&gt;请不要&lt;/strong&gt; 使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,2,3],[4,5,6],[7,8,9]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[7,4,1],[8,5,2],[9,6,3]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路数学变换&#34;&gt;核心思路：数学变换&lt;/h2&gt;
&lt;p&gt;这道题最直接的思路是找出每个元素旋转后的坐标规律。对于一个坐标为 &lt;code&gt;(i, j)&lt;/code&gt; 的元素，顺时针旋转 90 度后，它的新位置是 &lt;code&gt;(j, n-1-i)&lt;/code&gt;。
如果直接模拟这个过程，我们需要小心翼翼地进行四角交换，逻辑容易出错。&lt;/p&gt;
&lt;p&gt;更优雅的解法是利用矩阵运算的性质。顺时针旋转 90 度可以拆解为两步简单的变换：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;转置 (Transpose)&lt;/strong&gt;：将矩阵的行列互换（沿对角线翻转）。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;matrix[i][j]&lt;/code&gt; $\leftrightarrow$ &lt;code&gt;matrix[j][i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;水平镜像 (Reverse Rows)&lt;/strong&gt;：将每一行左右翻转。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;matrix[i][j]&lt;/code&gt; $\leftrightarrow$ &lt;code&gt;matrix[i][n-1-j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;演示过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设输入为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1 2 3
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4 5 6
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;7 8 9
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一步：转置（对角线翻转）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1 4 7
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2 5 8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3 6 9
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二步：每行左右翻转&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/矩阵】LeetCode 54. 螺旋矩阵</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-54-spiral-matrix/</link>
      <pubDate>Fri, 02 Jan 2026 21:30:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-54-spiral-matrix/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个 &lt;code&gt;m&lt;/code&gt; 行 &lt;code&gt;n&lt;/code&gt; 列的矩阵 &lt;code&gt;matrix&lt;/code&gt; ，请按照 &lt;strong&gt;顺时针螺旋顺序&lt;/strong&gt; ，返回矩阵中的所有元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,2,3],[4,5,6],[7,8,9]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[1,2,3,6,9,8,7,4,5]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[1,2,3,4,8,12,11,10,9,5,6,7]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路四边界模拟法&#34;&gt;核心思路：四边界模拟法&lt;/h2&gt;
&lt;p&gt;这道题没有太多的算法技巧，本质上是一道&lt;strong&gt;模拟题&lt;/strong&gt;。我们需要模拟一个机器人在矩阵中按照&amp;quot;右 -&amp;gt; 下 -&amp;gt; 左 -&amp;gt; 上&amp;quot;的顺序一直走，直到填满所有格子。&lt;/p&gt;
&lt;p&gt;虽然思路简单，但如果不加设计地直接写，很容易陷入各种边界判断的泥潭（比如拐角处怎么处理、什么时候停止）。&lt;/p&gt;
&lt;p&gt;最优雅的解法是&lt;strong&gt;设定四个边界&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; (top)：上边界，初始为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; (bottom)：下边界，初始为 &lt;code&gt;m-1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; (left)：左边界，初始为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; (right)：右边界，初始为 &lt;code&gt;n-1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;算法流程&#34;&gt;算法流程&lt;/h3&gt;
&lt;p&gt;我们要在一个循环中按照顺时针方向依次处理四条边。每处理完一条边，就将对应的边界向内收缩，并立即检查是否越界（越界意味着遍历结束）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;向右移动&lt;/strong&gt;：遍历从 &lt;code&gt;l&lt;/code&gt; 到 &lt;code&gt;r&lt;/code&gt;。处理完后，上边界下移 (&lt;code&gt;++t&lt;/code&gt;)。如果 &lt;code&gt;t &amp;gt; b&lt;/code&gt;，说明上下边界交错，遍历结束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向下移动&lt;/strong&gt;：遍历从 &lt;code&gt;t&lt;/code&gt; 到 &lt;code&gt;b&lt;/code&gt;。处理完后，右边界左移 (&lt;code&gt;--r&lt;/code&gt;)。如果 &lt;code&gt;l &amp;gt; r&lt;/code&gt;，说明左右边界交错，遍历结束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向左移动&lt;/strong&gt;：遍历从 &lt;code&gt;r&lt;/code&gt; 到 &lt;code&gt;l&lt;/code&gt;。处理完后，下边界上移 (&lt;code&gt;--b&lt;/code&gt;)。如果 &lt;code&gt;t &amp;gt; b&lt;/code&gt;，遍历结束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向上移动&lt;/strong&gt;：遍历从 &lt;code&gt;b&lt;/code&gt; 到 &lt;code&gt;t&lt;/code&gt;。处理完后，左边界右移 (&lt;code&gt;++l&lt;/code&gt;)。如果 &lt;code&gt;l &amp;gt; r&lt;/code&gt;，遍历结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种写法将边界检查巧妙地融合在每一步操作之后，不需要在循环头部写复杂的 &lt;code&gt;count &amp;lt; total&lt;/code&gt; 判断，代码逻辑非常清晰。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/矩阵】LeetCode 73. 矩阵置零</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-73-set-matrix-zeroes/</link>
      <pubDate>Fri, 02 Jan 2026 20:45:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-73-set-matrix-zeroes/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵，如果一个元素为 &lt;code&gt;0&lt;/code&gt; ，则将其所在行和列的所有元素都设为 &lt;code&gt;0&lt;/code&gt; 。请使用 &lt;strong&gt;原地&lt;/strong&gt; 算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,1,1],[1,0,1],[1,1,1]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[1,0,1],[0,0,0],[1,0,1]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[0,0,0,0],[0,4,5,0],[0,3,1,0]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个直观的解决方案是使用 $O(mn)$ 的额外空间，但这并不是一个好的解决方案。&lt;/li&gt;
&lt;li&gt;一个简单的改进方案是使用 $O(m + n)$ 的额外空间，但这仍然不是最好的解决方案。&lt;/li&gt;
&lt;li&gt;你能想出一个仅使用常量空间的解决方案吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;核心思路利用首行首列做标记&#34;&gt;核心思路：利用首行首列做标记&lt;/h2&gt;
&lt;p&gt;这道题的难点在于**&amp;ldquo;污染&amp;rdquo;**问题：如果我们一边遍历一边将 0 所在的行列置零，那么修改后的 0 会干扰后续的遍历，导致整个矩阵最后全变成了 0。&lt;/p&gt;
&lt;h3 id=&#34;空间复杂度优化路径&#34;&gt;空间复杂度优化路径&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;$O(MN)$ 空间&lt;/strong&gt;：新建一个同样的矩阵做标记。太浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$O(M+N)$ 空间&lt;/strong&gt;：使用两个布尔数组 &lt;code&gt;row[]&lt;/code&gt; 和 &lt;code&gt;col[]&lt;/code&gt;，分别记录哪一行、哪一列需要置零。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$O(1)$ 空间&lt;/strong&gt;：直接利用矩阵的第一行和第一列来替代上面的两个布尔数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;算法流程-o1-方案&#34;&gt;算法流程 ($O(1)$ 方案)&lt;/h3&gt;
&lt;p&gt;既然我们要用第一行和第一列来记录&amp;quot;该行/列是否需要置零&amp;quot;，那么第一行和第一列原本的状态（是否包含 0）就需要先被保存下来，否则会被后续的标记覆盖。&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;记录首行首列状态&lt;/strong&gt;：
定义两个变量 &lt;code&gt;firstRowHasZero&lt;/code&gt; 和 &lt;code&gt;firstColHasZero&lt;/code&gt;，遍历第一行和第一列，如果发现 0，则将对应的变量置为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;利用首行首列做标记&lt;/strong&gt;：
遍历矩阵的&lt;strong&gt;其余部分&lt;/strong&gt;（从 &lt;code&gt;(1,1)&lt;/code&gt; 开始）。如果发现 &lt;code&gt;matrix[i][j] == 0&lt;/code&gt;，就将它对应的行首 &lt;code&gt;matrix[i][0]&lt;/code&gt; 和列首 &lt;code&gt;matrix[0][j]&lt;/code&gt; 设为 0。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/数组】LeetCode 41. 缺失的第一个正数</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-41-first-missing-positive/</link>
      <pubDate>Fri, 02 Jan 2026 19:30:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-41-first-missing-positive/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;p&gt;请你实现时间复杂度为 $O(n)$ 并且只使用常数级别额外空间的解决方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,2,0]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 范围 [1,2] 中的数字都在数组中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [3,4,-1,1]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 1 在数组中，但 2 没有。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [7,8,9,11,12]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 最小的正数 1 没有出现。&lt;/p&gt;
&lt;h2 id=&#34;核心思路原地哈希萝卜坑&#34;&gt;核心思路：原地哈希（萝卜坑）&lt;/h2&gt;
&lt;p&gt;这道题的难点在于限制条件：&lt;strong&gt;时间 $O(N)$&lt;/strong&gt; 且 &lt;strong&gt;空间 $O(1)$&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果允许 $O(N \log N)$ 时间，我们可以直接排序。&lt;/li&gt;
&lt;li&gt;如果允许 $O(N)$ 空间，我们可以用 HashSet 记录出现过的数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了满足双重限制，我们需要利用数组本身作为哈希表。&lt;/p&gt;
&lt;h3 id=&#34;关键推论&#34;&gt;关键推论&lt;/h3&gt;
&lt;p&gt;对于一个长度为 &lt;code&gt;N&lt;/code&gt; 的数组，缺失的第一个正数一定在 &lt;code&gt;[1, N + 1]&lt;/code&gt; 这个范围内。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/数组】LeetCode 238. 除了自身以外数组的乘积</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-238-product-of-array-except-self/</link>
      <pubDate>Fri, 02 Jan 2026 18:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-238-product-of-array-except-self/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，返回 数组 &lt;code&gt;answer&lt;/code&gt; ，其中 &lt;code&gt;answer[i]&lt;/code&gt; 等于 &lt;code&gt;nums&lt;/code&gt; 中除了 &lt;code&gt;nums[i]&lt;/code&gt; 之外其余各元素的乘积。&lt;/p&gt;
&lt;p&gt;题目数据 &lt;strong&gt;保证&lt;/strong&gt; 数组 &lt;code&gt;nums&lt;/code&gt; 之中任意元素的全部前缀元素和后缀的乘积都在 &lt;strong&gt;32 位&lt;/strong&gt; 整数范围内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请不要使用除法，且在 $O(n)$ 时间复杂度内完成此题。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;nums = [1,2,3,4]&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;[24,12,8,6]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;nums = [-1,1,0,-3,3]&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;[0,0,9,0,0]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路左右乘积列表&#34;&gt;核心思路：左右乘积列表&lt;/h2&gt;
&lt;p&gt;这道题如果允许使用除法，那非常简单：算出所有元素的总乘积，然后除以当前元素即可（注意需要处理 0 的情况）。但题目明确禁止除法，我们需要另辟蹊径。&lt;/p&gt;
&lt;p&gt;对于数组中的任意一个元素 &lt;code&gt;nums[i]&lt;/code&gt;，除了它自身以外的乘积，实际上等于：
&lt;strong&gt;（它左边所有元素的乘积） $\times$ （它右边所有元素的乘积）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，我们可以通过两次遍历来解决这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;计算后缀积&lt;/strong&gt;：先算出每个位置&lt;strong&gt;右边&lt;/strong&gt;所有元素的乘积。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算前缀积并合并&lt;/strong&gt;：再算出每个位置&lt;strong&gt;左边&lt;/strong&gt;所有元素的乘积，并乘上刚才算好的后缀积。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;空间优化-o1-额外空间&#34;&gt;空间优化 ($O(1)$ 额外空间)&lt;/h3&gt;
&lt;p&gt;为了满足进阶要求的 $O(1)$ 额外空间（输出数组不计入空间复杂度），我们可以直接利用返回的数组 &lt;code&gt;answer&lt;/code&gt;（代码中为 &lt;code&gt;suf&lt;/code&gt;）来作为中间容器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第一轮遍历（从右向左）&lt;/strong&gt;：
我们在 &lt;code&gt;suf&lt;/code&gt; 数组中存储&lt;strong&gt;后缀积&lt;/strong&gt;。
&lt;code&gt;suf[i]&lt;/code&gt; 表示 &lt;code&gt;i&lt;/code&gt; 之后所有元素的乘积。
初始化 &lt;code&gt;suf[n-1] = 1&lt;/code&gt;（因为最后一个元素右边没有元素）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/数组】LeetCode 189. 轮转数组</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-189-rotate-array/</link>
      <pubDate>Fri, 02 Jan 2026 17:05:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-189-rotate-array/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，将数组中的元素向右轮转 &lt;code&gt;k&lt;/code&gt; 个位置，其中 &lt;code&gt;k&lt;/code&gt; 是非负数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;nums = [1,2,3,4,5,6,7], k = 3&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;[5,6,7,1,2,3,4]&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt;
向右轮转 1 步: &lt;code&gt;[7,1,2,3,4,5,6]&lt;/code&gt;
向右轮转 2 步: &lt;code&gt;[6,7,1,2,3,4,5]&lt;/code&gt;
向右轮转 3 步: &lt;code&gt;[5,6,7,1,2,3,4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [-1,-100,3,99], k = 2&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[3,99,-1,-100]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路三次翻转法&#34;&gt;核心思路：三次翻转法&lt;/h2&gt;
&lt;p&gt;这道题最直观的解法是使用一个额外的数组，将每个元素放到正确的位置，但这需要 $O(N)$ 的空间。
如果要求原地算法（$O(1)$ 空间），最经典且容易理解的方法是&lt;strong&gt;数组翻转法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以观察一下规律，以 &lt;code&gt;nums = [1,2,3,4,5,6,7], k = 3&lt;/code&gt; 为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原始数组&lt;/strong&gt;：&lt;code&gt;[1, 2, 3, 4, 5, 6, 7]&lt;/code&gt;
我们可以把数组分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分（前 &lt;code&gt;n-k&lt;/code&gt; 个）：&lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二部分（后 &lt;code&gt;k&lt;/code&gt; 个）：&lt;code&gt;[5, 6, 7]&lt;/code&gt; (这部分实际上是要移动到数组头部的)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第一步：整体翻转&lt;/strong&gt;
将整个数组翻转：
&lt;code&gt;[7, 6, 5, 4, 3, 2, 1]&lt;/code&gt;
此时，原本在尾部的 &lt;code&gt;[5, 6, 7]&lt;/code&gt; 跑到了头部，但是顺序是反的（&lt;code&gt;7, 6, 5&lt;/code&gt;）。原本在头部的 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 跑到了尾部，顺序也是反的（&lt;code&gt;4, 3, 2, 1&lt;/code&gt;）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/排序】LeetCode 56. 合并区间</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-56-merge-intervals/</link>
      <pubDate>Fri, 02 Jan 2026 16:20:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-56-merge-intervals/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以数组 &lt;code&gt;intervals&lt;/code&gt; 表示若干个区间的集合，其中单个区间为 &lt;code&gt;intervals[i] = [start_i, end_i]&lt;/code&gt; 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;intervals = [[1,3],[2,6],[8,10],[15,18]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[1,6],[8,10],[15,18]]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 区间 &lt;code&gt;[1,3]&lt;/code&gt; 和 &lt;code&gt;[2,6]&lt;/code&gt; 重叠, 将它们合并为 &lt;code&gt;[1,6]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;intervals = [[1,4],[4,5]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[1,5]]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 区间 &lt;code&gt;[1,4]&lt;/code&gt; 和 &lt;code&gt;[4,5]&lt;/code&gt; 可被视为重叠区间。&lt;/p&gt;
&lt;h2 id=&#34;核心思路排序--贪心&#34;&gt;核心思路：排序 + 贪心&lt;/h2&gt;
&lt;p&gt;区间问题最常见的痛点在于：输入的区间可能是乱序的。如果乱序处理，我们需要两两比较，复杂度会飙升到 $O(N^2)$。&lt;/p&gt;
&lt;p&gt;解决此类问题的&amp;quot;银弹&amp;quot;通常是&lt;strong&gt;先排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 预处理：排序&lt;/strong&gt;
我们首先按照区间的**左端点（Start Time）**进行从小到大的排序。
排序后，重叠的区间在数组中一定是相邻的。这使得我们只需要进行一次线性扫描就能完成合并。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 遍历与合并&lt;/strong&gt;
我们维护一个结果集 &lt;code&gt;res&lt;/code&gt;，并遍历排序后的区间列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始状态&lt;/strong&gt;：如果 &lt;code&gt;res&lt;/code&gt; 为空，直接将当前区间加入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无重叠&lt;/strong&gt;：如果当前区间的&lt;strong&gt;左端点&lt;/strong&gt;大于结果集中最后一个区间的&lt;strong&gt;右端点&lt;/strong&gt;，说明它们断开了，没有交集。直接将当前区间加入 &lt;code&gt;res&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有重叠&lt;/strong&gt;：如果当前区间的&lt;strong&gt;左端点&lt;/strong&gt;小于等于结果集中最后一个区间的&lt;strong&gt;右端点&lt;/strong&gt;，说明发生了重叠（或者通过端点相连）。
&lt;ul&gt;
&lt;li&gt;此时我们需要&lt;strong&gt;合并&lt;/strong&gt;：更新结果集中最后一个区间的右端点。&lt;/li&gt;
&lt;li&gt;新的右端点应该是两者右端点的最大值：&lt;code&gt;max(last_interval.end, current_interval.end)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码实现-java&#34;&gt;代码实现 (Java)&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[][]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[][]&lt;/span&gt; intervals) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界检查&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (intervals.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 核心步骤 1：按照区间左端点进行排序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 这一步将 O(N^2) 的两两比较降低为 O(N) 的线性扫描&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(intervals, (i1, i2) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; i1&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i2&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&amp;gt;&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; intervals.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; intervals&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; intervals&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 核心步骤 2：判断是否重叠&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果结果集为空，或者当前区间的左端点 &amp;gt; 结果集最后一个区间的右端点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 说明无重叠，直接添加&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (res.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; res.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1)&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; l) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                res.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;{l, r});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 发生重叠，合并区间&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 更新结果集最后一个区间的右端点，取两者最大值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                res.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1)&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1)&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;, r);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 转换回题目要求的 int[][] 格式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res.&lt;span style=&#34;color:#a6e22e&#34;&gt;toArray&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度: $O(N \log N)$。虽然遍历是一次线性的 $O(N)$，但排序的开销是 $O(N \log N)$，它是整个算法的瓶颈。&lt;/li&gt;
&lt;li&gt;空间复杂度: $O(\log N)$。这里指的是 Java 排序算法（通常是快排或归并排序的变种）所需的栈空间。如果算上存储结果的 res 列表，则是 $O(N)$。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>【HOT100/动态规划】LeetCode 53. 最大子数组和</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-53-maximum-subarray/</link>
      <pubDate>Fri, 02 Jan 2026 15:10:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-53-maximum-subarray/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;6&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 连续子数组 &lt;code&gt;[4,-1,2,1]&lt;/code&gt; 的和最大，为 &lt;code&gt;6&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [5,4,-1,7,8]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;23&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路动态规划与贪心&#34;&gt;核心思路：动态规划与贪心&lt;/h2&gt;
&lt;p&gt;这道题是**动态规划（Dynamic Programming）**的经典入门题。&lt;/p&gt;
&lt;p&gt;如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 $O(N^2)$，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。&lt;/p&gt;
&lt;h3 id=&#34;状态定义&#34;&gt;状态定义&lt;/h3&gt;
&lt;p&gt;我们要思考：&lt;strong&gt;以当前数字 &lt;code&gt;nums[i]&lt;/code&gt; 结尾的子数组，它的最大和是多少？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;dp[i]&lt;/code&gt; 表示以 &lt;code&gt;nums[i]&lt;/code&gt; &lt;strong&gt;结尾&lt;/strong&gt;的连续子数组的最大和。那么对于 &lt;code&gt;nums[i]&lt;/code&gt; 来说，它面临两个选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;加入前面的队伍&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是正数，那么加上它肯定比自己单干强，即 &lt;code&gt;dp[i-1] + nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;另起炉灶&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 &lt;code&gt;nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;状态转移方程&#34;&gt;状态转移方程&lt;/h3&gt;
&lt;p&gt;根据上述分析，我们可以得到状态转移方程：
$$
dp[i] = \max(dp[i-1] + \text{nums}[i], \text{nums}[i])
$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/单调队列】LeetCode 239. 滑动窗口最大值</title>
      <link>https://amemiya02.github.io/posts/2025-12-18-239-sliding-window-maximum/</link>
      <pubDate>Thu, 18 Dec 2025 15:30:00 +0800</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-12-18-239-sliding-window-maximum/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，有一个大小为 &lt;code&gt;k&lt;/code&gt; 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的 &lt;code&gt;k&lt;/code&gt; 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,3,-1,-3,5,3,6,7]&lt;/code&gt;, &lt;code&gt;k = 3&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[3,3,5,5,6,7]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;
滑动窗口的位置                最大值&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1  3  -1] -3  5  3  6  7       3&lt;br&gt;
1 [3  -1  -3] 5  3  6  7       3&lt;br&gt;
1  3 [-1  -3  5] 3  6  7       5&lt;br&gt;
1  3  -1 [-3  5  3] 6  7       5&lt;br&gt;
1  3  -1  -3 [5  3  6] 7       6&lt;br&gt;
1  3  -1  -3  5 [3  6  7]      7&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/前缀和】LeetCode 560. 和为 K 的子数组</title>
      <link>https://amemiya02.github.io/posts/2025-12-17-560-subarray-sum-equals-k/</link>
      <pubDate>Wed, 17 Dec 2025 21:55:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-12-17-560-subarray-sum-equals-k/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你统计并返回 &lt;strong&gt;该数组中和为 &lt;code&gt;k&lt;/code&gt; 的子数组的个数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;子数组是数组中元素的连续非空序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,1,1], k = 2&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,2,3], k = 3&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路前缀和--哈希表优化&#34;&gt;核心思路：前缀和 + 哈希表优化&lt;/h2&gt;
&lt;p&gt;这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 $O(n^2)$ 甚至 $O(n^3)$，无法通过所有测试用例。我们需要利用&lt;strong&gt;前缀和&lt;/strong&gt;的性质进行优化。&lt;/p&gt;
&lt;h3 id=&#34;1-前缀和转化&#34;&gt;1. 前缀和转化&lt;/h3&gt;
&lt;p&gt;定义 &lt;code&gt;pre[i]&lt;/code&gt; 为 &lt;code&gt;[0..i]&lt;/code&gt; 里所有数的和。那么 &lt;code&gt;[j..i]&lt;/code&gt; 这个子数组的和可以表示为：
$$
sum[j..i] = pre[i] - pre[j-1]
$$
题目要求找到和为 &lt;code&gt;k&lt;/code&gt; 的子数组，即寻找满足以下条件的 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt;：
$$
pre[i] - pre[j-1] == k
$$
移项得：
$$
pre[j-1] == pre[i] - k
$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/滑动窗口/Middle】LeetCode 438. 找到字符串中所有字母异位词</title>
      <link>https://amemiya02.github.io/posts/2025-09-23-438-find-all-anagrams-in-a-string/</link>
      <pubDate>Tue, 23 Sep 2025 09:52:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-23-438-find-all-anagrams-in-a-string/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中所有 &lt;code&gt;p&lt;/code&gt; 的 &lt;strong&gt;字母异位词&lt;/strong&gt; 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 指由相同字母按不同顺序排列组成的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;cbaebabacd&amp;quot;&lt;/code&gt;, &lt;code&gt;p = &amp;quot;abc&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;[0,6]&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt;
起始索引等于 0 的子串是 &lt;code&gt;&amp;quot;cba&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。
起始索引等于 6 的子串是 &lt;code&gt;&amp;quot;bac&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。&lt;/p&gt;
&lt;h2 id=&#34;核心思路定长滑动窗口--字符频率统计&#34;&gt;核心思路：定长滑动窗口 + 字符频率统计&lt;/h2&gt;
&lt;p&gt;这道题要求我们在一个长字符串 &lt;code&gt;s&lt;/code&gt; 中，找出所有与短字符串 &lt;code&gt;p&lt;/code&gt; 构成字母异位词的&lt;strong&gt;子串&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;字母异位词&amp;quot;的判断标准是：两个字符串长度相等，且包含的字符种类和数量完全相同。这提示我们，核心在于&lt;strong&gt;字符频率的比较&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;找出所有&amp;hellip;的子串&amp;quot;则强烈地暗示了&lt;strong&gt;滑动窗口&lt;/strong&gt;算法。由于 &lt;code&gt;p&lt;/code&gt; 的长度是固定的，我们可以使用一个&lt;strong&gt;大小固定&lt;/strong&gt;的滑动窗口来遍历 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;结合以上两点，我们的解题策略就清晰了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计 &lt;code&gt;p&lt;/code&gt; 的频率&lt;/strong&gt;：首先，我们需要一个&amp;quot;标准答案&amp;rdquo;，也就是字符串 &lt;code&gt;p&lt;/code&gt; 的字符频率分布。因为题目只包含小写字母，我们可以用一个长度为 26 的数组 &lt;code&gt;countP&lt;/code&gt; 来存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建固定大小的窗口&lt;/strong&gt;：我们在 &lt;code&gt;s&lt;/code&gt; 上维护一个长度与 &lt;code&gt;p&lt;/code&gt; 相同的滑动窗口。我们同样用一个长度为 26 的数组 &lt;code&gt;countS&lt;/code&gt; 来实时统计这个窗口内的字符频率。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希集合/Middle】LeetCode 128. 最长连续序列</title>
      <link>https://amemiya02.github.io/posts/2025-09-21-128-longest-consecutive-sequence/</link>
      <pubDate>Sun, 21 Sep 2025 11:03:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-21-128-longest-consecutive-sequence/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p&gt;
&lt;p&gt;请你设计并实现时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 的算法解决此问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [100,4,200,1,3,2]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;4&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 最长数字连续序列是 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;。它的长度为 4。&lt;/p&gt;
&lt;h2 id=&#34;核心思路哈希集合--智能枚举&#34;&gt;核心思路：哈希集合 + 智能枚举&lt;/h2&gt;
&lt;p&gt;这道题最核心的要求是 &lt;code&gt;O(n)&lt;/code&gt; 的时间复杂度，这意味着我们不能使用排序 $O(nlogn)$。&lt;/p&gt;
&lt;p&gt;要实现 &lt;code&gt;O(n)&lt;/code&gt;，关键在于&lt;strong&gt;快速查找&lt;/strong&gt;某个数是否存在。这让我们自然而然地想到了哈希表。我们可以用一个&lt;strong&gt;哈希集合 (HashSet)&lt;/strong&gt; 来优化查找过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这题的关键是找出序列起点来剪枝&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空间换时间，初始化哈希集合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个 &lt;code&gt;HashSet&lt;/code&gt;，并将数组 &lt;code&gt;nums&lt;/code&gt; 中的所有元素都添加进去。&lt;/li&gt;
&lt;li&gt;这一步有两个目的：一是方便后续以 $O(1)$ 的时间复杂度快速查找某个数是否存在；二是自动处理了数组中的重复元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;智能遍历，只从序列的起点开始计算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是整个算法最精妙的地方。如果我们遍历集合中的每一个数，都尝试计算以它开头的序列长度，会有大量重复计算。例如，对于序列 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;，我们从 &lt;code&gt;1&lt;/code&gt; 开始计算了一遍，又会从 &lt;code&gt;2&lt;/code&gt; 开始再计算一遍 &lt;code&gt;[2, 3, 4]&lt;/code&gt;，这是不必要的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何避免重复计算？&lt;/strong&gt; 答案是：&lt;strong&gt;只从一个连续序列的起点开始计算&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何判断一个数 &lt;code&gt;num&lt;/code&gt; 是不是起点？&lt;/strong&gt; 很简单，只要检查 &lt;code&gt;num - 1&lt;/code&gt; 是否存在于哈希集合中。如果 &lt;code&gt;num - 1&lt;/code&gt; &lt;strong&gt;不存在&lt;/strong&gt;，那么 &lt;code&gt;num&lt;/code&gt; 就是一个潜在的序列起点。如果 &lt;code&gt;num - 1&lt;/code&gt; &lt;strong&gt;存在&lt;/strong&gt;，那么 &lt;code&gt;num&lt;/code&gt; 肯定不是起点，我们可以直接跳过它，因为它一定会被 &lt;code&gt;num - 1&lt;/code&gt; 开始的计算所覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算长度并更新结果&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希表 / 数组】LeetCode 383. 赎金信</title>
      <link>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</link>
      <pubDate>Thu, 18 Sep 2025 18:18:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;aa&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路字符计数&#34;&gt;核心思路：字符计数&lt;/h2&gt;
&lt;p&gt;这道题的本质是判断 &lt;code&gt;magazine&lt;/code&gt; 字符串中的字符数量，是否足够&amp;quot;支付&amp;quot; &lt;code&gt;ransomNote&lt;/code&gt; 中所需的字符数量。字符的顺序无关紧要，我们只关心每个字符的可用频率。&lt;/p&gt;
&lt;p&gt;这是一个典型的&lt;strong&gt;哈希表&lt;/strong&gt;或&lt;strong&gt;频率统计&lt;/strong&gt;问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计资源&lt;/strong&gt;：首先，我们需要清点我们拥有的&amp;quot;资源&amp;quot;，即 &lt;code&gt;magazine&lt;/code&gt; 中每个字符的数量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以遍历 &lt;code&gt;magazine&lt;/code&gt; 字符串。&lt;/li&gt;
&lt;li&gt;由于题目中只包含小写英文字母，我们可以使用一个长度为 26 的整型数组 &lt;code&gt;counts&lt;/code&gt; 来充当哈希表，这比使用 &lt;code&gt;HashMap&lt;/code&gt; 更高效。数组的索引 &lt;code&gt;c - &#39;a&#39;&lt;/code&gt; 对应字符 &lt;code&gt;c&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历 &lt;code&gt;magazine&lt;/code&gt; 时，将对应字符的计数值加 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消耗资源&lt;/strong&gt;：统计完 &lt;code&gt;magazine&lt;/code&gt; 的字符后，我们再遍历 &lt;code&gt;ransomNote&lt;/code&gt;，看看我们的资源是否足够。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希表 / 摩尔投票】LeetCode 169. 多数元素</title>
      <link>https://amemiya02.github.io/posts/2025-09-15-169-majority-element/</link>
      <pubDate>Mon, 15 Sep 2025 10:05:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-15-169-majority-element/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中的多数元素。多数元素是指在数组中出现次数 &lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/code&gt; 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[2,2,1,1,1,2,2]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路&#34;&gt;核心思路&lt;/h2&gt;
&lt;p&gt;这道题旨在寻找数组中数量过半的元素。我们介绍两种主流的思路。&lt;/p&gt;
&lt;h3 id=&#34;思路一哈希表计数&#34;&gt;思路一：哈希表计数&lt;/h3&gt;
&lt;p&gt;这是最直观、最容易想到的方法。我们可以利用一个哈希表（HashMap）来记录数组中每个元素出现的次数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义哈希表&lt;/strong&gt;：创建一个 &lt;code&gt;Map&amp;lt;Integer, Integer&amp;gt;&lt;/code&gt; 用于存储 &lt;code&gt;元素 -&amp;gt; 出现次数&lt;/code&gt; 的映射。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;：遍历 &lt;code&gt;nums&lt;/code&gt; 数组，对于每个元素 &lt;code&gt;num&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;将其在哈希表中的计数值加 1。&lt;/li&gt;
&lt;li&gt;每次更新计数后，立即检查该元素的计数值是否已经大于 &lt;code&gt;n/2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果超过 &lt;code&gt;n/2&lt;/code&gt;，那么这个元素就是我们要找的多数元素，直接返回它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：由于题目保证多数元素总是存在，所以在遍历过程中必然会找到答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个方法用空间换时间，思路简单清晰，易于实现。&lt;/p&gt;
&lt;h3 id=&#34;思路二摩尔投票算法-boyer-moore-voting-algorithm&#34;&gt;思路二：摩尔投票算法 (Boyer-Moore Voting Algorithm)&lt;/h3&gt;
&lt;p&gt;这是一种非常巧妙的算法，可以在线性的时间和常数的空间内解决问题。&lt;/p&gt;
&lt;p&gt;它的核心思想是&lt;strong&gt;对拼消耗&lt;/strong&gt;。可以想象成在数组中进行一场选举，不同阵营的候选人进行投票。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义候选者和票数&lt;/strong&gt;：我们维护一个候选者 &lt;code&gt;candidate&lt;/code&gt; 和一个计数器 &lt;code&gt;count&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;：遍历 &lt;code&gt;nums&lt;/code&gt; 数组，对于每个元素 &lt;code&gt;num&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt;，表示之前的候选者已经被&amp;quot;淘汰&amp;quot;了，我们将当前元素 &lt;code&gt;num&lt;/code&gt; 设为新的 &lt;code&gt;candidate&lt;/code&gt;，并将 &lt;code&gt;count&lt;/code&gt; 设为 1。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;num&lt;/code&gt; 与 &lt;code&gt;candidate&lt;/code&gt; &lt;strong&gt;相同&lt;/strong&gt;，就给候选者&amp;quot;投一票&amp;quot;，&lt;code&gt;count&lt;/code&gt; 加 1。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;num&lt;/code&gt; 与 &lt;code&gt;candidate&lt;/code&gt; &lt;strong&gt;不同&lt;/strong&gt;，就让候选者的票数&amp;quot;抵消&amp;quot;一张，&lt;code&gt;count&lt;/code&gt; 减 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：遍历结束后，留下的 &lt;code&gt;candidate&lt;/code&gt; 就是最终的多数元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;为什么这个方法可行？&lt;/strong&gt; 因为多数元素的数量超过了数组长度的一半，这意味着它的数量比所有其他元素数量的总和还要多。所以在对拼消耗的过程中，它的票数 &lt;code&gt;count&lt;/code&gt; 最终不可能被减到 0 或以下，它必然是笑到最后的那个。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/快慢指针】LeetCode 80. 删除有序数组中的重复项 II</title>
      <link>https://amemiya02.github.io/posts/2025-09-14-80-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Sun, 14 Sep 2025 16:55:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-14-80-remove-duplicates-from-sorted-array-ii/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个有序数组 &lt;code&gt;nums&lt;/code&gt; ，请你 &lt;strong&gt;原地&lt;/strong&gt; 删除重复出现的元素，使得出现次数超过两次的元素&lt;strong&gt;只出现两次&lt;/strong&gt; ，返回删除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在 &lt;strong&gt;原地&lt;/strong&gt; 修改输入数组 并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[1,1,1,2,2,3]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;5&lt;/code&gt;, nums = &lt;code&gt;[1,1,2,2,3,_]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 函数应返回 &lt;code&gt;k = 5&lt;/code&gt;，并且 &lt;code&gt;nums&lt;/code&gt; 的前五个元素为 &lt;code&gt;1, 1, 2, 2, 3&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;核心思路快慢指针的通用解法&#34;&gt;核心思路：快慢指针的通用解法&lt;/h2&gt;
&lt;p&gt;这道题是 LeetCode 26 的进阶版，规则从&amp;quot;只保留 1 个&amp;quot;变成了&amp;quot;最多保留 2 个&amp;quot;。快慢指针的思路依然适用，我们只需要对写入条件稍作修改。&lt;/p&gt;
&lt;p&gt;我们可以定义一个更通用的解法来处理&amp;quot;最多保留 k 个重复项&amp;quot;这类问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢指针 &lt;code&gt;slow&lt;/code&gt;&lt;/strong&gt;: 指向下一个可以被覆盖的位置。&lt;code&gt;[0...slow-1]&lt;/code&gt; 是已处理好的区域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快指针 &lt;code&gt;fast&lt;/code&gt;&lt;/strong&gt;: 遍历整个数组，寻找符合条件的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们遍历数组，对于快指针 &lt;code&gt;fast&lt;/code&gt; 指向的当前元素 &lt;code&gt;nums[fast]&lt;/code&gt;，思考一个问题：&lt;strong&gt;在什么情况下，这个元素应该被保留下来？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;保留的条件是：当前处理好的数组长度 &lt;code&gt;slow&lt;/code&gt; 小于 2，或者 &lt;code&gt;nums[fast]&lt;/code&gt; 不等于 &lt;code&gt;nums[slow - 2]&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slow &amp;lt; 2&lt;/code&gt;：表示当前是数组最开头的两个位置，无论如何都应该被填充，因为题目允许最多两个重复项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[fast] &amp;gt; nums[slow - 2]&lt;/code&gt;：这是本算法的核心。&lt;code&gt;nums[slow - 1]&lt;/code&gt; 和 &lt;code&gt;nums[slow - 2]&lt;/code&gt; 是已处理好的数组的最后两个元素。如果当前快指针的元素 &lt;code&gt;nums[fast]&lt;/code&gt; 和 &lt;code&gt;nums[slow - 2]&lt;/code&gt; 相同，说明 &lt;code&gt;nums[slow-2]&lt;/code&gt;, &lt;code&gt;nums[slow-1]&lt;/code&gt;, &lt;code&gt;nums[fast]&lt;/code&gt; 将构成三个或以上的连续重复，此时 &lt;code&gt;nums[fast]&lt;/code&gt; 不应被保留。反之，则可以保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/快慢指针】LeetCode 26.删除有序数组中的重复项</title>
      <link>https://amemiya02.github.io/posts/2025-09-13-26-remove-duplicates-from-sorted-array/</link>
      <pubDate>Sat, 13 Sep 2025 10:35:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-13-26-remove-duplicates-from-sorted-array/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你 &lt;strong&gt;原地&lt;/strong&gt; 删除重复出现的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; ，返回删除后数组的新长度。元素的 &lt;strong&gt;相对顺序&lt;/strong&gt; 应该保持 &lt;strong&gt;一致&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;更改数组 &lt;code&gt;nums&lt;/code&gt; ，使 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素包含唯一元素，并按照它们最初在 &lt;code&gt;nums&lt;/code&gt; 中出现的顺序排列。&lt;/p&gt;
&lt;p&gt;返回 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[0,0,1,1,1,2,2,3,3,4]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;5&lt;/code&gt;, nums = &lt;code&gt;[0,1,2,3,4,_,_,_,_,_]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 函数应该返回 &lt;code&gt;k = 5&lt;/code&gt;，并且 &lt;code&gt;nums&lt;/code&gt; 的前五个元素为 &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;核心思路快慢指针&#34;&gt;核心思路：快慢指针&lt;/h2&gt;
&lt;p&gt;题目的关键在于&amp;quot;数组有序&amp;quot;和&amp;quot;保持相对顺序&amp;quot;。因为数组是有序的，所以所有重复的元素必然是相邻的。这让我们不必进行复杂的查找，只需向后遍历即可。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;strong&gt;快慢指针&lt;/strong&gt;来解决这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢指针 &lt;code&gt;p&lt;/code&gt;&lt;/strong&gt;: 指向当前已处理好的、不重复数组的最后一个位置。它也代表了下一个唯一元素应该被放置的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快指针 &lt;code&gt;q&lt;/code&gt;&lt;/strong&gt;: 负责向前探索，遍历整个数组，寻找与慢指针所指元素不同的新元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 &lt;code&gt;p = 0&lt;/code&gt;, &lt;code&gt;q = 1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;快指针 &lt;code&gt;q&lt;/code&gt; 向后遍历数组。&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;nums[q]&lt;/code&gt; 与 &lt;code&gt;nums[p]&lt;/code&gt; &lt;strong&gt;相同&lt;/strong&gt;，说明是重复元素，则 &lt;code&gt;p&lt;/code&gt; 不动，&lt;code&gt;q&lt;/code&gt; 继续向后移动以跳过所有重复项。&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;nums[q]&lt;/code&gt; 与 &lt;code&gt;nums[p]&lt;/code&gt; &lt;strong&gt;不同&lt;/strong&gt;，说明 &lt;code&gt;q&lt;/code&gt; 找到了一个新的唯一元素。此时，先将慢指针 &lt;code&gt;p&lt;/code&gt; 向后移动一位 (&lt;code&gt;++p&lt;/code&gt;)，然后将 &lt;code&gt;nums[q]&lt;/code&gt; 的值赋给 &lt;code&gt;nums[p]&lt;/code&gt;，完成新元素的&amp;quot;入队&amp;quot;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 27. 原地移除数组元素</title>
      <link>https://amemiya02.github.io/posts/2025-09-12-27-remove-element/</link>
      <pubDate>Fri, 12 Sep 2025 21:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-12-27-remove-element/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;原地&lt;/strong&gt; 移除所有数值等于 &lt;code&gt;val&lt;/code&gt; 的元素。元素的顺序可能发生改变。然后返回 &lt;code&gt;nums&lt;/code&gt; 中与 &lt;code&gt;val&lt;/code&gt; 不同的元素的数量。&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;nums&lt;/code&gt; 中不等于 &lt;code&gt;val&lt;/code&gt; 的元素数量为 &lt;code&gt;k&lt;/code&gt;，要通过此题，您需要执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改 &lt;code&gt;nums&lt;/code&gt; 数组，使 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素包含不等于 &lt;code&gt;val&lt;/code&gt; 的元素。&lt;code&gt;nums&lt;/code&gt; 的其余元素和 &lt;code&gt;nums&lt;/code&gt; 的大小并不重要。&lt;/li&gt;
&lt;li&gt;返回 &lt;code&gt;k&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[3,2,2,3]&lt;/code&gt;, val = &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;, nums = &lt;code&gt;[2,2,_,_]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 函数应该返回 &lt;code&gt;k = 2&lt;/code&gt;, 并且 &lt;code&gt;nums&lt;/code&gt; 中的前两个元素均为 &lt;code&gt;2&lt;/code&gt;。你的函数可以返回 &lt;code&gt;k&lt;/code&gt;，并且 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素可以包含任何顺序的 &lt;code&gt;2&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;核心思路相向双指针头尾指针&#34;&gt;核心思路：相向双指针（头尾指针）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义头尾指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 指针从数组头部 &lt;code&gt;0&lt;/code&gt; 开始，向后移动。它的任务是&lt;strong&gt;寻找值为 &lt;code&gt;val&lt;/code&gt; 的元素&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q&lt;/code&gt; 指针从数组尾部 &lt;code&gt;n-1&lt;/code&gt; 开始，向前移动。它的任务是&lt;strong&gt;寻找值不为 &lt;code&gt;val&lt;/code&gt; 的元素&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交换与移动&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 88. 合并两个有序数组</title>
      <link>https://amemiya02.github.io/posts/2025-09-11-88-merge-sorted-array/</link>
      <pubDate>Thu, 11 Sep 2025 18:46:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-11-88-merge-sorted-array/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排列的整数数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;，另有两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; ，分别表示 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; 中的元素数目。&lt;/p&gt;
&lt;p&gt;请你 &lt;strong&gt;合并&lt;/strong&gt; &lt;code&gt;nums2&lt;/code&gt; 到 &lt;code&gt;nums1&lt;/code&gt; 中，使合并后的数组同样按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：最终，合并后数组不应由函数返回，而是存储在数组 &lt;code&gt;nums1&lt;/code&gt; 中。为了应对这种情况，&lt;code&gt;nums1&lt;/code&gt; 的初始长度为 &lt;code&gt;m + n&lt;/code&gt;，其中前 &lt;code&gt;m&lt;/code&gt; 个元素表示应合并的元素，后 &lt;code&gt;n&lt;/code&gt; 个元素为 &lt;code&gt;0&lt;/code&gt; ，应忽略。&lt;code&gt;nums2&lt;/code&gt; 的长度为 &lt;code&gt;n&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums1 = &lt;code&gt;[1,2,3,0,0,0]&lt;/code&gt;, m = &lt;code&gt;3&lt;/code&gt;, nums2 = &lt;code&gt;[2,5,6]&lt;/code&gt;, n = &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[1,2,2,3,5,6]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 需要合并 &lt;code&gt;[1,2,3]&lt;/code&gt; 和 &lt;code&gt;[2,5,6]&lt;/code&gt; 。合并结果是 &lt;code&gt;[1,2,2,3,5,6]&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最初的思考为何从前往后走不通&#34;&gt;最初的思考：为何从前往后走不通？&lt;/h2&gt;
&lt;p&gt;看到这道题，我的第一反应非常直接：创建一个新的指针 &lt;code&gt;i&lt;/code&gt; 指向 &lt;code&gt;nums1&lt;/code&gt; 的开头，一个指针 &lt;code&gt;j&lt;/code&gt; 指向 &lt;code&gt;nums2&lt;/code&gt; 的开头，然后比较 &lt;code&gt;nums1[i]&lt;/code&gt; 和 &lt;code&gt;nums2[j]&lt;/code&gt; 的大小，把较小的那个放到一个新数组里。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
