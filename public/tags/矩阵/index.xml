<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>矩阵 on 个人技术博客</title>
    <link>https://amemiya02.github.io/tags/%E7%9F%A9%E9%98%B5/</link>
    <description>Recent content in 矩阵 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 27 Jan 2026 09:00:00 +0900</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/tags/%E7%9F%A9%E9%98%B5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Golang] LeetCode 热题 100 - 矩阵</title>
      <link>https://amemiya02.github.io/posts/2026-01-27-matrix/</link>
      <pubDate>Tue, 27 Jan 2026 09:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-27-matrix/</guid>
      <description>&lt;h1 id=&#34;矩阵&#34;&gt;矩阵&lt;/h1&gt;
&lt;h2 id=&#34;73-矩阵置零---mid&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/set-matrix-zeroes/&#34;&gt;73. 矩阵置零 - Mid&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵，如果一个元素为 &lt;code&gt;0&lt;/code&gt; ，则将其所在行和列的所有元素都设为 &lt;code&gt;0&lt;/code&gt; 。请使用 &lt;strong&gt;原地&lt;/strong&gt; 算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,1,1],[1,0,1],[1,1,1]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[1,0,1],[0,0,0],[1,0,1]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[0,0,0,0],[0,4,5,0],[0,3,1,0]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个直观的解决方案是使用 $O(mn)$ 的额外空间，但这并不是一个好的解决方案。&lt;/li&gt;
&lt;li&gt;一个简单的改进方案是使用 $O(m + n)$ 的额外空间，但这仍然不是最好的解决方案。&lt;/li&gt;
&lt;li&gt;你能想出一个仅使用常量空间的解决方案吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;核心思路利用首行首列做标记&#34;&gt;核心思路：利用首行首列做标记&lt;/h3&gt;
&lt;p&gt;这道题的难点在于&lt;strong&gt;污染&lt;/strong&gt;问题：如果我们一边遍历一边将 0 所在的行列置零，那么修改后的 0 会干扰后续的遍历，导致整个矩阵最后全变成了 0。&lt;/p&gt;
&lt;h4 id=&#34;空间复杂度优化路径&#34;&gt;空间复杂度优化路径&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;$O(MN)$ 空间&lt;/strong&gt;：新建一个同样的矩阵做标记。太浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$O(M+N)$ 空间&lt;/strong&gt;：使用两个布尔数组 &lt;code&gt;row[]&lt;/code&gt; 和 &lt;code&gt;col[]&lt;/code&gt;，分别记录哪一行、哪一列需要置零。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$O(1)$ 空间&lt;/strong&gt;：直接利用矩阵的第一行和第一列来替代上面的两个布尔数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;算法流程--方案&#34;&gt;算法流程 ($O(1)$ 方案)&lt;/h4&gt;
&lt;p&gt;既然我们要用第一行和第一列来记录&amp;quot;该行/列是否需要置零&amp;quot;，那么第一行和第一列原本的状态（是否包含 0）就需要先被保存下来，否则会被后续的标记覆盖。&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;记录首行首列状态&lt;/strong&gt;：
定义两个变量 &lt;code&gt;firstRowHasZero&lt;/code&gt; 和 &lt;code&gt;firstColHasZero&lt;/code&gt;，遍历第一行和第一列，如果发现 0，则将对应的变量置为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/矩阵】LeetCode 240. 搜索二维矩阵 II</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-240-search-a-2d-matrix-ii/</link>
      <pubDate>Fri, 02 Jan 2026 23:00:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-240-search-a-2d-matrix-ii/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个高效的算法来搜索 &lt;code&gt;m x n&lt;/code&gt; 矩阵 &lt;code&gt;matrix&lt;/code&gt; 中的一个目标值 &lt;code&gt;target&lt;/code&gt; 。该矩阵具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行的元素从左到右升序排列。&lt;/li&gt;
&lt;li&gt;每列的元素从上到下升序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = ... (同上), target = 20&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路抽象-bst-从角落出发&#34;&gt;核心思路：抽象 BST (从角落出发)&lt;/h2&gt;
&lt;p&gt;如果把矩阵的每一个位置看作一个节点，我们要利用&amp;quot;行有序&amp;quot;和&amp;quot;列有序&amp;quot;这两个条件来快速缩小查找范围。&lt;/p&gt;
&lt;p&gt;如果我们从&lt;strong&gt;左上角&lt;/strong&gt;出发，当前值小于 &lt;code&gt;target&lt;/code&gt; 时，我们既可以向右走（变大），也可以向下走（变大），这就产生了歧义，无法确定唯一的搜索方向。&lt;/p&gt;
&lt;p&gt;但是，如果我们选择&lt;strong&gt;左下角&lt;/strong&gt;（或者右上角）作为起点，情况就完全不同了。&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;左下角&lt;/strong&gt; &lt;code&gt;(m-1, 0)&lt;/code&gt; 为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当前值 &amp;gt; target&lt;/strong&gt;：
因为当前行是升序的，左下角已经是该行最小的数了，如果连它都比 &lt;code&gt;target&lt;/code&gt; 大，说明&lt;strong&gt;这一行所有的数都比 &lt;code&gt;target&lt;/code&gt; 大&lt;/strong&gt;。
-&amp;gt; 结论：&lt;strong&gt;排除当前行&lt;/strong&gt;，向上移动 (&lt;code&gt;i--&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当前值 &amp;lt; target&lt;/strong&gt;：
因为当前列是升序的，左下角已经是该列最大的数了（在剩下的范围内），如果连它都比 &lt;code&gt;target&lt;/code&gt; 小，说明&lt;strong&gt;这一列所有的数都比 &lt;code&gt;target&lt;/code&gt; 小&lt;/strong&gt;。
-&amp;gt; 结论：&lt;strong&gt;排除当前列&lt;/strong&gt;，向右移动 (&lt;code&gt;j++&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个过程就像是在遍历一棵&lt;strong&gt;二叉搜索树 (BST)&lt;/strong&gt;，左下角就是根节点，往上走是找更小的（类似左子树），往右走是找更大的（类似右子树）。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
