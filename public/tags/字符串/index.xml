<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>字符串 on 个人技术博客</title>
    <link>https://amemiya02.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
    <description>Recent content in 字符串 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 18 Sep 2025 18:18:00 +0900</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/哈希表 / 数组】LeetCode 383. 赎金信</title>
      <link>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</link>
      <pubDate>Thu, 18 Sep 2025 18:18:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;aa&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路字符计数&#34;&gt;核心思路：字符计数&lt;/h2&gt;
&lt;p&gt;这道题的本质是判断 &lt;code&gt;magazine&lt;/code&gt; 字符串中的字符数量，是否足够&amp;quot;支付&amp;quot; &lt;code&gt;ransomNote&lt;/code&gt; 中所需的字符数量。字符的顺序无关紧要，我们只关心每个字符的可用频率。&lt;/p&gt;
&lt;p&gt;这是一个典型的&lt;strong&gt;哈希表&lt;/strong&gt;或&lt;strong&gt;频率统计&lt;/strong&gt;问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计资源&lt;/strong&gt;：首先，我们需要清点我们拥有的&amp;quot;资源&amp;quot;，即 &lt;code&gt;magazine&lt;/code&gt; 中每个字符的数量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以遍历 &lt;code&gt;magazine&lt;/code&gt; 字符串。&lt;/li&gt;
&lt;li&gt;由于题目中只包含小写英文字母，我们可以使用一个长度为 26 的整型数组 &lt;code&gt;counts&lt;/code&gt; 来充当哈希表，这比使用 &lt;code&gt;HashMap&lt;/code&gt; 更高效。数组的索引 &lt;code&gt;c - &#39;a&#39;&lt;/code&gt; 对应字符 &lt;code&gt;c&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历 &lt;code&gt;magazine&lt;/code&gt; 时，将对应字符的计数值加 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消耗资源&lt;/strong&gt;：统计完 &lt;code&gt;magazine&lt;/code&gt; 的字符后，我们再遍历 &lt;code&gt;ransomNote&lt;/code&gt;，看看我们的资源是否足够。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 392. 判断子序列</title>
      <link>https://amemiya02.github.io/posts/2025-09-17-392-is-subsequence/</link>
      <pubDate>Wed, 17 Sep 2025 20:13:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-17-392-is-subsequence/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，判断 &lt;code&gt;s&lt;/code&gt; 是否为 &lt;code&gt;t&lt;/code&gt; 的子序列。&lt;/p&gt;
&lt;p&gt;字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt;是&lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt;的一个子序列，而&lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt;不是）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; s = &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;, t = &lt;code&gt;&amp;quot;ahbgdc&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; s = &lt;code&gt;&amp;quot;axc&amp;quot;&lt;/code&gt;, t = &lt;code&gt;&amp;quot;ahbgdc&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路双指针&#34;&gt;核心思路：双指针&lt;/h2&gt;
&lt;p&gt;这道题的核心是匹配字符，同时要保持&lt;strong&gt;相对顺序&lt;/strong&gt;。这种&amp;quot;按顺序查找&amp;quot;的场景，是双指针大显身手的地方。我们可以使用两个指针，一个指向子序列 &lt;code&gt;s&lt;/code&gt;，一个指向主串 &lt;code&gt;t&lt;/code&gt;，然后同步向前扫描。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义指针 &lt;code&gt;p&lt;/code&gt; 指向 &lt;code&gt;s&lt;/code&gt; 的起始位置 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义指针 &lt;code&gt;q&lt;/code&gt; 指向 &lt;code&gt;t&lt;/code&gt; 的起始位置 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;贪心匹配&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们使用指针 &lt;code&gt;q&lt;/code&gt; 遍历主串 &lt;code&gt;t&lt;/code&gt;，同时用指针 &lt;code&gt;p&lt;/code&gt; 来标记我们&lt;strong&gt;当前正在 &lt;code&gt;s&lt;/code&gt; 中寻找的字符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 都在各自的字符串范围内时，进行循环比较：
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;s.charAt(p)&lt;/code&gt; 与 &lt;code&gt;t.charAt(q)&lt;/code&gt; &lt;strong&gt;相等&lt;/strong&gt;，意味着我们在 &lt;code&gt;t&lt;/code&gt; 中找到了 &lt;code&gt;s&lt;/code&gt; 的一个字符。接下来我们应该去寻找 &lt;code&gt;s&lt;/code&gt; 的下一个字符了，所以将 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; &lt;strong&gt;都&lt;/strong&gt;向后移动一位 (&lt;code&gt;p++&lt;/code&gt;, &lt;code&gt;q++&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;s.charAt(p)&lt;/code&gt; 与 &lt;code&gt;t.charAt(q)&lt;/code&gt; &lt;strong&gt;不相等&lt;/strong&gt;，说明当前 &lt;code&gt;t&lt;/code&gt; 中的这个字符不是我们想要的。我们应该继续在 &lt;code&gt;t&lt;/code&gt; 的后续部分寻找 &lt;code&gt;s.charAt(p)&lt;/code&gt;，所以只将 &lt;code&gt;q&lt;/code&gt; 向后移动一位 (&lt;code&gt;q++&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;判断结果&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 125. 验证回文串</title>
      <link>https://amemiya02.github.io/posts/2025-09-16-125-valid-palindrome/</link>
      <pubDate>Tue, 16 Sep 2025 21:02:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-16-125-valid-palindrome/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 &lt;strong&gt;回文串&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;字母和数字都属于字母数字字符。&lt;/p&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，如果它是 &lt;strong&gt;回文串&lt;/strong&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; s = &lt;code&gt;&amp;quot;A man, a plan, a canal: Panama&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; &lt;code&gt;&amp;quot;amanaplanacanalpanama&amp;quot;&lt;/code&gt; 是回文串。&lt;/p&gt;
&lt;h2 id=&#34;核心思路相向双指针&#34;&gt;核心思路：相向双指针&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;回文&amp;quot;这个特性，天然就适合使用&lt;strong&gt;相向双指针&lt;/strong&gt;来解决。我们可以设置一个指针从字符串头部开始，另一个指针从尾部开始，同时向中间移动并进行比较。&lt;/p&gt;
&lt;p&gt;对于这道题，我们需要在比较之前，先对字符进行&amp;quot;清洗&amp;rdquo;，即忽略非字母数字字符和大小写。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化指针&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义左指针 &lt;code&gt;left&lt;/code&gt; 指向字符串的起始位置 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义右指针 &lt;code&gt;right&lt;/code&gt; 指向字符串的末尾位置 &lt;code&gt;s.length() - 1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;循环与过滤&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;left &amp;lt; right&lt;/code&gt; 时，循环继续。&lt;/li&gt;
&lt;li&gt;在循环内部，首先要找到左右两边有效的、可用于比较的字符。
&lt;ul&gt;
&lt;li&gt;移动 &lt;code&gt;left&lt;/code&gt; 指针：如果 &lt;code&gt;left&lt;/code&gt; 指向的字符&lt;strong&gt;不是&lt;/strong&gt;字母或数字，就将 &lt;code&gt;left&lt;/code&gt; 右移 (&lt;code&gt;left++&lt;/code&gt;)，跳过该字符。&lt;/li&gt;
&lt;li&gt;移动 &lt;code&gt;right&lt;/code&gt; 指针：如果 &lt;code&gt;right&lt;/code&gt; 指向的字符&lt;strong&gt;不是&lt;/strong&gt;字母或数字，就将 &lt;code&gt;right&lt;/code&gt; 左移 (&lt;code&gt;right--&lt;/code&gt;)，跳过该字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;比较字符&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当左右指针都停留在有效的字母数字字符上时，将它们统一转换为小写进行比较。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;Character.toLowerCase(s.charAt(left))&lt;/code&gt; &lt;strong&gt;不等于&lt;/strong&gt; &lt;code&gt;Character.toLowerCase(s.charAt(right))&lt;/code&gt;，说明字符串不是回文串，可以直接返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;向中心移动&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
