<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>模拟 on 个人技术博客</title>
    <link>https://amemiya02.github.io/tags/%E6%A8%A1%E6%8B%9F/</link>
    <description>Recent content in 模拟 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 02 Jan 2026 21:30:00 +0900</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/tags/%E6%A8%A1%E6%8B%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/矩阵】LeetCode 54. 螺旋矩阵</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-54-spiral-matrix/</link>
      <pubDate>Fri, 02 Jan 2026 21:30:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-54-spiral-matrix/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个 &lt;code&gt;m&lt;/code&gt; 行 &lt;code&gt;n&lt;/code&gt; 列的矩阵 &lt;code&gt;matrix&lt;/code&gt; ，请按照 &lt;strong&gt;顺时针螺旋顺序&lt;/strong&gt; ，返回矩阵中的所有元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,2,3],[4,5,6],[7,8,9]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[1,2,3,6,9,8,7,4,5]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[1,2,3,4,8,12,11,10,9,5,6,7]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路四边界模拟法&#34;&gt;核心思路：四边界模拟法&lt;/h2&gt;
&lt;p&gt;这道题没有太多的算法技巧，本质上是一道&lt;strong&gt;模拟题&lt;/strong&gt;。我们需要模拟一个机器人在矩阵中按照&amp;quot;右 -&amp;gt; 下 -&amp;gt; 左 -&amp;gt; 上&amp;quot;的顺序一直走，直到填满所有格子。&lt;/p&gt;
&lt;p&gt;虽然思路简单，但如果不加设计地直接写，很容易陷入各种边界判断的泥潭（比如拐角处怎么处理、什么时候停止）。&lt;/p&gt;
&lt;p&gt;最优雅的解法是&lt;strong&gt;设定四个边界&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; (top)：上边界，初始为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; (bottom)：下边界，初始为 &lt;code&gt;m-1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; (left)：左边界，初始为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; (right)：右边界，初始为 &lt;code&gt;n-1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;算法流程&#34;&gt;算法流程&lt;/h3&gt;
&lt;p&gt;我们要在一个循环中按照顺时针方向依次处理四条边。每处理完一条边，就将对应的边界向内收缩，并立即检查是否越界（越界意味着遍历结束）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;向右移动&lt;/strong&gt;：遍历从 &lt;code&gt;l&lt;/code&gt; 到 &lt;code&gt;r&lt;/code&gt;。处理完后，上边界下移 (&lt;code&gt;++t&lt;/code&gt;)。如果 &lt;code&gt;t &amp;gt; b&lt;/code&gt;，说明上下边界交错，遍历结束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向下移动&lt;/strong&gt;：遍历从 &lt;code&gt;t&lt;/code&gt; 到 &lt;code&gt;b&lt;/code&gt;。处理完后，右边界左移 (&lt;code&gt;--r&lt;/code&gt;)。如果 &lt;code&gt;l &amp;gt; r&lt;/code&gt;，说明左右边界交错，遍历结束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向左移动&lt;/strong&gt;：遍历从 &lt;code&gt;r&lt;/code&gt; 到 &lt;code&gt;l&lt;/code&gt;。处理完后，下边界上移 (&lt;code&gt;--b&lt;/code&gt;)。如果 &lt;code&gt;t &amp;gt; b&lt;/code&gt;，遍历结束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向上移动&lt;/strong&gt;：遍历从 &lt;code&gt;b&lt;/code&gt; 到 &lt;code&gt;t&lt;/code&gt;。处理完后，左边界右移 (&lt;code&gt;++l&lt;/code&gt;)。如果 &lt;code&gt;l &amp;gt; r&lt;/code&gt;，遍历结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种写法将边界检查巧妙地融合在每一步操作之后，不需要在循环头部写复杂的 &lt;code&gt;count &amp;lt; total&lt;/code&gt; 判断，代码逻辑非常清晰。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
