<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>哈希集合 on 个人技术博客</title>
    <link>https://amemiya02.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</link>
    <description>Recent content in 哈希集合 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 22 Sep 2025 18:24:00 +0900</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/tags/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/滑动窗口/Middle】LeetCode 3. 无重复字符的最长子串</title>
      <link>https://amemiya02.github.io/posts/2025-09-22-3-longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 22 Sep 2025 18:24:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-22-3-longest-substring-without-repeating-characters/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;abcabcbb&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt; 因为无重复字符的最长子串是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;，所以其长度为 3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;pwwkew&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt; 因为无重复字符的最长子串是 &lt;code&gt;&amp;quot;wke&amp;quot;&lt;/code&gt;，所以其长度为 3。
请注意，你的答案必须是 &lt;strong&gt;子串&lt;/strong&gt; 的长度，&lt;code&gt;&amp;quot;pwke&amp;quot;&lt;/code&gt; 是一个子序列，不是子串。&lt;/p&gt;
&lt;h2 id=&#34;核心思路滑动窗口&#34;&gt;核心思路：滑动窗口&lt;/h2&gt;
&lt;p&gt;这道题要求我们找到一个&lt;strong&gt;连续&lt;/strong&gt;的子串，这个子串需要满足&amp;quot;无重复字符&amp;quot;的条件，并且长度要最长。这种在连续区间上求解的问题，非常适合使用&lt;strong&gt;滑动窗口&lt;/strong&gt;算法。&lt;/p&gt;
&lt;p&gt;我们可以想象有一个窗口在字符串 &lt;code&gt;s&lt;/code&gt; 上滑动，窗口的左右边界由两个指针 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 决定。这个窗口 &lt;code&gt;s[left...right]&lt;/code&gt; 就代表了我们正在考察的当前子串。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据结构选择&lt;/strong&gt;：我们需要一个数据结构来快速判断窗口内是否存在重复字符。&lt;strong&gt;哈希集合 (HashSet)&lt;/strong&gt; 是不二之选，它可以在 $O(1)$ 的时间内添加、删除和查找元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口的移动逻辑&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩大窗口&lt;/strong&gt;：我们不断地移动右指针 &lt;code&gt;right&lt;/code&gt;，将新的字符纳入窗口中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缩小窗口&lt;/strong&gt;：当新加入的字符 &lt;code&gt;s[right]&lt;/code&gt; 已经在哈希集合中存在时，说明窗口内出现了重复。此时，我们必须从左侧开始缩小窗口，即不断地移动左指针 &lt;code&gt;left&lt;/code&gt; 并从哈希集合中移除 &lt;code&gt;s[left]&lt;/code&gt;，直到窗口内不再包含重复的 &lt;code&gt;s[right]&lt;/code&gt; 为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化左指针 &lt;code&gt;left = 0&lt;/code&gt;，右指针 &lt;code&gt;right = 0&lt;/code&gt;，最大长度 &lt;code&gt;maxLength = 0&lt;/code&gt;，以及一个空的哈希集合 &lt;code&gt;set&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;右指针 &lt;code&gt;right&lt;/code&gt; 开始遍历整个字符串：
a.  获取当前右指针的字符 &lt;code&gt;c = s.charAt(right)&lt;/code&gt;。
b.  &lt;strong&gt;检查重复&lt;/strong&gt;：在 &lt;code&gt;set&lt;/code&gt; 中检查是否存在字符 &lt;code&gt;c&lt;/code&gt;。如果存在，就进入一个循环，不断从 &lt;code&gt;set&lt;/code&gt; 中移除左指针 &lt;code&gt;left&lt;/code&gt; 指向的字符，并递增 &lt;code&gt;left&lt;/code&gt;，直到 &lt;code&gt;set&lt;/code&gt; 中不再有 &lt;code&gt;c&lt;/code&gt;。
c.  &lt;strong&gt;添加新字符&lt;/strong&gt;：将当前字符 &lt;code&gt;c&lt;/code&gt; 添加到 &lt;code&gt;set&lt;/code&gt; 中。
d.  &lt;strong&gt;更新最大长度&lt;/strong&gt;：此时，从 &lt;code&gt;left&lt;/code&gt; 到 &lt;code&gt;right&lt;/code&gt; 的窗口内一定是无重复字符的。我们更新最大长度：&lt;code&gt;maxLength = Math.max(maxLength, right - left + 1)&lt;/code&gt;。
e.  将右指针 &lt;code&gt;right&lt;/code&gt; 右移一位，考察下一个字符。&lt;/li&gt;
&lt;li&gt;遍历结束后，&lt;code&gt;maxLength&lt;/code&gt; 就是最终答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种一扩一缩的动态调整，滑动窗口能够保证在一次遍历中就找到最优解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希集合/Middle】LeetCode 128. 最长连续序列</title>
      <link>https://amemiya02.github.io/posts/2025-09-21-128-longest-consecutive-sequence/</link>
      <pubDate>Sun, 21 Sep 2025 11:03:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-21-128-longest-consecutive-sequence/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p&gt;
&lt;p&gt;请你设计并实现时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 的算法解决此问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [100,4,200,1,3,2]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;4&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 最长数字连续序列是 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;。它的长度为 4。&lt;/p&gt;
&lt;h2 id=&#34;核心思路哈希集合--智能枚举&#34;&gt;核心思路：哈希集合 + 智能枚举&lt;/h2&gt;
&lt;p&gt;这道题最核心的要求是 &lt;code&gt;O(n)&lt;/code&gt; 的时间复杂度，这意味着我们不能使用排序 $O(nlogn)$。&lt;/p&gt;
&lt;p&gt;要实现 &lt;code&gt;O(n)&lt;/code&gt;，关键在于&lt;strong&gt;快速查找&lt;/strong&gt;某个数是否存在。这让我们自然而然地想到了哈希表。我们可以用一个&lt;strong&gt;哈希集合 (HashSet)&lt;/strong&gt; 来优化查找过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这题的关键是找出序列起点来剪枝&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空间换时间，初始化哈希集合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个 &lt;code&gt;HashSet&lt;/code&gt;，并将数组 &lt;code&gt;nums&lt;/code&gt; 中的所有元素都添加进去。&lt;/li&gt;
&lt;li&gt;这一步有两个目的：一是方便后续以 $O(1)$ 的时间复杂度快速查找某个数是否存在；二是自动处理了数组中的重复元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;智能遍历，只从序列的起点开始计算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是整个算法最精妙的地方。如果我们遍历集合中的每一个数，都尝试计算以它开头的序列长度，会有大量重复计算。例如，对于序列 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;，我们从 &lt;code&gt;1&lt;/code&gt; 开始计算了一遍，又会从 &lt;code&gt;2&lt;/code&gt; 开始再计算一遍 &lt;code&gt;[2, 3, 4]&lt;/code&gt;，这是不必要的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何避免重复计算？&lt;/strong&gt; 答案是：&lt;strong&gt;只从一个连续序列的起点开始计算&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何判断一个数 &lt;code&gt;num&lt;/code&gt; 是不是起点？&lt;/strong&gt; 很简单，只要检查 &lt;code&gt;num - 1&lt;/code&gt; 是否存在于哈希集合中。如果 &lt;code&gt;num - 1&lt;/code&gt; &lt;strong&gt;不存在&lt;/strong&gt;，那么 &lt;code&gt;num&lt;/code&gt; 就是一个潜在的序列起点。如果 &lt;code&gt;num - 1&lt;/code&gt; &lt;strong&gt;存在&lt;/strong&gt;，那么 &lt;code&gt;num&lt;/code&gt; 肯定不是起点，我们可以直接跳过它，因为它一定会被 &lt;code&gt;num - 1&lt;/code&gt; 开始的计算所覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算长度并更新结果&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
