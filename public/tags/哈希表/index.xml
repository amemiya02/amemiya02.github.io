<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>哈希表 on 个人技术博客</title>
    <link>https://amemiya02.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
    <description>Recent content in 哈希表 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 18 Dec 2025 14:00:00 +0800</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/滑动窗口】LeetCode 76. Minimum Window Substring</title>
      <link>https://amemiya02.github.io/posts/2025-12-18-76-minimum-window-substring/</link>
      <pubDate>Thu, 18 Dec 2025 14:00:00 +0800</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-12-18-76-minimum-window-substring/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt;，长度分别是 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt;，返回 &lt;code&gt;s&lt;/code&gt; 中的 &lt;strong&gt;最短窗口&lt;/strong&gt; 子串，使得该子串包含 &lt;code&gt;t&lt;/code&gt; 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;测试用例保证答案唯一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;s = &amp;quot;ADOBECODEBANC&amp;quot;&lt;/code&gt;, &lt;code&gt;t = &amp;quot;ABC&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;&amp;quot;BANC&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 最小覆盖子串 &lt;code&gt;&amp;quot;BANC&amp;quot;&lt;/code&gt; 包含 &lt;code&gt;t&lt;/code&gt; 中所有字符 &lt;code&gt;&#39;A&#39;&lt;/code&gt;, &lt;code&gt;&#39;B&#39;&lt;/code&gt;, &lt;code&gt;&#39;C&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;核心思路滑动窗口--哈希计数&#34;&gt;核心思路：滑动窗口 + 哈希计数&lt;/h2&gt;
&lt;p&gt;本题是「滑动窗口」的经典应用，核心目标是：在 &lt;code&gt;s&lt;/code&gt; 中找到一个&lt;strong&gt;最短连续子串&lt;/strong&gt;，使其&lt;strong&gt;字符频次 ≥ &lt;code&gt;t&lt;/code&gt; 的字符频次&lt;/strong&gt;（即完全覆盖 &lt;code&gt;t&lt;/code&gt;）。&lt;/p&gt;
&lt;h3 id=&#34;关键观察点&#34;&gt;关键观察点：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;窗口有效性判定&lt;/strong&gt;：不能只看字符是否出现，而要看&lt;strong&gt;频次是否足够&lt;/strong&gt;。例如 &lt;code&gt;t = &amp;quot;AAB&amp;quot;&lt;/code&gt;，窗口中至少要有 2 个 &lt;code&gt;&#39;A&#39;&lt;/code&gt; 和 1 个 &lt;code&gt;&#39;B&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展与收缩策略&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;右指针 &lt;code&gt;r&lt;/code&gt; 扩展窗口&lt;/strong&gt;：直到窗口&lt;strong&gt;首次满足覆盖条件&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左指针 &lt;code&gt;l&lt;/code&gt; 收缩窗口&lt;/strong&gt;：在满足条件的前提下，尽可能缩小窗口，尝试找到更优解；&lt;/li&gt;
&lt;li&gt;重复上述过程，维护全局最小窗口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实现细节&#34;&gt;实现细节：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用两个哈希表：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ori&lt;/code&gt;：统计 &lt;code&gt;t&lt;/code&gt; 中各字符的&lt;strong&gt;目标频次&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cnt&lt;/code&gt;：动态维护当前窗口 &lt;code&gt;[l, r]&lt;/code&gt; 中各字符的&lt;strong&gt;实际频次&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助函数 &lt;code&gt;check()&lt;/code&gt;：遍历 &lt;code&gt;ori&lt;/code&gt;，检查 &lt;code&gt;cnt&lt;/code&gt; 中每个字符频次是否 ≥ &lt;code&gt;ori&lt;/code&gt; 中对应值；
&lt;ul&gt;
&lt;li&gt;✅ 优化点：可改用「需匹配字符种类数」+「当前达标种类数」实现 O(1) 判断（见文末优化提示），但为清晰起见，此处保留原写法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠️ 注意边界：当 &lt;code&gt;r&lt;/code&gt; 向右移动后需先判断是否越界再访问 &lt;code&gt;s.charAt(r)&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/前缀和】LeetCode 560. 和为 K 的子数组</title>
      <link>https://amemiya02.github.io/posts/2025-12-17-560-subarray-sum-equals-k/</link>
      <pubDate>Wed, 17 Dec 2025 21:55:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-12-17-560-subarray-sum-equals-k/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你统计并返回 &lt;strong&gt;该数组中和为 &lt;code&gt;k&lt;/code&gt; 的子数组的个数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;子数组是数组中元素的连续非空序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,1,1], k = 2&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,2,3], k = 3&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路前缀和--哈希表优化&#34;&gt;核心思路：前缀和 + 哈希表优化&lt;/h2&gt;
&lt;p&gt;这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 $O(n^2)$ 甚至 $O(n^3)$，无法通过所有测试用例。我们需要利用&lt;strong&gt;前缀和&lt;/strong&gt;的性质进行优化。&lt;/p&gt;
&lt;h3 id=&#34;1-前缀和转化&#34;&gt;1. 前缀和转化&lt;/h3&gt;
&lt;p&gt;定义 &lt;code&gt;pre[i]&lt;/code&gt; 为 &lt;code&gt;[0..i]&lt;/code&gt; 里所有数的和。那么 &lt;code&gt;[j..i]&lt;/code&gt; 这个子数组的和可以表示为：
$$
sum[j..i] = pre[i] - pre[j-1]
$$
题目要求找到和为 &lt;code&gt;k&lt;/code&gt; 的子数组，即寻找满足以下条件的 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt;：
$$
pre[i] - pre[j-1] == k
$$
移项得：
$$
pre[j-1] == pre[i] - k
$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/滑动窗口/Middle】LeetCode 438. 找到字符串中所有字母异位词</title>
      <link>https://amemiya02.github.io/posts/2025-09-23-438-find-all-anagrams-in-a-string/</link>
      <pubDate>Tue, 23 Sep 2025 09:52:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-23-438-find-all-anagrams-in-a-string/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中所有 &lt;code&gt;p&lt;/code&gt; 的 &lt;strong&gt;字母异位词&lt;/strong&gt; 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 指由相同字母按不同顺序排列组成的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;cbaebabacd&amp;quot;&lt;/code&gt;, &lt;code&gt;p = &amp;quot;abc&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;[0,6]&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt;
起始索引等于 0 的子串是 &lt;code&gt;&amp;quot;cba&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。
起始索引等于 6 的子串是 &lt;code&gt;&amp;quot;bac&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。&lt;/p&gt;
&lt;h2 id=&#34;核心思路定长滑动窗口--字符频率统计&#34;&gt;核心思路：定长滑动窗口 + 字符频率统计&lt;/h2&gt;
&lt;p&gt;这道题要求我们在一个长字符串 &lt;code&gt;s&lt;/code&gt; 中，找出所有与短字符串 &lt;code&gt;p&lt;/code&gt; 构成字母异位词的&lt;strong&gt;子串&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;字母异位词&amp;quot;的判断标准是：两个字符串长度相等，且包含的字符种类和数量完全相同。这提示我们，核心在于&lt;strong&gt;字符频率的比较&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;找出所有&amp;hellip;的子串&amp;quot;则强烈地暗示了&lt;strong&gt;滑动窗口&lt;/strong&gt;算法。由于 &lt;code&gt;p&lt;/code&gt; 的长度是固定的，我们可以使用一个&lt;strong&gt;大小固定&lt;/strong&gt;的滑动窗口来遍历 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;结合以上两点，我们的解题策略就清晰了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计 &lt;code&gt;p&lt;/code&gt; 的频率&lt;/strong&gt;：首先，我们需要一个&amp;quot;标准答案&amp;rdquo;，也就是字符串 &lt;code&gt;p&lt;/code&gt; 的字符频率分布。因为题目只包含小写字母，我们可以用一个长度为 26 的数组 &lt;code&gt;countP&lt;/code&gt; 来存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建固定大小的窗口&lt;/strong&gt;：我们在 &lt;code&gt;s&lt;/code&gt; 上维护一个长度与 &lt;code&gt;p&lt;/code&gt; 相同的滑动窗口。我们同样用一个长度为 26 的数组 &lt;code&gt;countS&lt;/code&gt; 来实时统计这个窗口内的字符频率。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希表 / 数组】LeetCode 383. 赎金信</title>
      <link>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</link>
      <pubDate>Thu, 18 Sep 2025 18:18:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-18-383-ransom-note/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; ransomNote = &lt;code&gt;&amp;quot;aa&amp;quot;&lt;/code&gt;, magazine = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路字符计数&#34;&gt;核心思路：字符计数&lt;/h2&gt;
&lt;p&gt;这道题的本质是判断 &lt;code&gt;magazine&lt;/code&gt; 字符串中的字符数量，是否足够&amp;quot;支付&amp;quot; &lt;code&gt;ransomNote&lt;/code&gt; 中所需的字符数量。字符的顺序无关紧要，我们只关心每个字符的可用频率。&lt;/p&gt;
&lt;p&gt;这是一个典型的&lt;strong&gt;哈希表&lt;/strong&gt;或&lt;strong&gt;频率统计&lt;/strong&gt;问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计资源&lt;/strong&gt;：首先，我们需要清点我们拥有的&amp;quot;资源&amp;quot;，即 &lt;code&gt;magazine&lt;/code&gt; 中每个字符的数量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以遍历 &lt;code&gt;magazine&lt;/code&gt; 字符串。&lt;/li&gt;
&lt;li&gt;由于题目中只包含小写英文字母，我们可以使用一个长度为 26 的整型数组 &lt;code&gt;counts&lt;/code&gt; 来充当哈希表，这比使用 &lt;code&gt;HashMap&lt;/code&gt; 更高效。数组的索引 &lt;code&gt;c - &#39;a&#39;&lt;/code&gt; 对应字符 &lt;code&gt;c&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历 &lt;code&gt;magazine&lt;/code&gt; 时，将对应字符的计数值加 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消耗资源&lt;/strong&gt;：统计完 &lt;code&gt;magazine&lt;/code&gt; 的字符后，我们再遍历 &lt;code&gt;ransomNote&lt;/code&gt;，看看我们的资源是否足够。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/哈希表 / 摩尔投票】LeetCode 169. 多数元素</title>
      <link>https://amemiya02.github.io/posts/2025-09-15-169-majority-element/</link>
      <pubDate>Mon, 15 Sep 2025 10:05:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-09-15-169-majority-element/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中的多数元素。多数元素是指在数组中出现次数 &lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/code&gt; 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums = &lt;code&gt;[2,2,1,1,1,2,2]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路&#34;&gt;核心思路&lt;/h2&gt;
&lt;p&gt;这道题旨在寻找数组中数量过半的元素。我们介绍两种主流的思路。&lt;/p&gt;
&lt;h3 id=&#34;思路一哈希表计数&#34;&gt;思路一：哈希表计数&lt;/h3&gt;
&lt;p&gt;这是最直观、最容易想到的方法。我们可以利用一个哈希表（HashMap）来记录数组中每个元素出现的次数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义哈希表&lt;/strong&gt;：创建一个 &lt;code&gt;Map&amp;lt;Integer, Integer&amp;gt;&lt;/code&gt; 用于存储 &lt;code&gt;元素 -&amp;gt; 出现次数&lt;/code&gt; 的映射。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;：遍历 &lt;code&gt;nums&lt;/code&gt; 数组，对于每个元素 &lt;code&gt;num&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;将其在哈希表中的计数值加 1。&lt;/li&gt;
&lt;li&gt;每次更新计数后，立即检查该元素的计数值是否已经大于 &lt;code&gt;n/2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果超过 &lt;code&gt;n/2&lt;/code&gt;，那么这个元素就是我们要找的多数元素，直接返回它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：由于题目保证多数元素总是存在，所以在遍历过程中必然会找到答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个方法用空间换时间，思路简单清晰，易于实现。&lt;/p&gt;
&lt;h3 id=&#34;思路二摩尔投票算法-boyer-moore-voting-algorithm&#34;&gt;思路二：摩尔投票算法 (Boyer-Moore Voting Algorithm)&lt;/h3&gt;
&lt;p&gt;这是一种非常巧妙的算法，可以在线性的时间和常数的空间内解决问题。&lt;/p&gt;
&lt;p&gt;它的核心思想是&lt;strong&gt;对拼消耗&lt;/strong&gt;。可以想象成在数组中进行一场选举，不同阵营的候选人进行投票。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义候选者和票数&lt;/strong&gt;：我们维护一个候选者 &lt;code&gt;candidate&lt;/code&gt; 和一个计数器 &lt;code&gt;count&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;：遍历 &lt;code&gt;nums&lt;/code&gt; 数组，对于每个元素 &lt;code&gt;num&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt;，表示之前的候选者已经被&amp;quot;淘汰&amp;quot;了，我们将当前元素 &lt;code&gt;num&lt;/code&gt; 设为新的 &lt;code&gt;candidate&lt;/code&gt;，并将 &lt;code&gt;count&lt;/code&gt; 设为 1。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;num&lt;/code&gt; 与 &lt;code&gt;candidate&lt;/code&gt; &lt;strong&gt;相同&lt;/strong&gt;，就给候选者&amp;quot;投一票&amp;quot;，&lt;code&gt;count&lt;/code&gt; 加 1。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;num&lt;/code&gt; 与 &lt;code&gt;candidate&lt;/code&gt; &lt;strong&gt;不同&lt;/strong&gt;，就让候选者的票数&amp;quot;抵消&amp;quot;一张，&lt;code&gt;count&lt;/code&gt; 减 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：遍历结束后，留下的 &lt;code&gt;candidate&lt;/code&gt; 就是最终的多数元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;为什么这个方法可行？&lt;/strong&gt; 因为多数元素的数量超过了数组长度的一半，这意味着它的数量比所有其他元素数量的总和还要多。所以在对拼消耗的过程中，它的票数 &lt;code&gt;count&lt;/code&gt; 最终不可能被减到 0 或以下，它必然是笑到最后的那个。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
