<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>动态规划 on 个人技术博客</title>
    <link>http://localhost:1313/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <description>Recent content in 动态规划 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 02 Jan 2026 15:10:00 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/动态规划】LeetCode 53. 最大子数组和</title>
      <link>http://localhost:1313/posts/2026-01-02-53-maximum-subarray/</link>
      <pubDate>Fri, 02 Jan 2026 15:10:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2026-01-02-53-maximum-subarray/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;6&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 连续子数组 &lt;code&gt;[4,-1,2,1]&lt;/code&gt; 的和最大，为 &lt;code&gt;6&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [5,4,-1,7,8]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;23&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路动态规划与贪心&#34;&gt;核心思路：动态规划与贪心&lt;/h2&gt;
&lt;p&gt;这道题是**动态规划（Dynamic Programming）**的经典入门题。&lt;/p&gt;
&lt;p&gt;如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 $O(N^2)$，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。&lt;/p&gt;
&lt;h3 id=&#34;状态定义&#34;&gt;状态定义&lt;/h3&gt;
&lt;p&gt;我们要思考：&lt;strong&gt;以当前数字 &lt;code&gt;nums[i]&lt;/code&gt; 结尾的子数组，它的最大和是多少？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;dp[i]&lt;/code&gt; 表示以 &lt;code&gt;nums[i]&lt;/code&gt; &lt;strong&gt;结尾&lt;/strong&gt;的连续子数组的最大和。那么对于 &lt;code&gt;nums[i]&lt;/code&gt; 来说，它面临两个选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;加入前面的队伍&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是正数，那么加上它肯定比自己单干强，即 &lt;code&gt;dp[i-1] + nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;另起炉灶&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 &lt;code&gt;nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;状态转移方程&#34;&gt;状态转移方程&lt;/h3&gt;
&lt;p&gt;根据上述分析，我们可以得到状态转移方程：
$$
dp[i] = \max(dp[i-1] + \text{nums}[i], \text{nums}[i])
$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/动态规划】LeetCode 42. 接雨水</title>
      <link>http://localhost:1313/posts/2026-01-02-42-trapping-rain-water/</link>
      <pubDate>Fri, 02 Jan 2026 14:35:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2026-01-02-42-trapping-rain-water/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;height = [0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;6&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 上面是由数组 &lt;code&gt;[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt; 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;height = [4,2,0,3,2,5]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;9&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路按列求值的动态规划&#34;&gt;核心思路：按列求值的动态规划&lt;/h2&gt;
&lt;p&gt;这道题是 LeetCode Top 100 中非常经典的 Hard 题目，也是大厂面试的常客。解决这道题的关键在于&lt;strong&gt;化繁为简&lt;/strong&gt;：不要试图一次性算出所有雨水，而是思考&lt;strong&gt;每一根柱子上方能存多少水&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于数组中索引为 &lt;code&gt;i&lt;/code&gt; 的位置，它能接到的雨水量取决于什么？
根据&amp;quot;木桶效应&amp;quot;，它能存的水，取决于它&lt;strong&gt;左边最高的柱子&lt;/strong&gt;和&lt;strong&gt;右边最高的柱子&lt;/strong&gt;中较矮的那一个，减去它自身的高度。&lt;/p&gt;
&lt;p&gt;公式如下：&lt;/p&gt;
&lt;p&gt;$$
\text{water}[i] = \min(\text{maxleft}[i], \text{maxright}[i]) - \text{height}[i]
$$&lt;/p&gt;
&lt;p&gt;当然，如果计算结果小于 0，说明当前柱子比两边都高，存不了水，结果取 0。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要动态规划&#34;&gt;为什么需要动态规划？&lt;/h3&gt;
&lt;p&gt;如果我们对每个位置 &lt;code&gt;i&lt;/code&gt; 都向左、向右扫描寻找最大值，时间复杂度会达到 $O(N^2)$，这在数据量大时会超时。&lt;/p&gt;
&lt;p&gt;为了优化，我们可以使用&lt;strong&gt;空间换时间&lt;/strong&gt;的策略（预处理）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;左侧最大值数组 (&lt;code&gt;left&lt;/code&gt;)&lt;/strong&gt;：从左往右遍历，&lt;code&gt;left[i]&lt;/code&gt; 表示 &lt;code&gt;[0...i]&lt;/code&gt; 区间内的最大高度。递推公式为 &lt;code&gt;left[i] = max(left[i-1], height[i])&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右侧最大值数组 (&lt;code&gt;right&lt;/code&gt;)&lt;/strong&gt;：从右往左遍历，&lt;code&gt;right[i]&lt;/code&gt; 表示 &lt;code&gt;[i...n-1]&lt;/code&gt; 区间内的最大高度。递推公式为 &lt;code&gt;right[i] = max(right[i+1], height[i])&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，我们在最后计算雨水时，只需要 $O(1)$ 的时间就能获取到左右两边的限制高度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/动态规划】LeetCode 70.爬楼梯</title>
      <link>http://localhost:1313/posts/2025-09-13-70-climbing-stairs/</link>
      <pubDate>Sat, 13 Sep 2025 10:40:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2025-09-13-70-climbing-stairs/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; n = 3
&lt;strong&gt;输出：&lt;/strong&gt; 3
&lt;strong&gt;解释：&lt;/strong&gt; 有三种方法可以爬到楼顶。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1 阶 + 1 阶 + 1 阶&lt;/li&gt;
&lt;li&gt;1 阶 + 2 阶&lt;/li&gt;
&lt;li&gt;2 阶 + 1 阶&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;核心思路寻找递推关系&#34;&gt;核心思路：寻找递推关系&lt;/h2&gt;
&lt;p&gt;直接计算 &lt;code&gt;n&lt;/code&gt; 阶楼梯的所有方法可能很复杂，我们不妨从小问题入手，寻找规律。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;爬 1 阶楼梯 (n=1)&lt;/strong&gt;: 只有 1 种方法 (1)。 -&amp;gt; $f(1) = 1$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;爬 2 阶楼梯 (n=2)&lt;/strong&gt;: 有 2 种方法 (1+1, 2)。 -&amp;gt; $f(2) = 2$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;爬 3 阶楼梯 (n=3)&lt;/strong&gt;: 有 3 种方法 (1+1+1, 1+2, 2+1)。 -&amp;gt; $f(3) = 3$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们思考一下，要想到达第 &lt;code&gt;n&lt;/code&gt; 阶，我们的&lt;strong&gt;最后一步&lt;/strong&gt;是怎么迈出去的？&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
