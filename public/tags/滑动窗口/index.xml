<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>滑动窗口 on 个人技术博客</title>
    <link>http://localhost:1313/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
    <description>Recent content in 滑动窗口 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 18 Dec 2025 15:30:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/单调队列】LeetCode 239. 滑动窗口最大值</title>
      <link>http://localhost:1313/posts/2025-12-18-239-sliding-window-maximum/</link>
      <pubDate>Thu, 18 Dec 2025 15:30:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/2025-12-18-239-sliding-window-maximum/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，有一个大小为 &lt;code&gt;k&lt;/code&gt; 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的 &lt;code&gt;k&lt;/code&gt; 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1,3,-1,-3,5,3,6,7]&lt;/code&gt;, &lt;code&gt;k = 3&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[3,3,5,5,6,7]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;
滑动窗口的位置                最大值&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1  3  -1] -3  5  3  6  7       3&lt;br&gt;
1 [3  -1  -3] 5  3  6  7       3&lt;br&gt;
1  3 [-1  -3  5] 3  6  7       5&lt;br&gt;
1  3  -1 [-3  5  3] 6  7       5&lt;br&gt;
1  3  -1  -3 [5  3  6] 7       6&lt;br&gt;
1  3  -1  -3  5 [3  6  7]      7&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/滑动窗口】LeetCode 76. Minimum Window Substring</title>
      <link>http://localhost:1313/posts/2025-12-18-76-minimum-window-substring/</link>
      <pubDate>Thu, 18 Dec 2025 14:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/2025-12-18-76-minimum-window-substring/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt;，长度分别是 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt;，返回 &lt;code&gt;s&lt;/code&gt; 中的 &lt;strong&gt;最短窗口&lt;/strong&gt; 子串，使得该子串包含 &lt;code&gt;t&lt;/code&gt; 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;测试用例保证答案唯一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;s = &amp;quot;ADOBECODEBANC&amp;quot;&lt;/code&gt;, &lt;code&gt;t = &amp;quot;ABC&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;&amp;quot;BANC&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 最小覆盖子串 &lt;code&gt;&amp;quot;BANC&amp;quot;&lt;/code&gt; 包含 &lt;code&gt;t&lt;/code&gt; 中所有字符 &lt;code&gt;&#39;A&#39;&lt;/code&gt;, &lt;code&gt;&#39;B&#39;&lt;/code&gt;, &lt;code&gt;&#39;C&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;核心思路滑动窗口--哈希计数&#34;&gt;核心思路：滑动窗口 + 哈希计数&lt;/h2&gt;
&lt;p&gt;本题是「滑动窗口」的经典应用，核心目标是：在 &lt;code&gt;s&lt;/code&gt; 中找到一个&lt;strong&gt;最短连续子串&lt;/strong&gt;，使其&lt;strong&gt;字符频次 ≥ &lt;code&gt;t&lt;/code&gt; 的字符频次&lt;/strong&gt;（即完全覆盖 &lt;code&gt;t&lt;/code&gt;）。&lt;/p&gt;
&lt;h3 id=&#34;关键观察点&#34;&gt;关键观察点：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;窗口有效性判定&lt;/strong&gt;：不能只看字符是否出现，而要看&lt;strong&gt;频次是否足够&lt;/strong&gt;。例如 &lt;code&gt;t = &amp;quot;AAB&amp;quot;&lt;/code&gt;，窗口中至少要有 2 个 &lt;code&gt;&#39;A&#39;&lt;/code&gt; 和 1 个 &lt;code&gt;&#39;B&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展与收缩策略&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;右指针 &lt;code&gt;r&lt;/code&gt; 扩展窗口&lt;/strong&gt;：直到窗口&lt;strong&gt;首次满足覆盖条件&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左指针 &lt;code&gt;l&lt;/code&gt; 收缩窗口&lt;/strong&gt;：在满足条件的前提下，尽可能缩小窗口，尝试找到更优解；&lt;/li&gt;
&lt;li&gt;重复上述过程，维护全局最小窗口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实现细节&#34;&gt;实现细节：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用两个哈希表：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ori&lt;/code&gt;：统计 &lt;code&gt;t&lt;/code&gt; 中各字符的&lt;strong&gt;目标频次&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cnt&lt;/code&gt;：动态维护当前窗口 &lt;code&gt;[l, r]&lt;/code&gt; 中各字符的&lt;strong&gt;实际频次&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助函数 &lt;code&gt;check()&lt;/code&gt;：遍历 &lt;code&gt;ori&lt;/code&gt;，检查 &lt;code&gt;cnt&lt;/code&gt; 中每个字符频次是否 ≥ &lt;code&gt;ori&lt;/code&gt; 中对应值；
&lt;ul&gt;
&lt;li&gt;✅ 优化点：可改用「需匹配字符种类数」+「当前达标种类数」实现 O(1) 判断（见文末优化提示），但为清晰起见，此处保留原写法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠️ 注意边界：当 &lt;code&gt;r&lt;/code&gt; 向右移动后需先判断是否越界再访问 &lt;code&gt;s.charAt(r)&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/滑动窗口/Middle】LeetCode 438. 找到字符串中所有字母异位词</title>
      <link>http://localhost:1313/posts/2025-09-23-438-find-all-anagrams-in-a-string/</link>
      <pubDate>Tue, 23 Sep 2025 09:52:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2025-09-23-438-find-all-anagrams-in-a-string/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中所有 &lt;code&gt;p&lt;/code&gt; 的 &lt;strong&gt;字母异位词&lt;/strong&gt; 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 指由相同字母按不同顺序排列组成的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;cbaebabacd&amp;quot;&lt;/code&gt;, &lt;code&gt;p = &amp;quot;abc&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;[0,6]&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt;
起始索引等于 0 的子串是 &lt;code&gt;&amp;quot;cba&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。
起始索引等于 6 的子串是 &lt;code&gt;&amp;quot;bac&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。&lt;/p&gt;
&lt;h2 id=&#34;核心思路定长滑动窗口--字符频率统计&#34;&gt;核心思路：定长滑动窗口 + 字符频率统计&lt;/h2&gt;
&lt;p&gt;这道题要求我们在一个长字符串 &lt;code&gt;s&lt;/code&gt; 中，找出所有与短字符串 &lt;code&gt;p&lt;/code&gt; 构成字母异位词的&lt;strong&gt;子串&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;字母异位词&amp;quot;的判断标准是：两个字符串长度相等，且包含的字符种类和数量完全相同。这提示我们，核心在于&lt;strong&gt;字符频率的比较&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;找出所有&amp;hellip;的子串&amp;quot;则强烈地暗示了&lt;strong&gt;滑动窗口&lt;/strong&gt;算法。由于 &lt;code&gt;p&lt;/code&gt; 的长度是固定的，我们可以使用一个&lt;strong&gt;大小固定&lt;/strong&gt;的滑动窗口来遍历 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;结合以上两点，我们的解题策略就清晰了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计 &lt;code&gt;p&lt;/code&gt; 的频率&lt;/strong&gt;：首先，我们需要一个&amp;quot;标准答案&amp;rdquo;，也就是字符串 &lt;code&gt;p&lt;/code&gt; 的字符频率分布。因为题目只包含小写字母，我们可以用一个长度为 26 的数组 &lt;code&gt;countP&lt;/code&gt; 来存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建固定大小的窗口&lt;/strong&gt;：我们在 &lt;code&gt;s&lt;/code&gt; 上维护一个长度与 &lt;code&gt;p&lt;/code&gt; 相同的滑动窗口。我们同样用一个长度为 26 的数组 &lt;code&gt;countS&lt;/code&gt; 来实时统计这个窗口内的字符频率。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【HOT100/滑动窗口/Middle】LeetCode 3. 无重复字符的最长子串</title>
      <link>http://localhost:1313/posts/2025-09-22-3-longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 22 Sep 2025 18:24:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2025-09-22-3-longest-substring-without-repeating-characters/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;abcabcbb&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt; 因为无重复字符的最长子串是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;，所以其长度为 3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &lt;code&gt;s = &amp;quot;pwwkew&amp;quot;&lt;/code&gt;
&lt;strong&gt;输出:&lt;/strong&gt; &lt;code&gt;3&lt;/code&gt;
&lt;strong&gt;解释:&lt;/strong&gt; 因为无重复字符的最长子串是 &lt;code&gt;&amp;quot;wke&amp;quot;&lt;/code&gt;，所以其长度为 3。
请注意，你的答案必须是 &lt;strong&gt;子串&lt;/strong&gt; 的长度，&lt;code&gt;&amp;quot;pwke&amp;quot;&lt;/code&gt; 是一个子序列，不是子串。&lt;/p&gt;
&lt;h2 id=&#34;核心思路滑动窗口&#34;&gt;核心思路：滑动窗口&lt;/h2&gt;
&lt;p&gt;这道题要求我们找到一个&lt;strong&gt;连续&lt;/strong&gt;的子串，这个子串需要满足&amp;quot;无重复字符&amp;quot;的条件，并且长度要最长。这种在连续区间上求解的问题，非常适合使用&lt;strong&gt;滑动窗口&lt;/strong&gt;算法。&lt;/p&gt;
&lt;p&gt;我们可以想象有一个窗口在字符串 &lt;code&gt;s&lt;/code&gt; 上滑动，窗口的左右边界由两个指针 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 决定。这个窗口 &lt;code&gt;s[left...right]&lt;/code&gt; 就代表了我们正在考察的当前子串。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据结构选择&lt;/strong&gt;：我们需要一个数据结构来快速判断窗口内是否存在重复字符。&lt;strong&gt;哈希集合 (HashSet)&lt;/strong&gt; 是不二之选，它可以在 $O(1)$ 的时间内添加、删除和查找元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口的移动逻辑&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩大窗口&lt;/strong&gt;：我们不断地移动右指针 &lt;code&gt;right&lt;/code&gt;，将新的字符纳入窗口中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缩小窗口&lt;/strong&gt;：当新加入的字符 &lt;code&gt;s[right]&lt;/code&gt; 已经在哈希集合中存在时，说明窗口内出现了重复。此时，我们必须从左侧开始缩小窗口，即不断地移动左指针 &lt;code&gt;left&lt;/code&gt; 并从哈希集合中移除 &lt;code&gt;s[left]&lt;/code&gt;，直到窗口内不再包含重复的 &lt;code&gt;s[right]&lt;/code&gt; 为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化左指针 &lt;code&gt;left = 0&lt;/code&gt;，右指针 &lt;code&gt;right = 0&lt;/code&gt;，最大长度 &lt;code&gt;maxLength = 0&lt;/code&gt;，以及一个空的哈希集合 &lt;code&gt;set&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;右指针 &lt;code&gt;right&lt;/code&gt; 开始遍历整个字符串：
a.  获取当前右指针的字符 &lt;code&gt;c = s.charAt(right)&lt;/code&gt;。
b.  &lt;strong&gt;检查重复&lt;/strong&gt;：在 &lt;code&gt;set&lt;/code&gt; 中检查是否存在字符 &lt;code&gt;c&lt;/code&gt;。如果存在，就进入一个循环，不断从 &lt;code&gt;set&lt;/code&gt; 中移除左指针 &lt;code&gt;left&lt;/code&gt; 指向的字符，并递增 &lt;code&gt;left&lt;/code&gt;，直到 &lt;code&gt;set&lt;/code&gt; 中不再有 &lt;code&gt;c&lt;/code&gt;。
c.  &lt;strong&gt;添加新字符&lt;/strong&gt;：将当前字符 &lt;code&gt;c&lt;/code&gt; 添加到 &lt;code&gt;set&lt;/code&gt; 中。
d.  &lt;strong&gt;更新最大长度&lt;/strong&gt;：此时，从 &lt;code&gt;left&lt;/code&gt; 到 &lt;code&gt;right&lt;/code&gt; 的窗口内一定是无重复字符的。我们更新最大长度：&lt;code&gt;maxLength = Math.max(maxLength, right - left + 1)&lt;/code&gt;。
e.  将右指针 &lt;code&gt;right&lt;/code&gt; 右移一位，考察下一个字符。&lt;/li&gt;
&lt;li&gt;遍历结束后，&lt;code&gt;maxLength&lt;/code&gt; 就是最终答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种一扩一缩的动态调整，滑动窗口能够保证在一次遍历中就找到最优解。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
