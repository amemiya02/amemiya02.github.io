<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>排序 on 个人技术博客</title>
    <link>https://amemiya02.github.io/tags/%E6%8E%92%E5%BA%8F/</link>
    <description>Recent content in 排序 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 02 Jan 2026 16:20:00 +0900</lastBuildDate>
    <atom:link href="https://amemiya02.github.io/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/排序】LeetCode 56. 合并区间</title>
      <link>https://amemiya02.github.io/posts/2026-01-02-56-merge-intervals/</link>
      <pubDate>Fri, 02 Jan 2026 16:20:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2026-01-02-56-merge-intervals/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以数组 &lt;code&gt;intervals&lt;/code&gt; 表示若干个区间的集合，其中单个区间为 &lt;code&gt;intervals[i] = [start_i, end_i]&lt;/code&gt; 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;intervals = [[1,3],[2,6],[8,10],[15,18]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[1,6],[8,10],[15,18]]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 区间 &lt;code&gt;[1,3]&lt;/code&gt; 和 &lt;code&gt;[2,6]&lt;/code&gt; 重叠, 将它们合并为 &lt;code&gt;[1,6]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;intervals = [[1,4],[4,5]]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[1,5]]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 区间 &lt;code&gt;[1,4]&lt;/code&gt; 和 &lt;code&gt;[4,5]&lt;/code&gt; 可被视为重叠区间。&lt;/p&gt;
&lt;h2 id=&#34;核心思路排序--贪心&#34;&gt;核心思路：排序 + 贪心&lt;/h2&gt;
&lt;p&gt;区间问题最常见的痛点在于：输入的区间可能是乱序的。如果乱序处理，我们需要两两比较，复杂度会飙升到 $O(N^2)$。&lt;/p&gt;
&lt;p&gt;解决此类问题的&amp;quot;银弹&amp;quot;通常是&lt;strong&gt;先排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 预处理：排序&lt;/strong&gt;
我们首先按照区间的**左端点（Start Time）**进行从小到大的排序。
排序后，重叠的区间在数组中一定是相邻的。这使得我们只需要进行一次线性扫描就能完成合并。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 遍历与合并&lt;/strong&gt;
我们维护一个结果集 &lt;code&gt;res&lt;/code&gt;，并遍历排序后的区间列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始状态&lt;/strong&gt;：如果 &lt;code&gt;res&lt;/code&gt; 为空，直接将当前区间加入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无重叠&lt;/strong&gt;：如果当前区间的&lt;strong&gt;左端点&lt;/strong&gt;大于结果集中最后一个区间的&lt;strong&gt;右端点&lt;/strong&gt;，说明它们断开了，没有交集。直接将当前区间加入 &lt;code&gt;res&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有重叠&lt;/strong&gt;：如果当前区间的&lt;strong&gt;左端点&lt;/strong&gt;小于等于结果集中最后一个区间的&lt;strong&gt;右端点&lt;/strong&gt;，说明发生了重叠（或者通过端点相连）。
&lt;ul&gt;
&lt;li&gt;此时我们需要&lt;strong&gt;合并&lt;/strong&gt;：更新结果集中最后一个区间的右端点。&lt;/li&gt;
&lt;li&gt;新的右端点应该是两者右端点的最大值：&lt;code&gt;max(last_interval.end, current_interval.end)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码实现-java&#34;&gt;代码实现 (Java)&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[][]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[][]&lt;/span&gt; intervals) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 边界检查&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (intervals.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 核心步骤 1：按照区间左端点进行排序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 这一步将 O(N^2) 的两两比较降低为 O(N) 的线性扫描&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(intervals, (i1, i2) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; i1&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i2&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&amp;gt;&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; intervals.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; intervals&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; intervals&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 核心步骤 2：判断是否重叠&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果结果集为空，或者当前区间的左端点 &amp;gt; 结果集最后一个区间的右端点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 说明无重叠，直接添加&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (res.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; res.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1)&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; l) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                res.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;{l, r});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 发生重叠，合并区间&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 更新结果集最后一个区间的右端点，取两者最大值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                res.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1)&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1)&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;, r);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 转换回题目要求的 int[][] 格式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res.&lt;span style=&#34;color:#a6e22e&#34;&gt;toArray&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;res.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度: $O(N \log N)$。虽然遍历是一次线性的 $O(N)$，但排序的开销是 $O(N \log N)$，它是整个算法的瓶颈。&lt;/li&gt;
&lt;li&gt;空间复杂度: $O(\log N)$。这里指的是 Java 排序算法（通常是快排或归并排序的变种）所需的栈空间。如果算上存储结果的 res 列表，则是 $O(N)$。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>【HOT100/双指针】LeetCode 15. 三数之和</title>
      <link>https://amemiya02.github.io/posts/2025-12-17-15-3sum/</link>
      <pubDate>Wed, 17 Dec 2025 19:25:00 +0900</pubDate>
      <guid>https://amemiya02.github.io/posts/2025-12-17-15-3sum/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，判断是否存在三元组 &lt;code&gt;[nums[i], nums[j], nums[k]]&lt;/code&gt; 满足 &lt;code&gt;i != j&lt;/code&gt;、&lt;code&gt;i != k&lt;/code&gt; 且 &lt;code&gt;j != k&lt;/code&gt; ，同时还满足 &lt;code&gt;nums[i] + nums[j] + nums[k] == 0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;请你返回所有和为 &lt;code&gt;0&lt;/code&gt; 且不重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [-1,0,1,2,-1,-4]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;[[-1,-1,2],[-1,0,1]]&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt;
不同的三元组是 &lt;code&gt;[-1,0,1]&lt;/code&gt; 和 &lt;code&gt;[-1,-1,2]&lt;/code&gt; 。
注意，输出的顺序和三元组的顺序并不重要。&lt;/p&gt;
&lt;h2 id=&#34;核心思路排序--双指针&#34;&gt;核心思路：排序 + 双指针&lt;/h2&gt;
&lt;p&gt;这道题是“两数之和”的进阶版。如果直接使用三重循环暴力求解，时间复杂度为 $O(n^3)$，这显然会超时。我们需要寻找 $O(n^2)$ 级别的解法。&lt;/p&gt;
&lt;h3 id=&#34;1-为什么先排序&#34;&gt;1. 为什么先排序？&lt;/h3&gt;
&lt;p&gt;排序是解决这道题的关键步骤（通常花费 $O(n \log n)$）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;便于双指针操作&lt;/strong&gt;：排序后，我们可以利用单调性，通过移动左右指针来调整两数之和的大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;便于去重&lt;/strong&gt;：题目要求不包含重复的三元组。排序后，相同的元素会相邻，我们在遍历时很容易判断并跳过重复元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-算法流程&#34;&gt;2. 算法流程&lt;/h3&gt;
&lt;p&gt;我们将三数之和问题转化为：&lt;strong&gt;固定一个数 &lt;code&gt;nums[i]&lt;/code&gt;，在剩下的数组中寻找两个数，使它们的和等于 &lt;code&gt;-nums[i]&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;特判&lt;/strong&gt;：如果数组为空或长度小于3，直接返回空列表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排序&lt;/strong&gt;：对数组进行升序排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遍历&lt;/strong&gt;：枚举第一个数 &lt;code&gt;nums[i]&lt;/code&gt;（索引 &lt;code&gt;i&lt;/code&gt; 从 0 到 &lt;code&gt;n-2&lt;/code&gt;）：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;剪枝优化&lt;/strong&gt;：因为数组已排序，如果 &lt;code&gt;nums[i] &amp;gt; 0&lt;/code&gt;，那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外层去重&lt;/strong&gt;：如果 &lt;code&gt;i &amp;gt; 0&lt;/code&gt; 且 &lt;code&gt;nums[i] == nums[i-1]&lt;/code&gt;，说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双指针查找&lt;/strong&gt;：令左指针 &lt;code&gt;L = i + 1&lt;/code&gt;，右指针 &lt;code&gt;R = n - 1&lt;/code&gt;。当 &lt;code&gt;L &amp;lt; R&lt;/code&gt; 时：
&lt;ul&gt;
&lt;li&gt;计算 sum = &lt;code&gt;nums[i] + nums[L] + nums[R]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;若 sum == 0&lt;/strong&gt;：找到一组解，加入结果集。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内层去重&lt;/strong&gt;：为了防止结果重复，需要将 &lt;code&gt;L&lt;/code&gt; 向右移过所有重复值，将 &lt;code&gt;R&lt;/code&gt; 向左移过所有重复值。&lt;/li&gt;
&lt;li&gt;移动指针：&lt;code&gt;L++&lt;/code&gt;, &lt;code&gt;R--&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;若 sum &amp;lt; 0&lt;/strong&gt;：说明和太小，需要变大，因此 &lt;code&gt;L++&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;若 sum &amp;gt; 0&lt;/strong&gt;：说明和太大，需要变小，因此 &lt;code&gt;R--&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-去重的细节&#34;&gt;3. 去重的细节&lt;/h3&gt;
&lt;p&gt;这道题最容易出错的地方就是去重。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
