<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>分治 on 个人技术博客</title>
    <link>http://localhost:1313/tags/%E5%88%86%E6%B2%BB/</link>
    <description>Recent content in 分治 on 个人技术博客</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 02 Jan 2026 15:10:00 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%88%86%E6%B2%BB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【HOT100/动态规划】LeetCode 53. 最大子数组和</title>
      <link>http://localhost:1313/posts/2026-01-02-53-maximum-subarray/</link>
      <pubDate>Fri, 02 Jan 2026 15:10:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2026-01-02-53-maximum-subarray/</guid>
      <description>&lt;h2 id=&#34;题目回顾&#34;&gt;题目回顾&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;6&lt;/code&gt;
&lt;strong&gt;解释：&lt;/strong&gt; 连续子数组 &lt;code&gt;[4,-1,2,1]&lt;/code&gt; 的和最大，为 &lt;code&gt;6&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [1]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; &lt;code&gt;nums = [5,4,-1,7,8]&lt;/code&gt;
&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;23&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;核心思路动态规划与贪心&#34;&gt;核心思路：动态规划与贪心&lt;/h2&gt;
&lt;p&gt;这道题是**动态规划（Dynamic Programming）**的经典入门题。&lt;/p&gt;
&lt;p&gt;如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 $O(N^2)$，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。&lt;/p&gt;
&lt;h3 id=&#34;状态定义&#34;&gt;状态定义&lt;/h3&gt;
&lt;p&gt;我们要思考：&lt;strong&gt;以当前数字 &lt;code&gt;nums[i]&lt;/code&gt; 结尾的子数组，它的最大和是多少？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;dp[i]&lt;/code&gt; 表示以 &lt;code&gt;nums[i]&lt;/code&gt; &lt;strong&gt;结尾&lt;/strong&gt;的连续子数组的最大和。那么对于 &lt;code&gt;nums[i]&lt;/code&gt; 来说，它面临两个选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;加入前面的队伍&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是正数，那么加上它肯定比自己单干强，即 &lt;code&gt;dp[i-1] + nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;另起炉灶&lt;/strong&gt;：如果前面的子数组和 &lt;code&gt;dp[i-1]&lt;/code&gt; 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 &lt;code&gt;nums[i]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;状态转移方程&#34;&gt;状态转移方程&lt;/h3&gt;
&lt;p&gt;根据上述分析，我们可以得到状态转移方程：
$$
dp[i] = \max(dp[i-1] + \text{nums}[i], \text{nums}[i])
$$&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
