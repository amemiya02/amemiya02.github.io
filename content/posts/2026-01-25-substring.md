---
title: "[Golang] LeetCode 热题 100 - 子串"
date: 2026-01-25 10:00:00 +0900
categories: [算法, LeetCode]
tags: [Go, 子串, 题解]
---
# 子串

## [560. 和为 K 的子数组 - Mid](https://leetcode.cn/problems/subarray-sum-equals-k/)



### 题目回顾

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 **该数组中和为 `k` 的子数组的个数** 。
>
> 子数组是数组中元素的连续非空序列。

**示例 1：**

**输入：** `nums = [1,1,1], k = 2`
**输出：** `2`

**示例 2：**

**输入：** `nums = [1,2,3], k = 3`
**输出：** `2`

### 核心思路：前缀和 + 哈希表优化

这道题如果使用暴力解法，枚举所有的子数组并计算和，时间复杂度会达到 $O(n^2)$ 甚至 $O(n^3)$，无法通过所有测试用例。我们需要利用**前缀和**的性质进行优化。

#### 1. 前缀和转化
定义 `pre[i]` 为 `[0..i]` 里所有数的和。那么 `[j..i]` 这个子数组的和可以表示为：
$$
sum[j..i] = pre[i] - pre[j-1]
$$
题目要求找到和为 `k` 的子数组，即寻找满足以下条件的 `j` 和 `i`：
$$
pre[i] - pre[j-1] == k
$$
移项得：
$$
pre[j-1] == pre[i] - k
$$

#### 2. 哈希表优化
这意味着，当我们遍历到位置 `i` 时，我们需要统计**在 `i` 之前**，有多少个位置 `j-1` 的前缀和等于 `pre[i] - k`。

为了快速查找和统计，我们可以使用一个 **哈希表 (HashMap)**：
* **Key**: 前缀和的值。
* **Value**: 该前缀和出现的次数。

#### 3. 算法流程
1.  初始化变量 `sum = 0` (当前前缀和) 和 `count = 0` (结果计数)。
2.  初始化哈希表 `map`，并**预先插入 `map.put(0, 1)`**。
    * **重点解释**：这是为了处理那些从数组下标 0 开始的子数组。如果某个子数组就是 `nums[0..i]` 且和为 `k`，那么 `pre[i] - k` 将等于 `0`。我们需要保证这种情况下能找到匹配项。
3.  遍历数组 `nums`：
    * 累加计算当前前缀和 `sum`。
    * 查询 `map` 中是否存在 `sum - k`。如果存在，说明找到了对应个数的子数组，将 `map.get(sum - k)` 累加到 `count` 中。
    * 将当前的 `sum` 存入 `map`，更新其出现次数。

### 代码实现

```go

func subarraySum(nums []int, k int) int {
	// countMap: key 是前缀和, value 是该前缀和出现的次数
	countMap := make(map[int]int)

	// 初始化：前缀和为 0 默认出现 1 次
	// 这是为了处理从数组第一个元素开始就满足和为 k 的情况
	countMap[0] = 1

	count := 0
	preSum := 0

	for _, num := range nums {
		preSum += num

		// 如果 preSum - k 在 map 中存在，说明从某个旧的前缀和到当前位置的子数组和为 k
		if v, ok := countMap[preSum-k]; ok {
			count += v
		}

		// 更新当前前缀和出现的次数
		countMap[preSum]++
	}

	return count
}


```

**复杂度分析**
- 时间复杂度: $O(n)$。我们只需要遍历数组一次，哈希表的插入和查询操作平均时间复杂度为 $O(1)$。
- 空间复杂度: $O(n)$。哈希表在最坏情况下（所有前缀和都不同）需要存储 n 个键值对。

## [239. 滑动窗口最大值 - Hard](https://leetcode.cn/problems/sliding-window-maximum/)

### 题目回顾


> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回滑动窗口中的最大值。

**示例：**

**输入：** `nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`
**输出：** `[3,3,5,5,6,7]`
**解释：**
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

---

### 核心思路：单调队列（Monotonic Deque）

本题的难点在于：**如何在 O(1) 时间内动态维护滑动窗口的最大值？**

若对每个窗口都遍历求最大值，时间复杂度为 $O(nk)$，在 `k` 较大时会超时（`n = 10⁵` 级别）。我们需要一种能“快速淘汰无用元素 + 快速获取最大值”的数据结构。

#### ✅ 单调递减队列（从队首到队尾：值递减，存储下标）

- **队首**：始终是当前窗口中的**最大值对应下标**
- **队尾**：用于插入新元素，并在插入前**弹出所有比它小的元素**（因为这些元素不可能成为后续窗口的最大值——它们更小、且更早被移出窗口）

#### 为什么可以弹出“比当前元素小的”？
> 假设 `j < i` 且 `nums[j] ≤ nums[i]`，那么对于**所有包含 `i` 的后续窗口**，`nums[j]` 都不可能成为最大值：
> - 它比 `nums[i]` 小
> - 它比 `nums[i]` 更早离开窗口
> → `j` 是“无用”的，可安全丢弃。

#### 算法流程

1. 初始化一个**双端队列 `q`**（Deque），用于存储**下标**，维护窗口内元素对应的下标单调递减（对应值单调递减）。
2. 先处理前 `k` 个元素（第一个窗口）：
   - 入队前，从队尾弹出所有 `nums[q.peekLast()] < nums[i]` 的下标；
   - 将当前下标 `i` 入队尾。
   - 此时队首即为第一个窗口最大值下标。
3. 从 `i = k` 开始滑动窗口：
   - **维护队列单调性**：从队尾弹出所有小于 `nums[i]` 的元素；
   - **移除过期元素**：若队首下标 `≤ i - k`（已不在窗口内），则从队首弹出；
   - 将 `i` 入队尾；
   - 当前窗口最大值为 `nums[q.peekFirst()]`，存入结果数组。

> ⚠️ 注意：**队列中存的是下标而非值**，便于判断元素是否过期。

---

### 代码实现

```go
func maxSlidingWindow(nums []int, k int) []int {
    // 边界条件处理
    if len(nums) == 0 || k == 0 {
        return nil
    }

    n := len(nums)
    // 预分配结果数组，容量为 n-k+1
    res := make([]int, 0, n-k+1)

    // q 是单调队列，仅存储数组的【下标】
    // 保证队列头部 q[0] 对应的数值 nums[q[0]] 永远是当前窗口的最大值
    q := []int{}

    for i, v := range nums {
        // 1. 维护单调性（递减）：
        // 如果队尾元素对应的值小于当前值 v，说明队尾元素不可能是最大值了，弹出
        for len(q) > 0 && nums[q[len(q)-1]] < v {
            q = q[:len(q)-1] // 弹出队尾
        }

        // 2. 入队：将当前元素下标加入队尾
        q = append(q, i)

        // 3. 移除过期元素：
        // 检查队首下标是否已经滑出窗口范围 (应当 > i-k)
        if q[0] <= i-k {
            q = q[1:] // 弹出队首
        }

        // 4. 记录结果：
        // 当窗口完全形成（下标 i >= k-1）时，队首即为当前窗口最大值
        if i >= k-1 {
            res = append(res, nums[q[0]])
        }
    }

    return res
}
```

**复杂度分析**
- 时间复杂度： O(n). 每个元素最多入队一次、出队一次，总操作数为 2n，均摊 O(1)。
- 空间复杂度： O(k). 队列中最多存放 k 个元素（窗口大小）。

## 76. [最小覆盖子串 - Hard](https://leetcode.cn/problems/minimum-window-substring/)


### 题目回顾

> 给定两个字符串 `s` 和 `t`，长度分别是 `m` 和 `n`，返回 `s` 中的 **最短窗口** 子串，使得该子串包含 `t` 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 `""`。
>
> 测试用例保证答案唯一。

**示例：**

**输入：** `s = "ADOBECODEBANC"`, `t = "ABC"`
**输出：** `"BANC"`
**解释：** 最小覆盖子串 `"BANC"` 包含 `t` 中所有字符 `'A'`, `'B'`, `'C'`。

---

### 核心思路：滑动窗口 + 哈希计数

本题是「滑动窗口」的经典应用，核心目标是：在 `s` 中找到一个**最短连续子串**，使其**字符频次 ≥ `t` 的字符频次**（即完全覆盖 `t`）。

#### 关键观察点：
1. **窗口有效性判定**：不能只看字符是否出现，而要看**频次是否足够**。例如 `t = "AAB"`，窗口中至少要有 2 个 `'A'` 和 1 个 `'B'`。
2. **扩展与收缩策略**：
   - **右指针 `r` 扩展窗口**：直到窗口**首次满足覆盖条件**；
   - **左指针 `l` 收缩窗口**：在满足条件的前提下，尽可能缩小窗口，尝试找到更优解；
   - 重复上述过程，维护全局最小窗口。

#### 实现细节：
改用「需匹配字符种类数」+「当前达标种类数」实现 O(1) 判断

---

### 代码实现

```java

func minWindow(s string, t string) string {
    // 边界检查
    if len(s) < len(t) {
        return ""
    }

    // 1. 频次统计
    //由于是 ASCII 字符，使用数组代替 map 性能更高 (index 0-127)
    need := [128]int{}
    for i := 0; i < len(t); i++ {
        need[t[i]]++
    }

    // needCnt: 还需要匹配多少个字符才能完全覆盖 t
    needCnt := len(t)

    // 记录最小覆盖子串的起始位置和长度
    start, minLen := 0, len(s)+1

    // 滑动窗口：[l, r) 左闭右开区间
    l, r := 0, 0

    for r < len(s) {
        // === 1. 进窗口逻辑 ===
        ch := s[r]
        // 如果当前字符 ch 是 t 中需要的 (即 need[ch] > 0)，
        // 那么我们将 needCnt 减 1，表示"还缺少的字符数"少了一个
        if need[ch] > 0 {
            needCnt--
        }
        // 无论是否需要，都将该字符在 need 数组中的计数减 1
        // need[ch] > 0 表示还缺这个字符
        // need[ch] <= 0 表示窗口内该字符已经足够，甚至多余了 (负数表示多余个数)
        need[ch]--
        r++

        // === 2. 窗口满足条件，尝试收缩左边界 ===
        // needCnt == 0 意味着 t 中所有字符都已被覆盖
        for needCnt == 0 {
            // 更新最小结果
            if r-l < minLen {
                minLen = r - l
                start = l
            }

            // === 3. 出窗口逻辑 ===
            removeChar := s[l]
            // 恢复 need 数组计数
            need[removeChar]++

            // 核心逻辑：判断是否破坏了覆盖条件
            // 如果 need[removeChar] 变回 > 0，说明刚才移除的那个字符是"必须"的，
            // 且移除后窗口内数量不足了，所以 needCnt + 1
            if need[removeChar] > 0 {
                needCnt++
            }
            l++
        }
    }

    if minLen == len(s)+1 {
        return ""
    }
    return s[start : start+minLen]
}

```

**复杂度分析**

- 时间复杂度: `O(m+n)`
  其中 `m = s.length()`, `n = t.length()`

- 空间复杂度: `O(1)`



