---
title: "[Golang] LeetCode 热题 100 - 普通数组"
date: 2026-01-26 9:00:00 +0900
categories: [算法, LeetCode]
tags: [Go, 普通数组, 题解, 动态规划, 贪心]
---
# 普通数组

## [53. 最大子数组和 - Mid](https://leetcode.cn/problems/maximum-subarray/)

### 题目回顾

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。

**示例 1：**

**输入：** `nums = [-2,1,-3,4,-1,2,1,-5,4]`
**输出：** `6`
**解释：** 连续子数组 `[4,-1,2,1]` 的和最大，为 `6` 。

**示例 2：**

**输入：** `nums = [1]`
**输出：** `1`

**示例 3：**

**输入：** `nums = [5,4,-1,7,8]`
**输出：** `23`

### 核心思路：动态规划与贪心

这道题是**动态规划**的经典入门题。

如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 $O(N^2)$，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。

#### 状态定义
我们要思考：**以当前数字 `nums[i]` 结尾的子数组，它的最大和是多少？**

假设 `dp[i]` 表示以 `nums[i]` **结尾**的连续子数组的最大和。那么对于 `nums[i]` 来说，它面临两个选择：
1.  **加入前面的队伍**：如果前面的子数组和 `dp[i-1]` 是正数，那么加上它肯定比自己单干强，即 `dp[i-1] + nums[i]`。
2.  **另起炉灶**：如果前面的子数组和 `dp[i-1]` 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 `nums[i]`。

#### 状态转移方程
根据上述分析，我们可以得到状态转移方程：


These are block equations:

$$
dp[i] = \max(dp[i-1] + \text{nums}[i], \text{nums}[i])
$$


#### 空间优化
观察转移方程发现，当前状态 `dp[i]` 只与前一个状态 `dp[i-1]` 有关。因此，我们不需要维护一个完整的 `dp` 数组，只需要用一个变量 `pre` 来记录"前一个位置的最大子数组和"即可。这也就是代码中 `pre` 变量的作用。

这种一边遍历一边做决策（如果收益为负则舍弃）的思想，也体现了**贪心算法**的影子。

### 代码实现

```go
func maxSubArray(nums []int) int {
    pre := 0
    maxAns := nums[0]

    for _, x := range nums {
        pre = max(pre+x, x)
        maxAns = max(pre, maxAns)
    }
    return maxAns
}


```

**复杂度分析**
- 时间复杂度: $O(N)$。我们只需要遍历数组一次
- 空间复杂度: $O(1)$。我们只使用了常数个变量，没有使用额外的数组空间（如果使用标准的 DP 数组则是 $O(N)$）。

## [56. 合并区间 - Mid](https://leetcode.cn/problems/merge-intervals/)


### 题目回顾

> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start_i, end_i]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：**

**输入：** `intervals = [[1,3],[2,6],[8,10],[15,18]]`
**输出：** `[[1,6],[8,10],[15,18]]`
**解释：** 区间 `[1,3]` 和 `[2,6]` 重叠, 将它们合并为 `[1,6]`.

**示例 2：**

**输入：** `intervals = [[1,4],[4,5]]`
**输出：** `[[1,5]]`
**解释：** 区间 `[1,4]` 和 `[4,5]` 可被视为重叠区间。

### 核心思路：排序 + 贪心

区间问题最常见的痛点在于：输入的区间可能是乱序的。如果乱序处理，我们需要两两比较，复杂度会飙升到 $O(N^2)$。

解决此类问题的"银弹"通常是**先排序**.


**1. 预处理：排序**
我们首先按照区间的**左端点（Start Time）**进行从小到大的排序。
排序后，重叠的区间在数组中一定是相邻的。这使得我们只需要进行一次线性扫描就能完成合并。

**2. 遍历与合并**
我们维护一个结果集 `res`，并遍历排序后的区间列表：

* **初始状态**：如果 `res` 为空，直接将当前区间加入。
* **无重叠**：如果当前区间的**左端点**大于结果集中最后一个区间的**右端点**，说明它们断开了，没有交集。直接将当前区间加入 `res`。
* **有重叠**：如果当前区间的**左端点**小于等于结果集中最后一个区间的**右端点**，说明发生了重叠（或者通过端点相连）。
    * 此时我们需要**合并**：更新结果集中最后一个区间的右端点。
    * 新的右端点应该是两者右端点的最大值：`max(last_interval.end, current_interval.end)`。

### 代码实现

```go
func merge(intervals [][]int) [][]int {
	// 边界检查：如果为空直接返回
	if len(intervals) == 0 {
		return nil
	}

	// 1. 按照区间左端点进行排序
	// 使用 sort.Slice 进行排序，传入 less 函数
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

	// res 用于存储合并后的结果
	// 预分配 capacity 可以略微提升性能，但不是必须的
	var res [][]int

	// 2. 遍历排序后的区间
	for _, interval := range intervals {
		l, r := interval[0], interval[1]

		// 如果结果集为空，或者当前区间的左端点 > 结果集最后一个区间的右端点
		// 说明没有重叠，直接添加新的区间
		if len(res) == 0 || l > res[len(res)-1][1] {
			res = append(res, []int{l, r})
		} else {
			// 发生重叠，我们需要合并区间
			// 修改结果集中最后一个区间的右端点：取 max(当前右端点, 存量右端点)
			if r > res[len(res)-1][1] {
				res[len(res)-1][1] = r
			}
		}
	}

	return res
}

```
**复杂度分析**

- 时间复杂度: $O(N \log N)$。虽然遍历是一次线性的 $O(N)$，但排序的开销是 $O(N \log N)$，它是整个算法的瓶颈。
- 空间复杂度: $O(\log N)$。这里指的是 Java 排序算法（通常是快排或归并排序的变种）所需的栈空间。如果算上存储结果的 res 列表，则是 $O(N)$。

## [189. 轮转数组 - Mid](https://leetcode.cn/problems/rotate-array/)



### 题目回顾

> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

**输入:** `nums = [1,2,3,4,5,6,7], k = 3`
**输出:** `[5,6,7,1,2,3,4]`
**解释:**
向右轮转 1 步: `[7,1,2,3,4,5,6]`
向右轮转 2 步: `[6,7,1,2,3,4,5]`
向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

**输入：** `nums = [-1,-100,3,99], k = 2`
**输出：** `[3,99,-1,-100]`

### 核心思路：三次翻转法

这道题最直观的解法是使用一个额外的数组，将每个元素放到正确的位置，但这需要 $O(N)$ 的空间。
如果要求原地算法（$O(1)$ 空间），最经典且容易理解的方法是**数组翻转法**。



我们可以观察一下规律，以 `nums = [1,2,3,4,5,6,7], k = 3` 为例：

1.  **原始数组**：`[1, 2, 3, 4, 5, 6, 7]`
    我们可以把数组分为两部分：
    * 第一部分（前 `n-k` 个）：`[1, 2, 3, 4]`
    * 第二部分（后 `k` 个）：`[5, 6, 7]` (这部分实际上是要移动到数组头部的)

2.  **第一步：整体翻转**
    将整个数组翻转：
    `[7, 6, 5, 4, 3, 2, 1]`
    此时，原本在尾部的 `[5, 6, 7]` 跑到了头部，但是顺序是反的（`7, 6, 5`）。原本在头部的 `[1, 2, 3, 4]` 跑到了尾部，顺序也是反的（`4, 3, 2, 1`）。

3.  **第二步：翻转前 k 个元素**
    我们将前 `k` 个元素（下标 `0` 到 `k-1`）再次翻转：
    `[5, 6, 7, 4, 3, 2, 1]`
    此时，头部元素顺序恢复正常。

4.  **第三步：翻转剩余元素**
    我们将剩下的元素（下标 `k` 到 `n-1`）再次翻转：
    `[5, 6, 7, 1, 2, 3, 4]`
    此时，尾部元素顺序也恢复正常，得到最终结果。

**注意事项**：
如果 `k` 大于数组长度 `n`，轮转 `k` 次等于轮转 `k % n` 次。所以在开始处理前，需要先执行 `k %= n`。

### 代码实现

```go
func rotate(nums []int, k int) {
    n := len(nums)
    if n == 0 {
        return
    }

    // 处理 k > n 的情况
    // 比如长度 5，轮转 6 次 等于 轮转 1 次
    k %= n

    // 核心逻辑：三次翻转
    // 1. 翻转整个数组
    reverse(nums, 0, n-1)
    // 2. 翻转前 k 个元素
    reverse(nums, 0, k-1)
    // 3. 翻转剩余元素
    reverse(nums, k, n-1)
}

// 辅助函数：翻转 nums 中 [start, end] 区间的元素
func reverse(nums []int, start, end int) {
    for start < end {
        // Go 语言特有的元组赋值（Tuple Assignment），无需临时变量即可交换
        nums[start], nums[end] = nums[end], nums[start]
        start++
        end--
    }
}

```

**复杂度分析**
- 时间复杂度: $O(N)$。我们需要遍历数组三次（一次整体，两次局部），每次操作都是线性的，总时间复杂度为 $O(N)$。
- 空间复杂度: $O(1)$。我们只使用了常数个额外变量进行交换操作，没有使用额外的数组空间。
