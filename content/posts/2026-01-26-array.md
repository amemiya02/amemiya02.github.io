---
title: "[Golang] LeetCode 热题 100 - 普通数组"
date: 2026-01-26 9:00:00 +0900
categories: [算法, LeetCode]
tags: [Go, 普通数组, 题解, 动态规划, 贪心]
---
# 普通数组

## [53. 最大子数组和 - Mid](https://leetcode.cn/problems/maximum-subarray/)

### 题目回顾

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。

**示例 1：**

**输入：** `nums = [-2,1,-3,4,-1,2,1,-5,4]`
**输出：** `6`
**解释：** 连续子数组 `[4,-1,2,1]` 的和最大，为 `6` 。

**示例 2：**

**输入：** `nums = [1]`
**输出：** `1`

**示例 3：**

**输入：** `nums = [5,4,-1,7,8]`
**输出：** `23`

### 核心思路：动态规划与贪心

这道题是**动态规划**的经典入门题。

如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 $O(N^2)$，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。

#### 状态定义

我们要思考：**以当前数字 `nums[i]` 结尾的子数组，它的最大和是多少？**

假设 `dp[i]` 表示以 `nums[i]` **结尾**的连续子数组的最大和。那么对于 `nums[i]` 来说，它面临两个选择：

1. **加入前面的队伍**：如果前面的子数组和 `dp[i-1]` 是正数，那么加上它肯定比自己单干强，即 `dp[i-1] + nums[i]`。
2. **另起炉灶**：如果前面的子数组和 `dp[i-1]` 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 `nums[i]`。

#### 状态转移方程

根据上述分析，我们可以得到状态转移方程：

$$
dp[i] = \max(dp[i-1] + \text{nums}[i], \text{nums}[i])
$$

#### 空间优化

观察转移方程发现，当前状态 `dp[i]` 只与前一个状态 `dp[i-1]` 有关。因此，我们不需要维护一个完整的 `dp` 数组，只需要用一个变量 `pre` 来记录"前一个位置的最大子数组和"即可。这也就是代码中 `pre` 变量的作用。

这种一边遍历一边做决策（如果收益为负则舍弃）的思想，也体现了**贪心算法**的影子。

### 代码实现

```go
func maxSubArray(nums []int) int {
    pre := 0
    maxAns := nums[0]

    for _, x := range nums {
        pre = max(pre+x, x)
        maxAns = max(pre, maxAns)
    }
    return maxAns
}


```

**复杂度分析**

- 时间复杂度: $O(N)$。我们只需要遍历数组一次
- 空间复杂度: $O(1)$。我们只使用了常数个变量，没有使用额外的数组空间（如果使用标准的 DP 数组则是 $O(N)$）。

## [56. 合并区间 - Mid](https://leetcode.cn/problems/merge-intervals/)

### 题目回顾

> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start_i, end_i]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：**

**输入：** `intervals = [[1,3],[2,6],[8,10],[15,18]]`
**输出：** `[[1,6],[8,10],[15,18]]`
**解释：** 区间 `[1,3]` 和 `[2,6]` 重叠, 将它们合并为 `[1,6]`.

**示例 2：**

**输入：** `intervals = [[1,4],[4,5]]`
**输出：** `[[1,5]]`
**解释：** 区间 `[1,4]` 和 `[4,5]` 可被视为重叠区间。

### 核心思路：排序 + 贪心

区间问题最常见的痛点在于：输入的区间可能是乱序的。如果乱序处理，我们需要两两比较，复杂度会飙升到 $O(N^2)$。

解决此类问题的"银弹"通常是**先排序**.

**1. 预处理：排序**
我们首先按照区间的**左端点（Start Time）**进行从小到大的排序。
排序后，重叠的区间在数组中一定是相邻的。这使得我们只需要进行一次线性扫描就能完成合并。

**2. 遍历与合并**
我们维护一个结果集 `res`，并遍历排序后的区间列表：

- **初始状态**：如果 `res` 为空，直接将当前区间加入。
- **无重叠**：如果当前区间的**左端点**大于结果集中最后一个区间的**右端点**，说明它们断开了，没有交集。直接将当前区间加入 `res`。
- **有重叠**：如果当前区间的**左端点**小于等于结果集中最后一个区间的**右端点**，说明发生了重叠（或者通过端点相连）。
  - 此时我们需要**合并**：更新结果集中最后一个区间的右端点。
  - 新的右端点应该是两者右端点的最大值：`max(last_interval.end, current_interval.end)`。

### 代码实现

```go
func merge(intervals [][]int) [][]int {
    // 边界检查：如果为空直接返回
    if len(intervals) == 0 {
        return nil
    }

    // 1. 按照区间左端点进行排序
    // 使用 sort.Slice 进行排序，传入 less 函数
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    // res 用于存储合并后的结果
    // 预分配 capacity 可以略微提升性能，但不是必须的
    var res [][]int

    // 2. 遍历排序后的区间
    for _, interval := range intervals {
        l, r := interval[0], interval[1]

        // 如果结果集为空，或者当前区间的左端点 > 结果集最后一个区间的右端点
        // 说明没有重叠，直接添加新的区间
        if len(res) == 0 || l > res[len(res)-1][1] {
            res = append(res, []int{l, r})
        } else {
            // 发生重叠，我们需要合并区间
            // 修改结果集中最后一个区间的右端点：取 max(当前右端点, 存量右端点)
            if r > res[len(res)-1][1] {
                res[len(res)-1][1] = r
            }
        }
    }

    return res
}

```

**复杂度分析**

- 时间复杂度: $O(N \log N)$。虽然遍历是一次线性的 $O(N)$，但排序的开销是 $O(N \log N)$，它是整个算法的瓶颈。
- 空间复杂度: $O(\log N)$。这里指的是 Java 排序算法（通常是快排或归并排序的变种）所需的栈空间。如果算上存储结果的 res 列表，则是 $O(N)$。

## [189. 轮转数组 - Mid](https://leetcode.cn/problems/rotate-array/)

### 题目回顾

> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

**输入:** `nums = [1,2,3,4,5,6,7], k = 3`
**输出:** `[5,6,7,1,2,3,4]`
**解释:**
向右轮转 1 步: `[7,1,2,3,4,5,6]`
向右轮转 2 步: `[6,7,1,2,3,4,5]`
向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

**输入：** `nums = [-1,-100,3,99], k = 2`
**输出：** `[3,99,-1,-100]`

### 核心思路：三次翻转法

这道题最直观的解法是使用一个额外的数组，将每个元素放到正确的位置，但这需要 $O(N)$ 的空间。
如果要求原地算法（$O(1)$ 空间），最经典且容易理解的方法是**数组翻转法**。

我们可以观察一下规律，以 `nums = [1,2,3,4,5,6,7], k = 3` 为例：

1. **原始数组**：`[1, 2, 3, 4, 5, 6, 7]`
    我们可以把数组分为两部分：
    - 第一部分（前 `n-k` 个）：`[1, 2, 3, 4]`
    - 第二部分（后 `k` 个）：`[5, 6, 7]` (这部分实际上是要移动到数组头部的)

2. **第一步：整体翻转**
    将整个数组翻转：
    `[7, 6, 5, 4, 3, 2, 1]`
    此时，原本在尾部的 `[5, 6, 7]` 跑到了头部，但是顺序是反的（`7, 6, 5`）。原本在头部的 `[1, 2, 3, 4]` 跑到了尾部，顺序也是反的（`4, 3, 2, 1`）。

3. **第二步：翻转前 k 个元素**
    我们将前 `k` 个元素（下标 `0` 到 `k-1`）再次翻转：
    `[5, 6, 7, 4, 3, 2, 1]`
    此时，头部元素顺序恢复正常。

4. **第三步：翻转剩余元素**
    我们将剩下的元素（下标 `k` 到 `n-1`）再次翻转：
    `[5, 6, 7, 1, 2, 3, 4]`
    此时，尾部元素顺序也恢复正常，得到最终结果。

**注意事项**：
如果 `k` 大于数组长度 `n`，轮转 `k` 次等于轮转 `k % n` 次。所以在开始处理前，需要先执行 `k %= n`。

### 代码实现

```go
func rotate(nums []int, k int) {
    n := len(nums)
    if n == 0 {
        return
    }

    // 处理 k > n 的情况
    // 比如长度 5，轮转 6 次 等于 轮转 1 次
    k %= n

    // 核心逻辑：三次翻转
    // 1. 翻转整个数组
    reverse(nums, 0, n-1)
    // 2. 翻转前 k 个元素
    reverse(nums, 0, k-1)
    // 3. 翻转剩余元素
    reverse(nums, k, n-1)
}

// 辅助函数：翻转 nums 中 [start, end] 区间的元素
func reverse(nums []int, start, end int) {
    for start < end {
        // Go 语言特有的元组赋值（Tuple Assignment），无需临时变量即可交换
        nums[start], nums[end] = nums[end], nums[start]
        start++
        end--
    }
}

```

**复杂度分析**

- 时间复杂度: $O(N)$。我们需要遍历数组三次（一次整体，两次局部），每次操作都是线性的，总时间复杂度为 $O(N)$。
- 空间复杂度: $O(1)$。我们只使用了常数个额外变量进行交换操作，没有使用额外的数组空间。

## [238. 除了自身以外数组的乘积 - Mid](https://leetcode.cn/problems/product-of-array-except-self/)



### 题目回顾

> 给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除了 `nums[i]` 之外其余各元素的乘积。
>
> 题目数据 **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。
>
> **请不要使用除法，且在 $O(n)$ 时间复杂度内完成此题。**

**示例 1:**

**输入:** `nums = [1,2,3,4]`
**输出:** `[24,12,8,6]`

**示例 2:**

**输入:** `nums = [-1,1,0,-3,3]`
**输出:** `[0,0,9,0,0]`

### 核心思路：左右乘积列表

这道题如果允许使用除法，那非常简单：算出所有元素的总乘积，然后除以当前元素即可（注意需要处理 0 的情况）。但题目明确禁止除法，我们需要另辟蹊径。

对于数组中的任意一个元素 `nums[i]`，除了它自身以外的乘积，实际上等于：
**（它左边所有元素的乘积） $\times$ （它右边所有元素的乘积）**



因此，我们可以通过两次遍历来解决这个问题：

1.  **计算后缀积**：先算出每个位置**右边**所有元素的乘积。
2.  **计算前缀积并合并**：再算出每个位置**左边**所有元素的乘积，并乘上刚才算好的后缀积。

#### 空间优化 ($O(1)$ 额外空间)

为了满足进阶要求的 $O(1)$ 额外空间（输出数组不计入空间复杂度），我们可以直接利用返回的数组 `answer`（代码中为 `suf`）来作为中间容器。

1.  **第一轮遍历（从右向左）**：
    我们在 `suf` 数组中存储**后缀积**。
    `suf[i]` 表示 `i` 之后所有元素的乘积。
    初始化 `suf[n-1] = 1`（因为最后一个元素右边没有元素）。

2.  **第二轮遍历（从左向右）**：
    我们使用一个变量 `pre` 来动态维护**前缀积**。
    对于每个位置 `i`，`suf[i]` 目前存储的是"右边的积"。
    我们只需要执行 `suf[i] = suf[i] * pre`，就可以得到"右边的积 $\times$ 左边的积"。
    然后更新 `pre`，将其乘上 `nums[i]`，为下一个位置做准备。

这样，我们只需要遍历两次，且不需要额外开辟数组空间。

### 代码实现

```go
func productExceptSelf(nums []int) []int {
    n := len(nums)
    // 初始化结果数组，在 Go 中切片默认值为 0
    res := make([]int, n)

    // 1. 计算后缀积 (Suffix Product)
    // res[i] 存储的是 nums[i] 右侧所有元素的乘积
    res[n-1] = 1
    for i := n - 2; i >= 0; i-- {
        res[i] = res[i+1] * nums[i+1]
    }

    // 2. 计算前缀积 (Prefix Product) 并与后缀积相乘
    // pre 变量动态维护当前位置左侧所有元素的乘积
    pre := 1
    for i := 0; i < n; i++ {
        // 核心公式：结果 = 左侧积 * 右侧积
        res[i] *= pre

        // 为下一次循环更新前缀积（包含当前 nums[i]）
        pre *= nums[i]
    }

    return res
}
```

**复杂度分析**
- 时间复杂度: $O(N)$。我们对数组进行了两次遍历。
- 空间复杂度: $O(1)$。除了用于返回答案的数组 suf 外，我们只使用了常数级别的额外变量（n, pre, i）。

## [41. 缺失的第一个正数 - Hard](https://leetcode.cn/problems/first-missing-positive/)



### 题目回顾

> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
>
> 请你实现时间复杂度为 $O(n)$ 并且只使用常数级别额外空间的解决方案。

**示例 1：**

**输入：** `nums = [1,2,0]`
**输出：** `3`
**解释：** 范围 [1,2] 中的数字都在数组中。

**示例 2：**

**输入：** `nums = [3,4,-1,1]`
**输出：** `2`
**解释：** 1 在数组中，但 2 没有。

**示例 3：**

**输入：** `nums = [7,8,9,11,12]`
**输出：** `1`
**解释：** 最小的正数 1 没有出现。

### 核心思路：原地哈希（萝卜坑）

这道题的难点在于限制条件：**时间 $O(N)$** 且 **空间 $O(1)$**。

* 如果允许 $O(N \log N)$ 时间，我们可以直接排序。
* 如果允许 $O(N)$ 空间，我们可以用 HashSet 记录出现过的数字。

为了满足双重限制，我们需要利用数组本身作为哈希表。

#### 关键推论
对于一个长度为 `N` 的数组，缺失的第一个正数一定在 `[1, N + 1]` 这个范围内。
* 最理想的情况是 `[1, 2, ..., N]` 都出现了，那么缺失的是 `N + 1`。
* 否则，缺失的数字一定在 `[1, N]` 之间。

#### 算法流程
我们可以把数组当作一个个“坑位”。
索引 `0` 的坑应该放数字 `1`。
索引 `1` 的坑应该放数字 `2`。
...
索引 `i` 的坑应该放数字 `i + 1`。

我们的目标就是遍历数组，通过**交换**，尽可能把每个数字放到它该去的坑里。



1.  **归位（交换）**：
    遍历数组，对于当前数字 `x = nums[i]`，如果它满足以下三个条件，就把它交换到正确的位置 `x - 1` 上：
    * `x` 是正数 (`x >= 1`)。
    * `x` 在有效范围内 (`x <= N`)。
    * `x` 还没有呆在正确的位置上 (`nums[x - 1] != x`) —— *这一步同时也避免了死循环（处理重复元素）*。

    注意：交换过来后，新的 `nums[i]` 可能还是需要交换的，所以这里要用 `while` 循环不断交换，直到当前位置无法进行交换为止。

2.  **查找**：
    再次遍历数组，检查每个坑位。如果发现 `nums[i] != i + 1`，说明这个坑位原本该有的数字 `i + 1` 缺失了，直接返回 `i + 1`。

3.  **兜底**：
    如果所有坑位都填满了正确的数字，说明缺失的是 `N + 1`。

### 代码实现

```go
func firstMissingPositive(nums []int) int {
	n := len(nums)

	// 1. 原地哈希 (In-place Hash)
	// 目标：尝试让 nums[i] 存储数字 i + 1
	for i := 0; i < n; i++ {
		// 使用 for 循环（对应 Java 的 while）
		// 如果当前数字 nums[i] 在 [1, n] 范围内，
		// 且它不在它应该在的位置（index 为 nums[i]-1），则进行交换
		for nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i]-1] {
			// Go 的多重赋值特性，可以直接完成交换，无需手动写 swap 函数
			nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
		}
	}

	// 2. 遍历检查
	// 第一个 nums[i] != i + 1 的位置，说明缺失了 i + 1
	for i := 0; i < n; i++ {
		if nums[i] != i + 1 {
			return i + 1
		}
	}

	// 3. 如果 1 到 n 都在正确位置，说明缺失的是 n + 1
	return n + 1
}
```

**复杂度分析**
- 时间复杂度: $O(N)$。初看代码里有 for 循环，似乎是 $O(N^2)$？其实不然。每个数字最多只会被交换一次到它正确的位置上。一旦它到了正确位置，就不会再被移动。因此所有元素的总交换次数不会超过 $N$ 次。均摊下来是 $O(N)$。
- 空间复杂度: $O(1)$。我们直接修改了输入数组，没有使用额外的线性空间。

