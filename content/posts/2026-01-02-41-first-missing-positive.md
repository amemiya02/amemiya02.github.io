---
title: "【HOT100/数组】LeetCode 41. 缺失的第一个正数"
date: 2026-01-02 19:30:00 +0900
categories: [算法, LeetCode]
tags: [数组, 原地哈希]
---

## 题目回顾

> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
>
> 请你实现时间复杂度为 $O(n)$ 并且只使用常数级别额外空间的解决方案。

**示例 1：**

**输入：** `nums = [1,2,0]`
**输出：** `3`
**解释：** 范围 [1,2] 中的数字都在数组中。

**示例 2：**

**输入：** `nums = [3,4,-1,1]`
**输出：** `2`
**解释：** 1 在数组中，但 2 没有。

**示例 3：**

**输入：** `nums = [7,8,9,11,12]`
**输出：** `1`
**解释：** 最小的正数 1 没有出现。

## 核心思路：原地哈希（萝卜坑）

这道题的难点在于限制条件：**时间 $O(N)$** 且 **空间 $O(1)$**。

* 如果允许 $O(N \log N)$ 时间，我们可以直接排序。
* 如果允许 $O(N)$ 空间，我们可以用 HashSet 记录出现过的数字。

为了满足双重限制，我们需要利用数组本身作为哈希表。

### 关键推论
对于一个长度为 `N` 的数组，缺失的第一个正数一定在 `[1, N + 1]` 这个范围内。
* 最理想的情况是 `[1, 2, ..., N]` 都出现了，那么缺失的是 `N + 1`。
* 否则，缺失的数字一定在 `[1, N]` 之间。

### 算法流程
我们可以把数组当作一个个“坑位”。
索引 `0` 的坑应该放数字 `1`。
索引 `1` 的坑应该放数字 `2`。
...
索引 `i` 的坑应该放数字 `i + 1`。

我们的目标就是遍历数组，通过**交换**，尽可能把每个数字放到它该去的坑里。



1.  **归位（交换）**：
    遍历数组，对于当前数字 `x = nums[i]`，如果它满足以下三个条件，就把它交换到正确的位置 `x - 1` 上：
    * `x` 是正数 (`x >= 1`)。
    * `x` 在有效范围内 (`x <= N`)。
    * `x` 还没有呆在正确的位置上 (`nums[x - 1] != x`) —— *这一步同时也避免了死循环（处理重复元素）*。
    
    注意：交换过来后，新的 `nums[i]` 可能还是需要交换的，所以这里要用 `while` 循环不断交换，直到当前位置无法进行交换为止。

2.  **查找**：
    再次遍历数组，检查每个坑位。如果发现 `nums[i] != i + 1`，说明这个坑位原本该有的数字 `i + 1` 缺失了，直接返回 `i + 1`。

3.  **兜底**：
    如果所有坑位都填满了正确的数字，说明缺失的是 `N + 1`。

## 代码实现 (Java)

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        
        // 1. 原地哈希：将数字 x 交换到索引 x-1 的位置
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            
            // 循环条件解析：
            // 1. num >= 1 && num <= n: 数字必须在 [1, n] 范围内，否则不处理
            // 2. num != nums[num - 1]: 目标位置上的数字不等于当前数字（防止死循环和处理重复值）
            while (num >= 1 && num <= n && num != nums[num - 1]) {
                // 将 num 交换到它应该在的位置 num-1
                swap(nums, num - 1, i);
                
                // 更新 num 为交换后当前位置的新值，继续检查是否需要再次交换
                num = nums[i];
            }
        }

        // 2. 遍历检查：找到第一个不满足 nums[i] == i + 1 的位置
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1; // 缺失的就是 i + 1
            }
        }

        // 3. 如果都在正确位置，则缺失的是 n + 1
        return n + 1;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```
## 复杂度分析
- 时间复杂度: $O(N)$。初看代码里有 while 循环，似乎是 $O(N^2)$？其实不然。每个数字最多只会被交换一次到它正确的位置上。一旦它到了正确位置，就不会再被移动。因此所有元素的总交换次数不会超过 $N$ 次。均摊下来是 $O(N)$。
- 空间复杂度: $O(1)$。我们直接修改了输入数组，没有使用额外的线性空间。
