---
title: "【HOT100/矩阵】LeetCode 240. 搜索二维矩阵 II"
date: 2026-01-02 23:00:00 +0900
categories: [算法, LeetCode]
tags: [数组, 矩阵, 二分查找, 分治]
---

## 题目回顾

> 编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：
> * 每行的元素从左到右升序排列。
> * 每列的元素从上到下升序排列。

**示例 1：**


**输入：** `matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5`
**输出：** `true`

**示例 2：**

**输入：** `matrix = ... (同上), target = 20`
**输出：** `false`

## 核心思路：抽象 BST (从角落出发)

如果把矩阵的每一个位置看作一个节点，我们要利用"行有序"和"列有序"这两个条件来快速缩小查找范围。

如果我们从**左上角**出发，当前值小于 `target` 时，我们既可以向右走（变大），也可以向下走（变大），这就产生了歧义，无法确定唯一的搜索方向。

但是，如果我们选择**左下角**（或者右上角）作为起点，情况就完全不同了。

以**左下角** `(m-1, 0)` 为例：
* **当前值 > target**：
    因为当前行是升序的，左下角已经是该行最小的数了，如果连它都比 `target` 大，说明**这一行所有的数都比 `target` 大**。
    -> 结论：**排除当前行**，向上移动 (`i--`)。
* **当前值 < target**：
    因为当前列是升序的，左下角已经是该列最大的数了（在剩下的范围内），如果连它都比 `target` 小，说明**这一列所有的数都比 `target` 小**。
    -> 结论：**排除当前列**，向右移动 (`j++`)。

这个过程就像是在遍历一棵**二叉搜索树 (BST)**，左下角就是根节点，往上走是找更小的（类似左子树），往右走是找更大的（类似右子树）。

### 算法流程
1.  初始化指针 `i` 指向最后一行，`j` 指向第一列。
2.  循环条件：只要 `i` 没有超出上边界，且 `j` 没有超出右边界。
3.  比较 `matrix[i][j]` 和 `target`：
    * 相等：找到目标，返回 `true`。
    * `matrix[i][j] > target`：`i--` (往上找小的)。
    * `matrix[i][j] < target`：`j++` (往右找大的)。
4.  如果循环结束还没找到，返回 `false`。

## 代码实现 (Java)

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;

        // 从左下角开始搜索
        // 行索引 i 初始化为最大，列索引 j 初始化为 0
        int i = m - 1;
        int j = 0;

        // 只要不出界，就继续寻找
        while (i >= 0 && j < n) {
            if (matrix[i][j] == target) {
                // 找到了
                return true;
            } else if (matrix[i][j] > target) {
                // 当前值比目标大，说明这一行右边的都比目标大
                // 所以这一行没戏了，往上移动一行
                i--;
            } else {
                // matrix[i][j] < target
                // 当前值比目标小，说明这一列上边的都比目标小（因为是升序）
                // 所以这一列没戏了，往右移动一列
                j++;
            }
        }

        return false;
    }
}

```

## 复杂度分析
- 时间复杂度: $O(M + N)$。在最坏的情况下（比如目标值就在右上角，或者不存在），我们需要从左下角一路走到右上角。每次迭代要么行索引减少，要么列索引增加，最多移动 m + n 次。
- 空间复杂度: $O(1)$。只使用了常数个变量作为指针。
