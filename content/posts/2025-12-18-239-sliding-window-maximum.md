---
title: "【HOT100/单调队列】LeetCode 239. 滑动窗口最大值"
date: 2025-12-18 15:30:00 +0800
categories: [算法, LeetCode]
tags: [数组, 单调队列, 滑动窗口]
---

## 题目回顾

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回滑动窗口中的最大值。

**示例：**

**输入：** `nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`  
**输出：** `[3,3,5,5,6,7]`  
**解释：**  
滑动窗口的位置                最大值  
---------------               -----  
[1  3  -1] -3  5  3  6  7       3  
 1 [3  -1  -3] 5  3  6  7       3  
 1  3 [-1  -3  5] 3  6  7       5  
 1  3  -1 [-3  5  3] 6  7       5  
 1  3  -1  -3 [5  3  6] 7       6  
 1  3  -1  -3  5 [3  6  7]      7

---

## 核心思路：单调队列（Monotonic Deque）

本题的难点在于：**如何在 O(1) 时间内动态维护滑动窗口的最大值？**

若对每个窗口都遍历求最大值，时间复杂度为 $O(nk)$，在 `k` 较大时会超时（`n = 10⁵` 级别）。我们需要一种能“快速淘汰无用元素 + 快速获取最大值”的数据结构。

### ✅ 单调递减队列（从队首到队尾：值递减，存储下标）

- **队首**：始终是当前窗口中的**最大值对应下标**
- **队尾**：用于插入新元素，并在插入前**弹出所有比它小的元素**（因为这些元素不可能成为后续窗口的最大值——它们更小、且更早被移出窗口）

#### 为什么可以弹出“比当前元素小的”？
> 假设 `j < i` 且 `nums[j] ≤ nums[i]`，那么对于**所有包含 `i` 的后续窗口**，`nums[j]` 都不可能成为最大值：  
> - 它比 `nums[i]` 小  
> - 它比 `nums[i]` 更早离开窗口  
> → `j` 是“无用”的，可安全丢弃。

### 算法流程

1. 初始化一个**双端队列 `q`**（Deque），用于存储**下标**，维护窗口内元素对应的下标单调递减（对应值单调递减）。
2. 先处理前 `k` 个元素（第一个窗口）：
   - 入队前，从队尾弹出所有 `nums[q.peekLast()] < nums[i]` 的下标；
   - 将当前下标 `i` 入队尾。
   - 此时队首即为第一个窗口最大值下标。
3. 从 `i = k` 开始滑动窗口：
   - **维护队列单调性**：从队尾弹出所有小于 `nums[i]` 的元素；
   - **移除过期元素**：若队首下标 `≤ i - k`（已不在窗口内），则从队首弹出；
   - 将 `i` 入队尾；
   - 当前窗口最大值为 `nums[q.peekFirst()]`，存入结果数组。

> ⚠️ 注意：**队列中存的是下标而非值**，便于判断元素是否过期。

---

## 代码实现 (Java)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        // 结果数组长度为 n - k + 1
        int[] res = new int[n - k + 1];
        // 使用双端队列存储下标，维护单调递减（值）
        Deque<Integer> q = new ArrayDeque<>();
        
        // 初始化第一个窗口 [0, k-1]
        for (int i = 0; i < k; i++) {
            // 保持队列单调递减：弹出队尾所有“值 ≤ nums[i]”的下标
            while (!q.isEmpty() && nums[q.peekLast()] < nums[i]) {
                q.pollLast();
            }
            q.offerLast(i);
        }
        res[0] = nums[q.peekFirst()]; // 第一个窗口最大值

        // 滑动窗口：i 为新加入窗口的右端点（从 k 到 n-1）
        for (int i = k; i < n; i++) {
            // 1. 维护单调性：弹出队尾所有比 nums[i] 小的元素
            while (!q.isEmpty() && nums[q.peekLast()] < nums[i]) {
                q.pollLast();
            }
            // 2. 移除队首过期元素（下标 ≤ i - k 的已不在窗口内）
            while (!q.isEmpty() && q.peekFirst() <= i - k) {
                q.pollFirst();
            }
            // 3. 当前下标入队
            q.offerLast(i);
            // 4. 队首即为当前窗口最大值
            res[i - k + 1] = nums[q.peekFirst()];
        }

        return res;
    }
}

```

## 复杂度分析
- 时间复杂度： O(n). 每个元素最多入队一次、出队一次，总操作数为 2n，均摊 O(1)。
- 空间复杂度： O(k). 队列中最多存放 k 个元素（窗口大小）。
