---
title: "【HOT100/矩阵】LeetCode 54. 螺旋矩阵"
date: 2026-01-02 21:30:00 +0900
categories: [算法, LeetCode]
tags: [数组, 矩阵, 模拟]
---

## 题目回顾

> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**


**输入：** `matrix = [[1,2,3],[4,5,6],[7,8,9]]`
**输出：** `[1,2,3,6,9,8,7,4,5]`

**示例 2：**

**输入：** `matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]`
**输出：** `[1,2,3,4,8,12,11,10,9,5,6,7]`

## 核心思路：四边界模拟法

这道题没有太多的算法技巧，本质上是一道**模拟题**。我们需要模拟一个机器人在矩阵中按照"右 -> 下 -> 左 -> 上"的顺序一直走，直到填满所有格子。

虽然思路简单，但如果不加设计地直接写，很容易陷入各种边界判断的泥潭（比如拐角处怎么处理、什么时候停止）。

最优雅的解法是**设定四个边界**：
* `t` (top)：上边界，初始为 `0`
* `b` (bottom)：下边界，初始为 `m-1`
* `l` (left)：左边界，初始为 `0`
* `r` (right)：右边界，初始为 `n-1`

### 算法流程

我们要在一个循环中按照顺时针方向依次处理四条边。每处理完一条边，就将对应的边界向内收缩，并立即检查是否越界（越界意味着遍历结束）。

1.  **向右移动**：遍历从 `l` 到 `r`。处理完后，上边界下移 (`++t`)。如果 `t > b`，说明上下边界交错，遍历结束。
2.  **向下移动**：遍历从 `t` 到 `b`。处理完后，右边界左移 (`--r`)。如果 `l > r`，说明左右边界交错，遍历结束。
3.  **向左移动**：遍历从 `r` 到 `l`。处理完后，下边界上移 (`--b`)。如果 `t > b`，遍历结束。
4.  **向上移动**：遍历从 `b` 到 `t`。处理完后，左边界右移 (`++l`)。如果 `l > r`，遍历结束。

这种写法将边界检查巧妙地融合在每一步操作之后，不需要在循环头部写复杂的 `count < total` 判断，代码逻辑非常清晰。

## 代码实现 (Java)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();

        int m = matrix.length;
        if (m == 0) {
            return res;
        }
        int n = matrix[0].length;

        // 定义四个方向的边界
        int t = 0;      // Top
        int b = m - 1;  // Bottom
        int l = 0;      // Left
        int r = n - 1;  // Right

        while (true) {
            // 1. 从左到右
            for (int i = l; i <= r; i++) {
                res.add(matrix[t][i]);
            }
            // 这一行遍历完，上边界这就没用了，下移，并判断是否越界
            if (++t > b) {
                break;
            }

            // 2. 从上到下
            for (int i = t; i <= b; i++) {
                res.add(matrix[i][r]);
            }
            // 这一列遍历完，右边界没用了，左移
            if (l > --r) {
                break;
            }

            // 3. 从右到左
            for (int i = r; i >= l; i--) {
                res.add(matrix[b][i]);
            }
            // 这一行遍历完，下边界没用了，上移
            if (t > --b) {
                break;
            }

            // 4. 从下到上
            for (int i = b; i >= t; i--) {
                res.add(matrix[i][l]);
            }
            // 这一列遍历完，左边界没用了，右移
            if (++l > r) {
                break;
            }
        }

        return res;
    }
}

```

## 复杂度分析
- 时间复杂度: $O(M \times N)$。矩阵中的每个元素都被访问且仅被访问一次。
- 空间复杂度: $O(1)$。除了用于返回结果的 res 列表外，我们只使用了 4 个变量来记录边界，不需要额外的存储空间。
