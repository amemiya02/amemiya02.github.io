---
title: "【HOT100/双指针】LeetCode 11. 盛最多水的容器"
date: 2025-12-17 19:10:00 +0900
categories: [算法, LeetCode]
tags: [数组, 双指针, 贪心]
---

## 题目回顾

> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。
>
> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> **说明：** 你不能倾斜容器。

**示例 1：**

**输入：** `height = [1,8,6,2,5,4,8,3,7]`
**输出：** `49`
**解释：** 图中垂直线代表输入数组 `[1,8,6,2,5,4,8,3,7]`。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

## 核心思路：双指针与贪心策略

这道题是经典的**双指针**（Two Pointers）应用题，同时也蕴含了**贪心**（Greedy）的思想。

如果我们使用暴力解法，两两组合计算面积，时间复杂度会达到 $O(n^2)$，这在 `n` 很大时会超时。我们需要寻找一种 $O(n)$ 的线性扫描方法。

### 面积公式分析

容器的蓄水量（面积）由以下公式决定：

$
\text{Area} = \min(height[l], height[r]) \times (r - l)
$

即：**取决于两板之间较短的那块板的高度 × 两板之间的距离**。这就像"木桶效应"，装多少水取决于最短的那块木板。

### 双指针的决策逻辑

我们从数组的两端开始向内收缩，初始化左指针 `l = 0`，右指针 `r = n - 1`。此时**宽度最大**。

在每一步迭代中，我们需要决定移动哪一边的指针。这里有一个关键的贪心策略：
**总是移动高度较小的那一端指针。**

**为什么？**
假设当前 `height[l] < height[r]`：
1.  **如果移动右指针（高板）**：宽度 `(r - l)` 变小了。而高度受限于左边的短板 `height[l]`，无论右边新的板多高，容器的实际高度不可能超过 `height[l]`。因此，面积**一定变小**。
2.  **如果移动左指针（短板）**：宽度 `(r - l)` 变小了。但是，新的左边板 `height[l+1]` 有可能比原来的 `height[l]` 高。虽然宽度减小了，但高度有可能大幅增加，从而使得整体面积**有可能变大**。

简而言之，**保留短板没有前途**（因为宽度在不断减小，短板限制了高度上限），只有丢弃短板，才有可能找到更高的板来弥补宽度的损失。

### 算法流程

1.  初始化 `ans = 0`，`l = 0`，`r = n - 1`。
2.  当 `l < r` 时循环：
    a.  计算当前面积：`tmp = min(height[l], height[r]) * (r - l)`。
    b.  更新最大面积：`ans = max(ans, tmp)`。
    c.  移动指针：如果 `height[l] <= height[r]`，则 `l++`；否则 `r--`。
3.  返回 `ans`。

## 代码实现 (Java)

```java
class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int ans = 0;
        // 初始化双指针，分别指向数组头尾
        int l = 0, r = n - 1;

        while (l < r) {
            // 计算当前面积：较短的板高 * 宽度
            // 这一步体现了"木桶效应"，水量由短板决定
            int tmp = Math.min(height[l], height[r]) * (r - l);

            // 更新历史最大值
            ans = Math.max(ans, tmp);

            // 核心贪心策略：谁短谁移动
            // 因为宽度在减小，保留短板不可能获得更大的面积
            if (height[l] <= height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return ans;
    }
}

```

## 复杂度分析

`时间复杂度`: $O(n)$。我们只需遍历数组一次，双指针 l 和 r 总共移动了 n 次。

`空间复杂度`: $O(1)$。只需要常数级别的变量来存储状态，不需要额外的存储空间。