---
title: "【HOT100/双指针】LeetCode 15. 三数之和"
date: 2025-12-17 19:25:00 +0900
categories: [算法, LeetCode]
tags: [数组, 双指针, 排序]
---

## 题目回顾

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。
>
> 请你返回所有和为 `0` 且不重复的三元组。
>
> **注意：** 答案中不可以包含重复的三元组。

**示例 1：**

**输入：** `nums = [-1,0,1,2,-1,-4]`
**输出：** `[[-1,-1,2],[-1,0,1]]`
**解释：**
不同的三元组是 `[-1,0,1]` 和 `[-1,-1,2]` 。
注意，输出的顺序和三元组的顺序并不重要。

## 核心思路：排序 + 双指针

这道题是“两数之和”的进阶版。如果直接使用三重循环暴力求解，时间复杂度为 $O(n^3)$，这显然会超时。我们需要寻找 $O(n^2)$ 级别的解法。

### 1. 为什么先排序？
排序是解决这道题的关键步骤（通常花费 $O(n \log n)$）。
- **便于双指针操作**：排序后，我们可以利用单调性，通过移动左右指针来调整两数之和的大小。
- **便于去重**：题目要求不包含重复的三元组。排序后，相同的元素会相邻，我们在遍历时很容易判断并跳过重复元素。

### 2. 算法流程
我们将三数之和问题转化为：**固定一个数 `nums[i]`，在剩下的数组中寻找两个数，使它们的和等于 `-nums[i]`**。

具体步骤如下：
1.  **特判**：如果数组为空或长度小于3，直接返回空列表。
2.  **排序**：对数组进行升序排序。
3.  **遍历**：枚举第一个数 `nums[i]`（索引 `i` 从 0 到 `n-2`）：
    * **剪枝优化**：因为数组已排序，如果 `nums[i] > 0`，那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。
    * **外层去重**：如果 `i > 0` 且 `nums[i] == nums[i-1]`，说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。
    * **双指针查找**：令左指针 `L = i + 1`，右指针 `R = n - 1`。当 `L < R` 时：
        * 计算 sum = `nums[i] + nums[L] + nums[R]`。
        * **若 sum == 0**：找到一组解，加入结果集。
            * **内层去重**：为了防止结果重复，需要将 `L` 向右移过所有重复值，将 `R` 向左移过所有重复值。
            * 移动指针：`L++`, `R--`。
        * **若 sum < 0**：说明和太小，需要变大，因此 `L++`。
        * **若 sum > 0**：说明和太大，需要变小，因此 `R--`。

### 3. 去重的细节
这道题最容易出错的地方就是去重。
- **外层去重** (`nums[i] == nums[i-1]`)：保证三元组的第一个位置不使用相同的值。
- **内层去重** (`nums[left] == nums[left+1]`)：在找到一个解后，保证三元组的第二个（以及自然确定的第三个）位置不使用相同的值。

## 代码实现 (Java)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        // 特判：数组无效或长度不足
        if (nums == null || nums.length <= 2) {
            return ans;
        }
        
        int n = nums.length;
        // 1. 排序：这是双指针法的前提
        Arrays.sort(nums); // O(nlogn)
        
        // 2. 遍历第一个数 nums[i]
        // 只需要遍历到倒数第三个数即可
        for (int i = 0; i < nums.length - 2; i++) {
            // 优化：如果当前数大于0，后续之和一定大于0，直接结束
            if (nums[i] > 0) {
                break;
            }
            
            // 外层去重：跳过重复的第一个数
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            // 转化为求两数之和：寻找 nums[left] + nums[right] == -nums[i]
            int target = -nums[i];
            int left = i + 1, right = n - 1;
            
            while (left < right) {
                int sum = nums[left] + nums[right];
                
                if (sum == target) {
                    // 找到符合条件的三元组
                    ans.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                    
                    // 无论如何先移动指针
                    left++;
                    right--;
                    
                    // 内层去重：跳过重复的 left 和 right
                    // 注意：必须在 left < right 的前提下比较
                    while (left < right && nums[left] == nums[left - 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right + 1]) {
                        right--;
                    }
                } else if (sum < target) {
                    // 和太小，左指针右移
                    left++;
                } else {
                    // 和太大，右指针左移
                    right--;
                }
            }
        }
        return ans;
    }
}
```
## 复杂度分析

- 时间复杂度: $O(n^2)$。数组排序的时间复杂度为 $O(n \log n)$。双指针遍历的时间复杂度为 $O(n^2)$。总体复杂度由 $O(n^2)$ 主导。
- 空间复杂度: $O(\log n)$ 或 $O(n)$。取决于排序算法的实现细节。Java 的 Arrays.sort 对于基本数据类型通常使用双轴快速排序，空间复杂度为 $O(\log n)$。如果不考虑存储答案的空间，额外空间仅为排序所需。
