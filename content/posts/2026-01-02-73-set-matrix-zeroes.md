---
title: "【HOT100/矩阵】LeetCode 73. 矩阵置零"
date: 2026-01-02 20:45:00 +0900
categories: [算法, LeetCode]
tags: [数组, 矩阵]
---

## 题目回顾

> 给定一个 `m x n` 的矩阵，如果一个元素为 `0` ，则将其所在行和列的所有元素都设为 `0` 。请使用 **原地** 算法。

**示例 1：**


**输入：** `matrix = [[1,1,1],[1,0,1],[1,1,1]]`
**输出：** `[[1,0,1],[0,0,0],[1,0,1]]`

**示例 2：**


**输入：** `matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]`
**输出：** `[[0,0,0,0],[0,4,5,0],[0,3,1,0]]`

**进阶：**
* 一个直观的解决方案是使用 $O(mn)$ 的额外空间，但这并不是一个好的解决方案。
* 一个简单的改进方案是使用 $O(m + n)$ 的额外空间，但这仍然不是最好的解决方案。
* 你能想出一个仅使用常量空间的解决方案吗？

## 核心思路：利用首行首列做标记

这道题的难点在于**"污染"**问题：如果我们一边遍历一边将 0 所在的行列置零，那么修改后的 0 会干扰后续的遍历，导致整个矩阵最后全变成了 0。

### 空间复杂度优化路径

1.  **$O(MN)$ 空间**：新建一个同样的矩阵做标记。太浪费。
2.  **$O(M+N)$ 空间**：使用两个布尔数组 `row[]` 和 `col[]`，分别记录哪一行、哪一列需要置零。
3.  **$O(1)$ 空间**：直接利用矩阵的第一行和第一列来替代上面的两个布尔数组。

### 算法流程 ($O(1)$ 方案)

既然我们要用第一行和第一列来记录"该行/列是否需要置零"，那么第一行和第一列原本的状态（是否包含 0）就需要先被保存下来，否则会被后续的标记覆盖。

步骤如下：

1.  **记录首行首列状态**：
    定义两个变量 `firstRowHasZero` 和 `firstColHasZero`，遍历第一行和第一列，如果发现 0，则将对应的变量置为 `true`。

2.  **利用首行首列做标记**：
    遍历矩阵的**其余部分**（从 `(1,1)` 开始）。如果发现 `matrix[i][j] == 0`，就将它对应的行首 `matrix[i][0]` 和列首 `matrix[0][j]` 设为 0。

3.  **根据标记置零内部**：
    再次遍历矩阵的**其余部分**（从 `(1,1)` 开始）。检查当前位置对应的行首或列首是否为 0，如果是，则将 `matrix[i][j]` 置为 0。

4.  **处理首行首列**：
    最后，根据第 1 步记录的 `firstRowHasZero` 和 `firstColHasZero`，决定是否要将第一行或第一列全部置零。

**注意**：处理顺序很重要，必须先处理内部，最后再根据布尔变量处理首行首列，否则首行首列作为"控制位"如果先被置零了，内部的逻辑就乱了。

## 代码实现 (Java)

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        boolean firstRowHasZero = false;
        boolean firstColHasZero = false;

        // 1. 检查第一列是否有 0
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColHasZero = true;
                break;
            }
        }

        // 2. 检查第一行是否有 0
        for (int i = 0; i < n; i++) {
            if (matrix[0][i] == 0) {
                firstRowHasZero = true;
                break;
            }
        }

        // 3. 使用第一行和第一列作为标记位
        // 遍历除第一行、第一列之外的元素
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0; // 标记该行需要置零
                    matrix[0][j] = 0; // 标记该列需要置零
                }
            }
        }

        // 4. 根据标记，将内部元素置零
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // 5. 最后处理第一行
        if (firstRowHasZero) {
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }

        // 6. 最后处理第一列
        if (firstColHasZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

## 复杂度分析
- 时间复杂度: $O(M \times N)$。我们对矩阵进行了几次遍历，但总体操作次数与元素总数呈线性关系。
- 空间复杂度: $O(1)$。我们只使用了两个布尔变量，利用矩阵本身的空间存储了状态，满足了进阶要求。
