---
title: "【HOT100/数组】LeetCode 238. 除了自身以外数组的乘积"
date: 2026-01-02 18:00:00 +0900
categories: [算法, LeetCode]
tags: [数组, 前缀和]
---

## 题目回顾

> 给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除了 `nums[i]` 之外其余各元素的乘积。
>
> 题目数据 **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。
>
> **请不要使用除法，且在 $O(n)$ 时间复杂度内完成此题。**

**示例 1:**

**输入:** `nums = [1,2,3,4]`
**输出:** `[24,12,8,6]`

**示例 2:**

**输入:** `nums = [-1,1,0,-3,3]`
**输出:** `[0,0,9,0,0]`

## 核心思路：左右乘积列表

这道题如果允许使用除法，那非常简单：算出所有元素的总乘积，然后除以当前元素即可（注意需要处理 0 的情况）。但题目明确禁止除法，我们需要另辟蹊径。

对于数组中的任意一个元素 `nums[i]`，除了它自身以外的乘积，实际上等于：
**（它左边所有元素的乘积） $\times$ （它右边所有元素的乘积）**



因此，我们可以通过两次遍历来解决这个问题：

1.  **计算后缀积**：先算出每个位置**右边**所有元素的乘积。
2.  **计算前缀积并合并**：再算出每个位置**左边**所有元素的乘积，并乘上刚才算好的后缀积。

### 空间优化 ($O(1)$ 额外空间)

为了满足进阶要求的 $O(1)$ 额外空间（输出数组不计入空间复杂度），我们可以直接利用返回的数组 `answer`（代码中为 `suf`）来作为中间容器。

1.  **第一轮遍历（从右向左）**：
    我们在 `suf` 数组中存储**后缀积**。
    `suf[i]` 表示 `i` 之后所有元素的乘积。
    初始化 `suf[n-1] = 1`（因为最后一个元素右边没有元素）。

2.  **第二轮遍历（从左向右）**：
    我们使用一个变量 `pre` 来动态维护**前缀积**。
    对于每个位置 `i`，`suf[i]` 目前存储的是"右边的积"。
    我们只需要执行 `suf[i] = suf[i] * pre`，就可以得到"右边的积 $\times$ 左边的积"。
    然后更新 `pre`，将其乘上 `nums[i]`，为下一个位置做准备。

这样，我们只需要遍历两次，且不需要额外开辟数组空间。

## 代码实现 (Java)

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        // 这里的 suf 数组最终将作为结果返回
        // 初始阶段，我们用它来存储"后缀积"
        int[] suf = new int[n];

        // 1. 从右向左遍历，计算每个位置右侧所有元素的乘积
        // 最右边的元素，其右侧没有元素，视为 1
        suf[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        // 2. 从左向右遍历，动态维护一个 pre 变量代表"前缀积"
        int pre = 1;
        for (int i = 0; i < n; i++) {
            // 此时 suf[i] 是右侧积，pre 是左侧积
            // 两者相乘即为结果
            suf[i] *= pre;
            
            // 更新前缀积，包含当前元素，供下一次循环使用
            pre *= nums[i];
        }
        
        return suf;
    }
}
```

## 复杂度分析
- 时间复杂度: $O(N)$。我们对数组进行了两次遍历。
- 空间复杂度: $O(1)$。除了用于返回答案的数组 suf 外，我们只使用了常数级别的额外变量（n, pre, i）。
