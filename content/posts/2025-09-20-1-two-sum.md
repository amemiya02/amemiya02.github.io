---
title: "【HOT100/哈希表】LeetCode 1. 两数之和"
date: 2025-09-20 14:50:00 +0900
categories: [算法, LeetCode]
tags: [数组, 哈希表]
---

## 题目回顾

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值 `target`** 的那 **两个** 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。

**示例 1：**

**输入：** `nums = [2,7,11,15]`, `target = 9`
**输出：** `[0,1]`
**解释：** 因为 `nums[0] + nums[1] == 9` ，返回 `[0, 1]` 。

## 核心思路：用空间换时间

作为 LeetCode 的开篇之作，这道题完美地诠释了如何通过"空间换时间"的思想来优化算法。

暴力解法的瓶颈在于"寻找另一个数"的过程太慢。对于每个 `nums[i]`，我们都需要在数组中寻找是否存在一个数 `target - nums[i]`。这个寻找过程能否被加速呢？

答案是肯定的，**哈希表**提供了近乎 $O(1)$ 的查找效率。

我们可以使用一个哈希表（HashMap）来存储已经遍历过的数字及其对应的索引，即 `Map<数值, 索引>`。

具体的算法流程如下：
1.  创建一个空的哈希表 `map`。
2.  遍历 `nums` 数组，对于当前的元素 `nums[i]`：
    a.  计算我们需要寻找的"另一半"：`complement = target - nums[i]`。
    b.  **在哈希表中查找** `complement` 是否存在。
        * **如果存在**，说明我们找到了解！`complement` 的索引已经存在 `map` 中，当前元素的索引是 `i`。我们立即返回 `[map.get(complement), i]`。
        * **如果不存在**，说明到目前为止还没遇到能和 `nums[i]` 配对的数。我们将当前数字和它的索引存入哈希表 `map.put(nums[i], i)`，以便后续的元素能用它来配对。
3.  遍历结束。由于题目保证有唯一解，所以在循环中一定会找到答案。

这个"一边遍历，一边查找，一边插入"的**单遍哈希表**解法，非常巧妙地在一次循环中完成了所有工作。

## 代码实现 (Java)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // Key 存储数值, Value 存储索引
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];

            // 检查"另一半"是否已经存在于 map 中
            if (map.containsKey(complement)) {
                // 如果存在，直接返回两个数的索引
                return new int[] { map.get(complement), i };
            }

            // 如果不存在，将当前数和它的索引存入 map，供后续元素查询
            map.put(nums[i], i);
        }

        // 根据题意，一定有解，这里是为了编译通过
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

**复杂度分析**
- 时间复杂度: `O(n)`。我们只需遍历数组一次。哈希表的插入和查找操作的平均时间复杂度都是 O(1)。

- 空间复杂度: `O(n)`。在最坏情况下，我们需要将数组中的所有元素都存入哈希表中。