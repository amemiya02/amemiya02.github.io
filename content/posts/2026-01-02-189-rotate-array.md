---
title: "【HOT100/数组】LeetCode 189. 轮转数组"
date: 2026-01-02 17:05:00 +0900
categories: [算法, LeetCode]
tags: [数组, 数学, 双指针]
---

## 题目回顾

> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

**输入:** `nums = [1,2,3,4,5,6,7], k = 3`
**输出:** `[5,6,7,1,2,3,4]`
**解释:**
向右轮转 1 步: `[7,1,2,3,4,5,6]`
向右轮转 2 步: `[6,7,1,2,3,4,5]`
向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

**输入：** `nums = [-1,-100,3,99], k = 2`
**输出：** `[3,99,-1,-100]`

## 核心思路：三次翻转法

这道题最直观的解法是使用一个额外的数组，将每个元素放到正确的位置，但这需要 $O(N)$ 的空间。
如果要求原地算法（$O(1)$ 空间），最经典且容易理解的方法是**数组翻转法**。



我们可以观察一下规律，以 `nums = [1,2,3,4,5,6,7], k = 3` 为例：

1.  **原始数组**：`[1, 2, 3, 4, 5, 6, 7]`
    我们可以把数组分为两部分：
    * 第一部分（前 `n-k` 个）：`[1, 2, 3, 4]`
    * 第二部分（后 `k` 个）：`[5, 6, 7]` (这部分实际上是要移动到数组头部的)

2.  **第一步：整体翻转**
    将整个数组翻转：
    `[7, 6, 5, 4, 3, 2, 1]`
    此时，原本在尾部的 `[5, 6, 7]` 跑到了头部，但是顺序是反的（`7, 6, 5`）。原本在头部的 `[1, 2, 3, 4]` 跑到了尾部，顺序也是反的（`4, 3, 2, 1`）。

3.  **第二步：翻转前 k 个元素**
    我们将前 `k` 个元素（下标 `0` 到 `k-1`）再次翻转：
    `[5, 6, 7, 4, 3, 2, 1]`
    此时，头部元素顺序恢复正常。

4.  **第三步：翻转剩余元素**
    我们将剩下的元素（下标 `k` 到 `n-1`）再次翻转：
    `[5, 6, 7, 1, 2, 3, 4]`
    此时，尾部元素顺序也恢复正常，得到最终结果。

**注意事项**：
如果 `k` 大于数组长度 `n`，轮转 `k` 次等于轮转 `k % n` 次。所以在开始处理前，需要先执行 `k %= n`。

## 代码实现 (Java)

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        if (n == 0) {
            return;
        }
        
        // 如果 k > n，轮转 k 次和轮转 k % n 次效果一样
        // 例如长度为 5，轮转 6 次 等于 轮转 1 次
        k %= n;

        // 核心步骤：三次翻转
        // 1. 翻转全部
        reverse(nums, 0, n - 1);
        // 2. 翻转前 k 个
        reverse(nums, 0, k - 1);
        // 3. 翻转剩余部分
        reverse(nums, k, n - 1);
    }

    // 辅助函数：双指针翻转数组指定区间
    private void reverse(int[] nums, int i, int j) {
        while (i < j) { // 注意：这里 i < j 即可，相等时无需交换
            int temp = nums[i];
            nums[i++] = nums[j];
            nums[j--] = temp;
        }
    }
}
```

## 复杂度分析
- 时间复杂度: $O(N)$。我们需要遍历数组三次（一次整体，两次局部），每次操作都是线性的，总时间复杂度为 $O(N)$。
- 空间复杂度: $O(1)$。我们只使用了常数个额外变量进行交换操作，没有使用额外的数组空间。
