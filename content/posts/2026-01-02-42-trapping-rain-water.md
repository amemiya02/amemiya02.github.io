---
title: "【HOT100/动态规划】LeetCode 42. 接雨水"
date: 2026-01-02 14:35:00 +0900
categories: [算法, LeetCode]
tags: [数组, 动态规划, 双指针]
---

## 题目回顾

> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**


**输入：** `height = [0,1,0,2,1,0,1,3,2,1,2,1]`
**输出：** `6`
**解释：** 上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**示例 2：**

**输入：** `height = [4,2,0,3,2,5]`
**输出：** `9`

## 核心思路：按列求值的动态规划

这道题是 LeetCode Top 100 中非常经典的 Hard 题目，也是大厂面试的常客。解决这道题的关键在于**化繁为简**：不要试图一次性算出所有雨水，而是思考**每一根柱子上方能存多少水**。

对于数组中索引为 `i` 的位置，它能接到的雨水量取决于什么？
根据"木桶效应"，它能存的水，取决于它**左边最高的柱子**和**右边最高的柱子**中较矮的那一个，减去它自身的高度。

公式如下：

$$
\text{water}[i] = \min(\text{maxleft}[i], \text{maxright}[i]) - \text{height}[i]
$$


当然，如果计算结果小于 0，说明当前柱子比两边都高，存不了水，结果取 0。

### 为什么需要动态规划？

如果我们对每个位置 `i` 都向左、向右扫描寻找最大值，时间复杂度会达到 $O(N^2)$，这在数据量大时会超时。

为了优化，我们可以使用**空间换时间**的策略（预处理）：
1.  **左侧最大值数组 (`left`)**：从左往右遍历，`left[i]` 表示 `[0...i]` 区间内的最大高度。递推公式为 `left[i] = max(left[i-1], height[i])`。
2.  **右侧最大值数组 (`right`)**：从右往左遍历，`right[i]` 表示 `[i...n-1]` 区间内的最大高度。递推公式为 `right[i] = max(right[i+1], height[i])`。

这样，我们在最后计算雨水时，只需要 $O(1)$ 的时间就能获取到左右两边的限制高度。

具体的算法流程如下：
1.  初始化两个长度为 `n` 的数组 `left` 和 `right`。
2.  **正向遍历**生成 `left` 数组。
3.  **反向遍历**生成 `right` 数组。
4.  再次遍历数组，应用上述公式累加每一个位置的雨水量。

## 代码实现 (Java)

```java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        int n = height.length;
        
        // 边界条件判断
        if (n == 0) {
            return 0;
        }

        // 定义两个数组，分别存储左边和右边的最大高度
        int[] left = new int[n];
        int[] right = new int[n];

        // 初始化 left 数组：从左向右扫描
        left[0] = height[0];
        for (int i = 1; i < n; i++) {
            // 当前位置左边的最大高度 = max(当前高度, 前一个位置记录的左边最大高度)
            left[i] = Math.max(height[i], left[i - 1]);
        }

        // 初始化 right 数组：从右向左扫描
        right[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            // 当前位置右边的最大高度 = max(当前高度, 后一个位置记录的右边最大高度)
            right[i] = Math.max(height[i], right[i + 1]);
        }

        // 计算总雨水量
        for (int i = 0; i < n; i++) {
            // 短板效应：取决于左右两边最大高度较小的那一个，减去自身高度
            res += (Math.min(left[i], right[i]) - height[i]);
        }

        return res;
    }
}
```

复杂度分析

- 时间复杂度: $O(N)$。我们需要遍历数组三次（计算 left，计算 right，计算结果），每次操作都是线性的，所以总时间复杂度为线性。
- 空间复杂度: $O(N)$。我们需要两个额外的数组 left 和 right 来存储预处理结果。进阶思考：虽然 $O(N)$ 的空间复杂度已经是可以接受的，但这道题其实还有空间复杂度为 $O(1)$ 的双指针解法。其核心思想是在动态维护左右最大值的同时收缩左右指针，有兴趣的读者可以尝试自行推导。
