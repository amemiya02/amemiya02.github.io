---
title: "[Golang] LeetCode 热题 100 - 双指针"
date: 2026-01-24 21:00:00 +0900
categories: [算法, LeetCode]
tags: [Go, 双指针, 动态规划, 题解]
---
# 双指针

## [283. 移动零 - Easy](https://leetcode.cn/problems/move-zeroes/)

### 题目回顾

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下**原地**对数组进行操作。

**示例 1:**

**输入:** `nums = [0,1,0,3,12]`
**输出:** `[1,3,12,0,0]`

### 核心思路：快慢指针（一次遍历）

这道题有两个核心要求：

1. 将所有 `0` 移动到末尾。
2. 保持所有**非零**元素的相对顺序不变。

第二个要求"保持相对顺序"是解题的关键。它告诉我们，不能简单地像"移除元素"那样，用头尾指针交换元素，因为那样会打乱非零元素的原有顺序。

这个问题的本质可以看作是：**将所有非零元素，按原有的顺序，紧凑地移动到数组的前面，然后将剩余的位置全部填上零**。

这正是**快慢指针**擅长的场景：

1. **定义指针**：

   * **慢指针 `p` (或 `slow`)**: 这个指针用于标记"下一个非零元素应该被放置的位置"。在 `p` 左边的所有元素（不含 `p`）都是已经处理好的、按序排列的非零元素。
   * **快指针 `q` (或 `fast`)**: 这个指针负责遍历整个数组，去寻找非零元素。
2. **执行过程**：

   * 初始化 `p` 和 `q` 都指向数组的起始位置 `0`。
   * 快指针 `q` 开始向后遍历数组。
   * 当 `q` 遇到一个**非零**元素时，说明这个元素需要被保留并放到前面。于是，我们执行两个操作：
     1. 将这个非零元素 `nums[q]` 赋值给慢指针 `p` 所在的位置 `nums[p]`。
     2. 将慢指针 `p` 向后移动一位 (`p++`)，为下一个非零元素腾出位置。
   * 如果 `q` 遇到的是 `0`，则慢指针 `p` 保持不动，只有快指针 `q` 继续向后移动。
3. **填充末尾的零**：

   * 当快指针 `q` 遍历完整个数组后，所有非零元素都已经被紧凑地移动到了数组的前 `p` 个位置。
   * 数组中从索引 `p` 到末尾的所有位置，都应该是 `0`。
   * 因此，我们再进行一次循环，从 `p` 开始，将数组剩余的位置全部赋值为 `0`。

### 代码实现

```go
func moveZeroes(nums []int) {

    p := 0

    for q := 0; q < len(nums); q++ {
        if nums[q] != 0 {
            nums[p] = nums[q]
            p++
        }
    }

    for ; p < len(nums); p++ {
        nums[p] = 0
    }
}
```

**复杂度分析**

* 时间复杂度: $O(n)$。其中 n 是数组的长度。快指针 q 遍历数组一次，慢指针 p 在第二步中也最多遍历一次。总的操作次数与 n 呈线性关系。
* 空间复杂度: $O(1)$。所有操作都在原数组上进行，没有使用额外的存储空间。

## [11. 盛最多水的容器 - Mid](https://leetcode.cn/problems/container-with-most-water/)

### 题目回顾

> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。
>
> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> **说明：** 你不能倾斜容器。

**示例 1：**

**输入：** `height = [1,8,6,2,5,4,8,3,7]`
**输出：** `49`
**解释：** 图中垂直线代表输入数组 `[1,8,6,2,5,4,8,3,7]`。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

### 核心思路：双指针与贪心策略

这道题是经典的**双指针**（Two Pointers）应用题，同时也蕴含了**贪心**（Greedy）的思想。

如果我们使用暴力解法，两两组合计算面积，时间复杂度会达到 $O(n^2)$，这在 `n` 很大时会超时。我们需要寻找一种 $O(n)$ 的线性扫描方法。

#### 面积公式分析

容器的蓄水量（面积）**取决于两板之间较短的那块板的高度 × 两板之间的距离**。这就像"木桶效应"，装多少水取决于最短的那块木板。

#### 双指针的决策逻辑

我们从数组的两端开始向内收缩，初始化左指针 `l = 0`，右指针 `r = n - 1`。此时**宽度最大**。

在每一步迭代中，我们需要决定移动哪一边的指针。这里有一个关键的贪心策略：
**总是移动高度较小的那一端指针。**

**为什么？**
假设当前 `height[l] < height[r]`：

1. **如果移动右指针（高板）**：宽度 `(r - l)` 变小了。而高度受限于左边的短板 `height[l]`，无论右边新的板多高，容器的实际高度不可能超过 `height[l]`。因此，面积**一定变小**。
2. **如果移动左指针（短板）**：宽度 `(r - l)` 变小了。但是，新的左边板 `height[l+1]` 有可能比原来的 `height[l]` 高。虽然宽度减小了，但高度有可能大幅增加，从而使得整体面积**有可能变大**。

简而言之，**保留短板没有前途**（因为宽度在不断减小，短板限制了高度上限），只有丢弃短板，才有可能找到更高的板来弥补宽度的损失。

#### 算法流程

1. 初始化 `ans = 0`，`l = 0`，`r = n - 1`。
2. 当 `l < r` 时循环：
   a.  计算当前面积：`tmp = min(height[l], height[r]) * (r - l)`。
   b.  更新最大面积：`ans = max(ans, tmp)`。
   c.  移动指针：如果 `height[l] <= height[r]`，则 `l++`；否则 `r--`。
3. 返回 `ans`。

### 代码实现

```go
func maxArea(height []int) int {
    l, r := 0, len(height)-1
    maxAns := 0

    for l < r {
        width := r - l
        // 确定当前这一步的短板高度
        h := 0
        if height[l] < height[r] {
            h = height[l]
        } else {
            h = height[r]
        }

        // 计算面积并更新最大值
        area := h * width
        if area > maxAns {
            maxAns = area
        }

        // --- 核心优化：快速跳过无意义的柱子 ---
        // 如果左侧是短板，移动左指针，且跳过所有比当前短板还矮的柱子
        if height[l] < height[r] {
            lastH := height[l]
            l++
            for l < r && height[l] <= lastH {
                l++
            }
        } else {
            // 如果右侧是短板，同理
            lastH := height[r]
            r--
            for l < r && height[r] <= lastH {
                r--
            }
        }
    }
    return maxAns
}
```

**复杂度分析**

`时间复杂度`: $O(n)$。我们只需遍历数组一次，双指针 l 和 r 总共移动了 n 次。

`空间复杂度`: $O(1)$。只需要常数级别的变量来存储状态，不需要额外的存储空间。

## [15. 三数之和 - Mid](https://leetcode.cn/problems/3sum/)

### 题目回顾

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。
>
> 请你返回所有和为 `0` 且不重复的三元组。
>
> **注意：** 答案中不可以包含重复的三元组。

**示例 1：**

**输入：** `nums = [-1,0,1,2,-1,-4]`
**输出：** `[[-1,-1,2],[-1,0,1]]`
**解释：**
不同的三元组是 `[-1,0,1]` 和 `[-1,-1,2]` 。
注意，输出的顺序和三元组的顺序并不重要。

### 核心思路：排序 + 双指针

这道题是“两数之和”的进阶版。如果直接使用三重循环暴力求解，时间复杂度为 $O(n^3)$，这显然会超时。我们需要寻找 $O(n^2)$ 级别的解法。

#### 1. 为什么先排序？

排序是解决这道题的关键步骤（通常花费 $O(n \log n)$）。

* **便于双指针操作**：排序后，我们可以利用单调性，通过移动左右指针来调整两数之和的大小。
* **便于去重**：题目要求不包含重复的三元组。排序后，相同的元素会相邻，我们在遍历时很容易判断并跳过重复元素。

#### 2. 算法流程

我们将三数之和问题转化为：**固定一个数 `nums[i]`，在剩下的数组中寻找两个数，使它们的和等于 `-nums[i]`**。

具体步骤如下：

1. **特判**：如果数组为空或长度小于3，直接返回空列表。
2. **排序**：对数组进行升序排序。
3. **遍历**：枚举第一个数 `nums[i]`（索引 `i` 从 0 到 `n-2`）：
   * **剪枝优化**：因为数组已排序，如果 `nums[i] > 0`，那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。
   * **外层去重**：如果 `i > 0` 且 `nums[i] == nums[i-1]`，说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。
   * **双指针查找**：令左指针 `L = i + 1`，右指针 `R = n - 1`。当 `L < R` 时：
     * 计算 sum = `nums[i] + nums[L] + nums[R]`。
     * **若 sum == 0**：找到一组解，加入结果集。
       * **内层去重**：为了防止结果重复，需要将 `L` 向右移过所有重复值，将 `R` 向左移过所有重复值。
       * 移动指针：`L++`, `R--`。
     * **若 sum < 0**：说明和太小，需要变大，因此 `L++`。
     * **若 sum > 0**：说明和太大，需要变小，因此 `R--`。

#### 3. 去重的细节

这道题最容易出错的地方就是去重。

* **外层去重** (`nums[i] == nums[i-1]`)：保证三元组的第一个位置不使用相同的值。
* **内层去重** (`nums[left] == nums[left+1]`)：在找到一个解后，保证三元组的第二个（以及自然确定的第三个）位置不使用相同的值。

### 代码实现

```go
func threeSum(nums []int) [][]int {
    n := len(nums)
    if n < 3 {
        return [][]int{}
    }

    var ans [][]int
    sort.Ints(nums)

    for i := 0; i < n-2; i++ {
        // 因为数组已排序，如果 nums[i] > 0，
        // 那么后面的数一定都比它大，三数之和不可能为 0，直接结束循环。
        if nums[i] > 0 {
            break
        }
        // 如果 i > 0 且 nums[i] == nums[i-1]
        // 说明这个数作为第一个数的情况已经处理过了，跳过以避免重复。
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        // 转化为求两数之和：寻找 nums[left] + nums[right] == -nums[i]
        target := -nums[i]
        left, right := i+1, n-1

        for left < right {
            sum := nums[left] + nums[right]
            if sum == target {
                // 找到符合条件的三元组
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                // 无论如何先移动指针
                left++
                right--
                // 内层去重：跳过重复的 left 和 right
                // 注意：必须在 left < right 的前提下比较
                for left < right && nums[left] == nums[left-1] {
                    left++
                }
                for left < right && nums[right] == nums[right+1] {
                    right--
                }
            } else if sum > target {
                // 和太大，右指针左移
                right--
            } else {
                // 和太小，左指针右移
                left++
            }
        }
    }
    return ans
}

```

**复杂度分析**

* 时间复杂度: $O(n^2)$。数组排序的时间复杂度为 $O(n \log n)$。双指针遍历的时间复杂度为 $O(n^2)$。总体复杂度由 $O(n^2)$ 主导。
* 空间复杂度: $O(\log n)$ 或 $O(n)$。取决于排序算法的实现细节。

## [42. 接雨水 - Hard](https://leetcode.cn/problems/trapping-rain-water/)

### 题目回顾

> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

**输入：** `height = [0,1,0,2,1,0,1,3,2,1,2,1]`
**输出：** `6`
**解释：** 上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**示例 2：**

**输入：** `height = [4,2,0,3,2,5]`
**输出：** `9`

### 核心思路：按列求值的动态规划

这道题是 LeetCode Top 100 中非常经典的 Hard 题目，也是大厂面试的常客。解决这道题的关键在于**化繁为简**：不要试图一次性算出所有雨水，而是思考**每一根柱子上方能存多少水**。

对于数组中索引为 `i` 的位置，它能接到的雨水量取决于什么？
根据"木桶效应"，它能存的水，取决于它**左边最高的柱子**和**右边最高的柱子**中较矮的那一个，减去它自身的高度。

公式如下：

$$
\text{water}[i] = \min(\text{maxleft}[i], \text{maxright}[i]) - \text{height}[i]
$$

当然，如果计算结果小于 0，说明当前柱子比两边都高，存不了水，结果取 0。

#### 为什么需要动态规划？

如果我们对每个位置 `i` 都向左、向右扫描寻找最大值，时间复杂度会达到 $O(N^2)$，这在数据量大时会超时。

为了优化，我们可以使用**空间换时间**的策略（预处理）：

1. **左侧最大值数组 (`left`)**：从左往右遍历，`left[i]` 表示 `[0...i]` 区间内的最大高度。递推公式为 `left[i] = max(left[i-1], height[i])`。
2. **右侧最大值数组 (`right`)**：从右往左遍历，`right[i]` 表示 `[i...n-1]` 区间内的最大高度。递推公式为 `right[i] = max(right[i+1], height[i])`。

这样，我们在最后计算雨水时，只需要 $O(1)$ 的时间就能获取到左右两边的限制高度。

具体的算法流程如下：

1. 初始化两个长度为 `n` 的数组 `left` 和 `right`。
2. **正向遍历**生成 `left` 数组。
3. **反向遍历**生成 `right` 数组。
4. 再次遍历数组，应用上述公式累加每一个位置的雨水量。

### 代码实现

```go

func trap(height []int) int {
    n := len(height)
    if n <= 1 {
        return 0
    }
    // left_i 表示0到i的最大值
    left := make([]int, n)
    left[0] = height[0]
    // right_i 表示i到n-1的最大值
    right := make([]int, n)
    right[n-1] = height[n-1]

    for i := 1; i < n; i++ {
        left[i] = max(left[i-1], height[i])
    }

    for i := n - 2; i >= 0; i-- {
        right[i] = max(right[i+1], height[i])
    }
    sum := 0
    for i, v := range height {
        sum += min(left[i], right[i]) - v
    }

    return sum
}

```

**复杂度分析**

* 时间复杂度: $O(N)$。我们需要遍历数组三次（计算 left，计算 right，计算结果），每次操作都是线性的，所以总时间复杂度为线性。
* 空间复杂度: $O(N)$。我们需要两个额外的数组 left 和 right 来存储预处理结果。进阶思考：虽然 $O(N)$ 的空间复杂度已经是可以接受的，但这道题其实还有空间复杂度为 $O(1)$ 的双指针解法。其核心思想是在动态维护左右最大值的同时收缩左右指针，有兴趣的读者可以尝试自行推导。
