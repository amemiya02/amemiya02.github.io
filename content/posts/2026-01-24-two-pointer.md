---
title: "[Golang] LeetCode 热题 100 - 双指针"
date: 2026-01-24 21:00:00 +0900
categories: [算法, LeetCode]
tags: [双指针, 题解]
---
# 双指针

## [283. 移动零 - Easy](https://leetcode.cn/problems/move-zeroes/)

### 题目回顾

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下**原地**对数组进行操作。

**示例 1:**

**输入:** `nums = [0,1,0,3,12]`
**输出:** `[1,3,12,0,0]`

### 核心思路：快慢指针（一次遍历）

这道题有两个核心要求：

1. 将所有 `0` 移动到末尾。
2. 保持所有**非零**元素的相对顺序不变。

第二个要求"保持相对顺序"是解题的关键。它告诉我们，不能简单地像"移除元素"那样，用头尾指针交换元素，因为那样会打乱非零元素的原有顺序。

这个问题的本质可以看作是：**将所有非零元素，按原有的顺序，紧凑地移动到数组的前面，然后将剩余的位置全部填上零**。

这正是**快慢指针**擅长的场景：

1. **定义指针**：

   * **慢指针 `p` (或 `slow`)**: 这个指针用于标记"下一个非零元素应该被放置的位置"。在 `p` 左边的所有元素（不含 `p`）都是已经处理好的、按序排列的非零元素。
   * **快指针 `q` (或 `fast`)**: 这个指针负责遍历整个数组，去寻找非零元素。
2. **执行过程**：

   * 初始化 `p` 和 `q` 都指向数组的起始位置 `0`。
   * 快指针 `q` 开始向后遍历数组。
   * 当 `q` 遇到一个**非零**元素时，说明这个元素需要被保留并放到前面。于是，我们执行两个操作：
     1. 将这个非零元素 `nums[q]` 赋值给慢指针 `p` 所在的位置 `nums[p]`。
     2. 将慢指针 `p` 向后移动一位 (`p++`)，为下一个非零元素腾出位置。
   * 如果 `q` 遇到的是 `0`，则慢指针 `p` 保持不动，只有快指针 `q` 继续向后移动。
3. **填充末尾的零**：

   * 当快指针 `q` 遍历完整个数组后，所有非零元素都已经被紧凑地移动到了数组的前 `p` 个位置。
   * 数组中从索引 `p` 到末尾的所有位置，都应该是 `0`。
   * 因此，我们再进行一次循环，从 `p` 开始，将数组剩余的位置全部赋值为 `0`。

### 代码实现

```go
func moveZeroes(nums []int) {

	p := 0

	for q := 0; q < len(nums); q++ {
		if nums[q] != 0 {
			nums[p] = nums[q]
			p++
		}
	}

	for ; p < len(nums); p++ {
		nums[p] = 0
	}
}
```

**复杂度分析**

- 时间复杂度: `O(n)`。其中 n 是数组的长度。快指针 q 遍历数组一次，慢指针 p 在第二步中也最多遍历一次。总的操作次数与 n 呈线性关系。
- 空间复杂度: `O(1)`。所有操作都在原数组上进行，没有使用额外的存储空间。


## [11. 盛最多水的容器 - Mid](https://leetcode.cn/problems/container-with-most-water/)

### 题目回顾

> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。
>
> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> **说明：** 你不能倾斜容器。

**示例 1：**

**输入：** `height = [1,8,6,2,5,4,8,3,7]`
**输出：** `49`
**解释：** 图中垂直线代表输入数组 `[1,8,6,2,5,4,8,3,7]`。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

### 核心思路：双指针与贪心策略

这道题是经典的**双指针**（Two Pointers）应用题，同时也蕴含了**贪心**（Greedy）的思想。

如果我们使用暴力解法，两两组合计算面积，时间复杂度会达到 $O(n^2)$，这在 `n` 很大时会超时。我们需要寻找一种 $O(n)$ 的线性扫描方法。

#### 面积公式分析

容器的蓄水量（面积）**取决于两板之间较短的那块板的高度 × 两板之间的距离**。这就像"木桶效应"，装多少水取决于最短的那块木板。

#### 双指针的决策逻辑

我们从数组的两端开始向内收缩，初始化左指针 `l = 0`，右指针 `r = n - 1`。此时**宽度最大**。

在每一步迭代中，我们需要决定移动哪一边的指针。这里有一个关键的贪心策略：
**总是移动高度较小的那一端指针。**

**为什么？**
假设当前 `height[l] < height[r]`：

1. **如果移动右指针（高板）**：宽度 `(r - l)` 变小了。而高度受限于左边的短板 `height[l]`，无论右边新的板多高，容器的实际高度不可能超过 `height[l]`。因此，面积**一定变小**。
2. **如果移动左指针（短板）**：宽度 `(r - l)` 变小了。但是，新的左边板 `height[l+1]` 有可能比原来的 `height[l]` 高。虽然宽度减小了，但高度有可能大幅增加，从而使得整体面积**有可能变大**。

简而言之，**保留短板没有前途**（因为宽度在不断减小，短板限制了高度上限），只有丢弃短板，才有可能找到更高的板来弥补宽度的损失。

#### 算法流程

1. 初始化 `ans = 0`，`l = 0`，`r = n - 1`。
2. 当 `l < r` 时循环：
   a.  计算当前面积：`tmp = min(height[l], height[r]) * (r - l)`。
   b.  更新最大面积：`ans = max(ans, tmp)`。
   c.  移动指针：如果 `height[l] <= height[r]`，则 `l++`；否则 `r--`。
3. 返回 `ans`。

### 代码实现

```go
func maxArea(height []int) int {
    l, r := 0, len(height)-1
    maxAns := 0

    for l < r {
        width := r - l
        // 确定当前这一步的短板高度
        h := 0
        if height[l] < height[r] {
            h = height[l]
        } else {
            h = height[r]
        }

        // 计算面积并更新最大值
        area := h * width
        if area > maxAns {
            maxAns = area
        }

        // --- 核心优化：快速跳过无意义的柱子 ---
        // 如果左侧是短板，移动左指针，且跳过所有比当前短板还矮的柱子
        if height[l] < height[r] {
            lastH := height[l]
            l++
            for l < r && height[l] <= lastH {
                l++
            }
        } else {
            // 如果右侧是短板，同理
            lastH := height[r]
            r--
            for l < r && height[r] <= lastH {
                r--
            }
        }
    }
    return maxAns
}
```

**复杂度分析**

`时间复杂度`: $O(n)$。我们只需遍历数组一次，双指针 l 和 r 总共移动了 n 次。

`空间复杂度`: $O(1)$。只需要常数级别的变量来存储状态，不需要额外的存储空间。
