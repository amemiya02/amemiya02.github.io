---
title: "【HOT100/滑动窗口/Middle】LeetCode 438. 找到字符串中所有字母异位词"
date: 2025-09-23 09:52:00 +0900
categories: [算法, LeetCode]
tags: [字符串, 哈希表, 滑动窗口, 数组]
---

## 题目回顾

> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **字母异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
> **字母异位词** 指由相同字母按不同顺序排列组成的字符串。

**示例 1:**

**输入:** `s = "cbaebabacd"`, `p = "abc"`
**输出:** `[0,6]`
**解释:**
起始索引等于 0 的子串是 `"cba"`, 它是 `"abc"` 的异位词。
起始索引等于 6 的子串是 `"bac"`, 它是 `"abc"` 的异位词。

## 核心思路：定长滑动窗口 + 字符频率统计

这道题要求我们在一个长字符串 `s` 中，找出所有与短字符串 `p` 构成字母异位词的**子串**。

"字母异位词"的判断标准是：两个字符串长度相等，且包含的字符种类和数量完全相同。这提示我们，核心在于**字符频率的比较**。

"找出所有...的子串"则强烈地暗示了**滑动窗口**算法。由于 `p` 的长度是固定的，我们可以使用一个**大小固定**的滑动窗口来遍历 `s`。

结合以上两点，我们的解题策略就清晰了：

1.  **统计 `p` 的频率**：首先，我们需要一个"标准答案"，也就是字符串 `p` 的字符频率分布。因为题目只包含小写字母，我们可以用一个长度为 26 的数组 `countP` 来存储。

2.  **创建固定大小的窗口**：我们在 `s` 上维护一个长度与 `p` 相同的滑动窗口。我们同样用一个长度为 26 的数组 `countS` 来实时统计这个窗口内的字符频率。

3.  **滑动与比较**：
    * **初始化**：先统计 `s` 中第一个窗口（即 `s[0...p.length()-1]`）的字符频率到 `countS` 中，并与 `countP` 比较。如果两者完全相同，那么索引 `0` 就是一个答案。
    * **滑动**：将窗口向右滑动一格。这个过程非常高效，我们不需要重新统计整个窗口，只需要：
        * **减去**移出窗口的左侧字符的频率。
        * **加上**进入窗口的右侧新字符的频率。
    * **比较**：每次滑动后，都将更新后的 `countS` 与 `countP` 进行比较。如果相同，就记录下当前窗口的起始索引。

4.  **收集结果**：重复滑动和比较的过程，直到窗口滑动到 `s` 的末尾，我们就找到了所有答案。

## 代码实现 (Java)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        int sLen = s.length(), pLen = p.length();

        if (sLen < pLen) {
            return result;
        }

        // 使用数组作为哈希表，统计 p 和窗口内 s 的字符频率
        int[] countP = new int[26];
        int[] countS = new int[26];

        // 1. 初始化第一个窗口 [0, pLen-1] 的频率
        for (int i = 0; i < pLen; i++) {
            countP[p.charAt(i) - 'a']++;
            countS[s.charAt(i) - 'a']++;
        }

        // 2. 比较第一个窗口
        if (Arrays.equals(countP, countS)) {
            result.add(0);
        }

        // 3. 开始滑动窗口
        // left 是旧窗口的起始点，新窗口的起始点是 left + 1
        for (int left = 0; left < sLen - pLen; left++) {
            // 移出旧窗口的第一个字符
            countS[s.charAt(left) - 'a']--;
            // 加入新窗口的最后一个字符
            countS[s.charAt(left + pLen) - 'a']++;

            // 4. 比较当前窗口
            if (Arrays.equals(countP, countS)) {
                result.add(left + 1);
            }
        }

        return result;
    }
}
```

**复杂度分析**

- 时间复杂度: `O(N)`。
- 空间复杂度: `O(1)`。