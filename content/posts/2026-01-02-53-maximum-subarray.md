---
title: "【HOT100/动态规划】LeetCode 53. 最大子数组和"
date: 2026-01-02 15:10:00 +0900
categories: [算法, LeetCode]
tags: [数组, 动态规划, 分治]
---

## 题目回顾

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。

**示例 1：**

**输入：** `nums = [-2,1,-3,4,-1,2,1,-5,4]`
**输出：** `6`
**解释：** 连续子数组 `[4,-1,2,1]` 的和最大，为 `6` 。

**示例 2：**

**输入：** `nums = [1]`
**输出：** `1`

**示例 3：**

**输入：** `nums = [5,4,-1,7,8]`
**输出：** `23`

## 核心思路：动态规划与贪心

这道题是**动态规划（Dynamic Programming）**的经典入门题。

如果我们用暴力法求解，枚举所有的起点和终点，时间复杂度会达到 $O(N^2)$，这显然不是最优解。我们需要找到一种遍历一次就能得出结果的方法。

### 状态定义
我们要思考：**以当前数字 `nums[i]` 结尾的子数组，它的最大和是多少？**

假设 `dp[i]` 表示以 `nums[i]` **结尾**的连续子数组的最大和。那么对于 `nums[i]` 来说，它面临两个选择：
1.  **加入前面的队伍**：如果前面的子数组和 `dp[i-1]` 是正数，那么加上它肯定比自己单干强，即 `dp[i-1] + nums[i]`。
2.  **另起炉灶**：如果前面的子数组和 `dp[i-1]` 是负数，加上它只会拖累自己，不如从自己重新开始计算，即 `nums[i]`。

### 状态转移方程
根据上述分析，我们可以得到状态转移方程：
$$
dp[i] = \max(dp[i-1] + \text{nums}[i], \text{nums}[i])
$$

### 空间优化
观察转移方程发现，当前状态 `dp[i]` 只与前一个状态 `dp[i-1]` 有关。因此，我们不需要维护一个完整的 `dp` 数组，只需要用一个变量 `pre` 来记录"前一个位置的最大子数组和"即可。这也就是代码中 `pre` 变量的作用。

这种一边遍历一边做决策（如果收益为负则舍弃）的思想，也体现了**贪心算法**的影子。

## 代码实现 (Java)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        // pre 记录以当前元素结尾的最大子数组和 (相当于 dp[i])
        // maxAns 记录全局最大值
        int pre = 0; 
        int maxAns = nums[0];

        for (int x : nums) {
            // 决策：是把当前数 x 加入之前的子数组 (pre + x)，还是从 x 开始重开 (x)
            // 如果 pre 是负数，那么 pre + x < x，所以会选择 x，相当于舍弃了之前的负收益
            pre = Math.max(pre + x, x);
            
            // 更新全局最大值
            maxAns = Math.max(pre, maxAns);
        }
        return maxAns;
    }
}
```

## 复杂度分析
- 时间复杂度: $O(N)$。我们只需要遍历数组一次
- 空间复杂度: $O(1)$。我们只使用了常数个变量，没有使用额外的数组空间（如果使用标准的 DP 数组则是 $O(N)$）。
