---
title: "【HOT100/排序】LeetCode 56. 合并区间"
date: 2026-01-02 16:20:00 +0900
categories: [算法, LeetCode]
tags: [数组, 排序]
---

## 题目回顾

> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start_i, end_i]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：**

**输入：** `intervals = [[1,3],[2,6],[8,10],[15,18]]`
**输出：** `[[1,6],[8,10],[15,18]]`
**解释：** 区间 `[1,3]` 和 `[2,6]` 重叠, 将它们合并为 `[1,6]`.

**示例 2：**

**输入：** `intervals = [[1,4],[4,5]]`
**输出：** `[[1,5]]`
**解释：** 区间 `[1,4]` 和 `[4,5]` 可被视为重叠区间。

## 核心思路：排序 + 贪心

区间问题最常见的痛点在于：输入的区间可能是乱序的。如果乱序处理，我们需要两两比较，复杂度会飙升到 $O(N^2)$。

解决此类问题的"银弹"通常是**先排序**。



**1. 预处理：排序**
我们首先按照区间的**左端点（Start Time）**进行从小到大的排序。
排序后，重叠的区间在数组中一定是相邻的。这使得我们只需要进行一次线性扫描就能完成合并。

**2. 遍历与合并**
我们维护一个结果集 `res`，并遍历排序后的区间列表：

* **初始状态**：如果 `res` 为空，直接将当前区间加入。
* **无重叠**：如果当前区间的**左端点**大于结果集中最后一个区间的**右端点**，说明它们断开了，没有交集。直接将当前区间加入 `res`。
* **有重叠**：如果当前区间的**左端点**小于等于结果集中最后一个区间的**右端点**，说明发生了重叠（或者通过端点相连）。
    * 此时我们需要**合并**：更新结果集中最后一个区间的右端点。
    * 新的右端点应该是两者右端点的最大值：`max(last_interval.end, current_interval.end)`。

## 代码实现 (Java)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 边界检查
        if (intervals.length == 0) {
            return new int[0][2];
        }

        // 核心步骤 1：按照区间左端点进行排序
        // 这一步将 O(N^2) 的两两比较降低为 O(N) 的线性扫描
        Arrays.sort(intervals, (i1, i2) -> i1[0] - i2[0]);

        List<int[]> res = new ArrayList<>();
        
        for (int i = 0; i < intervals.length; i++) {
            int l = intervals[i][0];
            int r = intervals[i][1];

            // 核心步骤 2：判断是否重叠
            // 如果结果集为空，或者当前区间的左端点 > 结果集最后一个区间的右端点
            // 说明无重叠，直接添加
            if (res.isEmpty() || res.get(res.size() - 1)[1] < l) {
                res.add(new int[]{l, r});
            } else {
                // 发生重叠，合并区间
                // 更新结果集最后一个区间的右端点，取两者最大值
                res.get(res.size() - 1)[1] = Math.max(res.get(res.size() - 1)[1], r);
            }
        }

        // 转换回题目要求的 int[][] 格式
        return res.toArray(new int[res.size()][0]);
    }
}
```
## 复杂度分析
- 时间复杂度: $O(N \log N)$。虽然遍历是一次线性的 $O(N)$，但排序的开销是 $O(N \log N)$，它是整个算法的瓶颈。
- 空间复杂度: $O(\log N)$。这里指的是 Java 排序算法（通常是快排或归并排序的变种）所需的栈空间。如果算上存储结果的 res 列表，则是 $O(N)$。
