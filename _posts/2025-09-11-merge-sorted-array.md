---
title: "【双指针】LeetCode 88. 合并两个有序数组"
date: 2025-09-11 18:46:00 +0900
categories: [算法, LeetCode]
tags: [数组, 双指针, 题解]
---

## 题目回顾

> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。
>
> 请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。
>
> **注意**：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

**示例：**

**输入：** nums1 = `[1,2,3,0,0,0]`, m = `3`, nums2 = `[2,5,6]`, n = `3`
**输出：** `[1,2,2,3,5,6]`
**解释：** 需要合并 `[1,2,3]` 和 `[2,5,6]` 。合并结果是 `[1,2,2,3,5,6]`。

## 最初的思考：为何从前往后走不通？

看到这道题，我的第一反应非常直接：创建一个新的指针 `i` 指向 `nums1` 的开头，一个指针 `j` 指向 `nums2` 的开头，然后比较 `nums1[i]` 和 `nums2[j]` 的大小，把较小的那个放到一个新数组里。

但题目要求我们**原地修改 `nums1`**，不能使用额外的数组。

好吧，那我们直接在 `nums1` 上操作。同样从前往后比较，如果 `nums1[i] > nums2[j]`，就需要把 `nums2[j]` 插入到 `nums1` 的 `i` 位置。但这意味着，`nums1` 中从 `i` 位置开始的所有元素都需要向后移动一位，为新元素腾出空间。这个移动操作的时间复杂度是 $O(m)$，如果在最坏情况下（`nums2` 的所有元素都比 `nums1` 的小），每次插入都需要移动，总的时间复杂度会飙升到 $O(m \times n)$，效率太低了。

正当我一筹莫展时，我注意到了 `nums1` 数组的一个关键特性：**它的尾部有足够的空余空间！**

## 从后往前的双指针

既然从前往后会因为“移动元素”而变得复杂，那何不逆向思维，从后往前填充呢？

`nums1` 的尾部 `m` 到 `m+n-1` 的位置是空的（初始为0），这正是为我们准备的“操作台”。我们可以利用这部分空间，从大到小地将元素填充进去，完美地避免了数据覆盖的问题。

**解题思路如下：**

1.  **定义三个指针**：
    * `p` 指向 `nums1` 有效元素部分的末尾，初始为 `m-1`。
    * `q` 指向 `nums2` 的末尾，初始为 `n-1`。
    * `r` 指向 `nums1` 数组的最末尾（也就是合并后最大元素应该在的位置），初始为 `m+n-1`。

2.  **从后往前遍历比较**：
    * 当 `p` 和 `q` 都还在有效范围内（`>=0`）时，比较 `nums1[p]` 和 `nums2[q]` 的大小。
    * 将两者中**较大**的那个数，放到 `nums1[r]` 的位置。
    * 移动被选中的那个数的指针（`p--` 或 `q--`）和放置位置的指针 (`r--`)。

3.  **处理剩余元素**：
    * 循环结束后，`p` 和 `q` 可能有一个还没有遍历完。
    * 如果 `p` 还没有遍历完（`p >= 0`），说明 `nums1` 中剩余的元素都比已经合并好的元素要小，它们已经天然地在正确的位置上了，无需任何操作。
    * 如果 `q` 还没有遍历完（`q >= 0`），说明 `nums2` 中还有剩余的、更小的元素，需要将它们依次拷贝到 `nums1` 的剩余前端位置（`r` 指针所在处）。

这个思路巧妙地利用了 `nums1` 的尾部空间，将一个可能需要 $O(m \times n)$ 复杂度的操作，优化到了 $O(m+n)$。

## 代码实现 (Java)

下面就是我根据这个思路写出的题解代码：

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // p 指向 nums1 有效元素的末尾
        int p = m - 1;
        // q 指向 nums2 的末尾
        int q = n - 1;
        // r 指向 nums1 数组的总末尾
        int r = m + n - 1;

        // 当 nums1 和 nums2 都还有元素时，从后往前比较
        while (p >= 0 && q >= 0) {
            // 将较大的元素放到 nums1 的末尾
            if (nums1[p] >= nums2[q]) {
                nums1[r--] = nums1[p--];
            } else {
                nums1[r--] = nums2[q--];
            }
        }

        // 循环结束后，如果 nums2 中还有剩余元素（说明它们都比 nums1 的所有元素小）
        // 将它们继续从后往前拷贝到 nums1 的头部空位
        while (q >= 0) {
            nums1[r--] = nums2[q--];
        }
        
        // 如果是 nums1 有剩余 (p >= 0)，它们已经在原位，不需要处理。
    }
}
```
# 复杂度分析
- 时间复杂度: `O(m+n)`。指针 p、q 和 r 都只会从后往前遍历一次数组，所以总的操作次数与 m+n 呈线性关系。

- 空间复杂度: `O(1)`。我们只使用了常数个额外指针，没有使用任何额外的存储空间，是真正的原地操作。
