---
title: "【双指针】LeetCode 392. 判断子序列"
date: 2025-09-17 20:13:00 +0900
categories: [算法, LeetCode]
tags: [字符串, 双指针]
---

## 题目回顾

> 给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的子序列。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例：**

**输入：** s = `"abc"`, t = `"ahbgdc"`
**输出：** `true`

**输入：** s = `"axc"`, t = `"ahbgdc"`
**输出：** `false`

## 核心思路：双指针

这道题的核心是匹配字符，同时要保持**相对顺序**。这种“按顺序查找”的场景，是双指针大显身手的地方。我们可以使用两个指针，一个指向子序列 `s`，一个指向主串 `t`，然后同步向前扫描。

1.  **初始化指针**：
    * 定义指针 `p` 指向 `s` 的起始位置 `0`。
    * 定义指针 `q` 指向 `t` 的起始位置 `0`。

2.  **贪心匹配**：
    * 我们使用指针 `q` 遍历主串 `t`，同时用指针 `p` 来标记我们**当前正在 `s` 中寻找的字符**。
    * 当 `p` 和 `q` 都在各自的字符串范围内时，进行循环比较：
        * 如果 `s.charAt(p)` 与 `t.charAt(q)` **相等**，意味着我们在 `t` 中找到了 `s` 的一个字符。接下来我们应该去寻找 `s` 的下一个字符了，所以将 `p` 和 `q` **都**向后移动一位 (`p++`, `q++`)。
        * 如果 `s.charAt(p)` 与 `t.charAt(q)` **不相等**，说明当前 `t` 中的这个字符不是我们想要的。我们应该继续在 `t` 的后续部分寻找 `s.charAt(p)`，所以只将 `q` 向后移动一位 (`q++`)。

3.  **判断结果**：
    * 循环的终止条件是 `p` 或 `q` 任何一个越界。
    * 循环结束后，如果 `p` 成功地移动到了 `s` 字符串的末尾（即 `p == s.length()`），说明 `s` 中的所有字符都按顺序在 `t` 中找到了。因此 `s` 是 `t` 的子序列。
    * 反之，如果 `q` 走完了 `t` 而 `p` 还没走完 `s`，则说明匹配失败。

这个方法的本质是一个贪心算法：对于 `s` 中的每一个字符，我们都在 `t` 中寻找它第一次出现的位置。

## 代码实现 (Java)

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int n = s.length(), m = t.length();
        int p = 0, q = 0;

        while (p < n && q < m) {
            // 如果找到匹配的字符，则 s 的指针 p 向后移动
            if (s.charAt(p) == t.charAt(q)) {
                p++;
            }
            // 无论是否匹配，t 的指针 q 总是向后移动
            q++;
        }
        
        // 如果 p 走完了 s，说明 s 是 t 的子序列
        return p == n;
    }

}

```

**复杂度分析**

- 时间复杂度：`O(n+m)`，其中 n 为 s 的长度，m 为 t 的长度。每次无论是匹配成功还是失败，都有至少一个指针发生右移，两指针能够位移的总距离为 n+m。
- 空间复杂度：`O(1)`。
