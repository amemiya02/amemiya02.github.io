---
title: "【双指针】LeetCode 27. 原地移除数组元素"
date: 2025-09-12 21:00:00 +0900
categories: [算法, LeetCode]
tags: [数组, 双指针, 题解]
---

## 题目回顾

> 给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。
>
> 假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：
>
> * 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
> * 返回 `k`。

**示例：**

**输入：** nums = `[3,2,2,3]`, val = `3`
**输出：** `2`, nums = `[2,2,_,_]`
**解释：** 函数应该返回 `k = 2`, 并且 `nums` 中的前两个元素均为 `2`。你的函数可以返回 `k`，并且 `nums` 的前 `k` 个元素可以包含任何顺序的 `2`。

## 核心思路：相向双指针（头尾指针）

如果允许我们使用新数组，问题会很简单。但“原地”操作的限制，意味着我们必须在 `nums` 内部完成所有交换。

一个直观的想法是，遍历数组，每当遇到值为 `val` 的元素，就将它后面的所有元素向前移动一位。但这样做的成本太高，时间复杂度会达到 $O(n^2)$。

题目的一个关键信息是：“元素的顺序可以改变”。这给了我们极大的操作自由度。我们可以不用费力地“移动”元素，而是通过“交换”来达到目的。

这正是**相向双指针**发挥作用的舞台：

1.  **定义头尾指针**：
    * `p` 指针从数组头部 `0` 开始，向后移动。它的任务是**寻找值为 `val` 的元素**。
    * `q` 指针从数组尾部 `n-1` 开始，向前移动。它的任务是**寻找值不为 `val` 的元素**。

2.  **交换与移动**：
    * 当 `p` 找到一个 `nums[p] == val`，同时 `q` 找到了一个 `nums[q] != val` 时，我们就可以将这两个元素交换。
    * 这次交换的意义在于：将一个需要移除的元素 (`val`) 和一个需要保留的元素换了位置，相当于把一个“坏”元素扔到了数组末尾的“垃圾区”，同时把一个“好”元素移到了它应该在的前半部分。
    * 交换完成后，`p` 和 `q` 各自向中间移动一步，继续寻找下一对目标。

3.  **循环终止**：
    * 当 `p` 指针与 `q` 指针相遇或交错（`p > q`）时，说明所有值为 `val` 的元素都已经被交换到了数组的后半部分。
    * 此时，`p` 指针的位置恰好就是不等于 `val` 的元素的数量 `k`。

## 代码实现 (Java)

以下是我基于相向双指针思路的实现。

```java
class Solution {
  public int removeElement(int[] nums, int val) {
    int n = nums.length;
    if (n == 0) return 0;

    int p = 0, q = n - 1;
    while (p <= q) {
      // 指针 p 从左往右，寻找第一个等于 val 的元素
      if (nums[p] != val) {
        p++;
        continue; // 继续寻找
      }

      // 指针 q 从右往左，寻找第一个不等于 val 的元素
      if (nums[q] == val) {
        q--;
        continue; // 继续寻找
      }

      // 此时，p 指向了 val, q 指向了非 val，进行交换
      swap(nums, p, q);
      p++;
      q--;
    }
    // 循环结束后，p 的位置就是不重复元素的数量
    return p;
  }

  private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
}
```
**复杂度分析**

- 时间复杂度: O(n)。p 和 q 两个指针最多各自遍历整个数组一次。
- 空间复杂度: O(1)。只使用了常数级别的额外空间，完美符合题目要求。
