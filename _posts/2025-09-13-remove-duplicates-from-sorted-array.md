---
title: "【快慢指针】LeetCode 26.删除有序数组中的重复项"
date: 2025-09-13 SSS10:35:00 +0900
categories: [算法, LeetCode]
tags: [数组, 双指针, 快慢指针]
---

## 题目回顾

> 给你一个 **非严格递增排列** 的数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。
>
> 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。
>
> 返回 `k` 。

**示例：**

**输入：** nums = `[0,0,1,1,1,2,2,3,3,4]`
**输出：** `5`, nums = `[0,1,2,3,4,_,_,_,_,_]`
**解释：** 函数应该返回 `k = 5`，并且 `nums` 的前五个元素为 `0, 1, 2, 3, 4`。

## 核心思路：快慢指针

题目的关键在于“数组有序”和“保持相对顺序”。因为数组是有序的，所以所有重复的元素必然是相邻的。这让我们不必进行复杂的查找，只需向后遍历即可。

我们可以使用**快慢指针**来解决这个问题：

1.  **定义指针**：
    * **慢指针 `p`**: 指向当前已处理好的、不重复数组的最后一个位置。它也代表了下一个唯一元素应该被放置的位置。
    * **快指针 `q`**: 负责向前探索，遍历整个数组，寻找与慢指针所指元素不同的新元素。

2.  **执行过程**：
    * 初始化 `p = 0`, `q = 1`。
    * 快指针 `q` 向后遍历数组。
    * 若 `nums[q]` 与 `nums[p]` **相同**，说明是重复元素，则 `p` 不动，`q` 继续向后移动以跳过所有重复项。
    * 若 `nums[q]` 与 `nums[p]` **不同**，说明 `q` 找到了一个新的唯一元素。此时，先将慢指针 `p` 向后移动一位 (`++p`)，然后将 `nums[q]` 的值赋给 `nums[p]`，完成新元素的“入队”。

3.  **返回结果**：
    * 当 `q` 遍历完整个数组后，`p` 指针所在的索引就是最后一个唯一元素的位置。
    * 因此，新数组的长度即为 `p + 1`。

这个过程本质上是将不重复的元素，从数组前面开始，一个个地覆盖掉后面的重复元素。

## 代码实现 (Java)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        
        // p 是慢指针, q 是快指针
        int p = 0;
        for (int q = 1; q < nums.length; q++) {
            // 当找到一个与慢指针所指元素不同的新元素时
            if (nums[p] != nums[q]) {
                // 先移动慢指针
                // 再将新元素的值覆盖到慢指针的新位置
                nums[++p] = nums[q];
            }
        }
        // 数组长度是索引 + 1
        return p + 1;
    }
}
```
**复杂度分析**

- 时间复杂度: `O(n)`。快慢指针都只对数组进行单次遍历。
- 空间复杂度: `O(1)`。原地修改，没有使用额外空间。
