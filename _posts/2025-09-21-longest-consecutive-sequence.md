---
title: "【哈希集合/Middle】LeetCode 128. 最长连续序列"
date: 2025-09-21 11:03:00 +0900
categories: [算法, LeetCode]
tags: [数组, 哈希集合, O(n)]
---

## 题目回顾

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> 请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

**输入：** `nums = [100,4,200,1,3,2]`
**输出：** `4`
**解释：** 最长数字连续序列是 `[1, 2, 3, 4]`。它的长度为 4。

## 核心思路：哈希集合 + 智能枚举

这道题最核心的要求是 `O(n)` 的时间复杂度，这意味着我们不能使用排序 $O(nlogn)$。

要实现 `O(n)`，关键在于**快速查找**某个数是否存在。这让我们自然而然地想到了哈希表。我们可以用一个**哈希集合 (HashSet)** 来优化查找过程。

**这题的关键是找出序列起点来剪枝**

1.  **空间换时间，初始化哈希集合**
    * 创建一个 `HashSet`，并将数组 `nums` 中的所有元素都添加进去。
    * 这一步有两个目的：一是方便后续以 $O(1)$ 的时间复杂度快速查找某个数是否存在；二是自动处理了数组中的重复元素。

2.  **智能遍历，只从序列的起点开始计算**
    * 这是整个算法最精妙的地方。如果我们遍历集合中的每一个数，都尝试计算以它开头的序列长度，会有大量重复计算。例如，对于序列 `[1, 2, 3, 4]`，我们从 `1` 开始计算了一遍，又会从 `2` 开始再计算一遍 `[2, 3, 4]`，这是不必要的。
    * **如何避免重复计算？** 答案是：**只从一个连续序列的起点开始计算**。
    * **如何判断一个数 `num` 是不是起点？** 很简单，只要检查 `num - 1` 是否存在于哈希集合中。如果 `num - 1` **不存在**，那么 `num` 就是一个潜在的序列起点。如果 `num - 1` **存在**，那么 `num` 肯定不是起点，我们可以直接跳过它，因为它一定会被 `num - 1` 开始的计算所覆盖。

3.  **计算长度并更新结果**
    * 遍历哈希集合，对于每个元素 `num`：
        * **判断是否为起点**：`if (!set.contains(num - 1))`
        * **如果是起点**：就从 `num` 开始，不断检查 `num + 1`, `num + 2`, ... 是否存在于集合中，以此计算出当前序列的长度。
        * **更新最大值**：将当前计算出的长度与全局的最大长度进行比较并更新。

通过这种“只从起点开始”的智能枚举，我们确保了每个数字作为序列的一部分，只会被内层循环访问一次，从而将总时间复杂度控制在 $O(n)$。

## 代码实现 (Java)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // 1. 将所有数字放入哈希集合，O(n) 且去重
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }

        int longestStreak = 0;
        
        // 2. 遍历哈希集合 如果遍历数组会超时
        for (int num : set) {
            // 3. 智能判断：只有当 num-1 不存在时，才将 num 视为序列的起点
            // 如果num-1存在，说明在前面已经便利过了 直接跳过
            if (!set.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                // 4. 从起点开始，向后查找连续序列的长度
                while (set.contains(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }
                
                // 5. 更新最长序列的长度
                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }
        
        return longestStreak;
    }
}
```

**复杂度分析**

    
- 时间复杂度: `O(n)`。

        将 n 个数添加到 HashSet 中，时间复杂度为 O(n)。

        外层 for 循环会执行 m 次（m 为去重后的元素数量，m <= n）。

        内层 while 循环虽然看起来像是嵌套，但每个元素最多只会被 while 循环访问一次（当它作为序列的一部分被currentNum + 1访问时）。因此，所有 while 循环的总执行次数加起来也是 O(m)。

        总的时间复杂度是 O(n) + O(m)，即 O(n)。

- 空间复杂度: O(n)。在最坏情况下，数组中所有元素都不同，HashSet 需要存储 n 个元素。
