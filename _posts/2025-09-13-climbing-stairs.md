---
title: "【动态规划】LeetCode 70.爬楼梯"
date: 2025-09-13 10:40:00 +0900
categories: [算法, LeetCode, 动态规划]
tags: [动态规划, 斐波那契数列, 题解]
---

## 题目回顾

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**

**输入：** n = 3
**输出：** 3
**解释：** 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

## 核心思路：寻找递推关系

直接计算 `n` 阶楼梯的所有方法可能很复杂，我们不妨从小问题入手，寻找规律。

* **爬 1 阶楼梯 (n=1)**: 只有 1 种方法 (1)。 -> $f(1) = 1$
* **爬 2 阶楼梯 (n=2)**: 有 2 种方法 (1+1, 2)。 -> $f(2) = 2$
* **爬 3 阶楼梯 (n=3)**: 有 3 种方法 (1+1+1, 1+2, 2+1)。 -> $f(3) = 3$

我们思考一下，要想到达第 `n` 阶，我们的**最后一步**是怎么迈出去的？

只有两种可能：
1.  从第 `n-1` 阶爬 `1` 个台阶上来。
2.  从第 `n-2` 阶爬 `2` 个台阶上来。

因此，到达第 `n` 阶的方法总数，等于**到达第 `n-1` 阶的方法数**与**到达第 `n-2` 阶的方法数**之和。

这就得到了这个问题的**状态转移方程**（或称递推关系）：
$f(n) = f(n-1) + f(n-2)$

这正是著名的**斐波那契数列**！我们已经找到了问题的解题公式，接下来只需要用代码实现它。

最直接的方法是递归，但会因大量重复计算而超时。更好的方法是使用迭代，从下往上计算。我们注意到，计算 $f(n)$ 只需要前两项 $f(n-1)$ 和 $f(n-2)$ 的值，所以我们甚至不需要一个数组来存储所有中间结果，只需要两个变量滚动向前计算即可。

## 代码实现 (Java)

这种只用有限变量来代替 DP 数组的方法，常被称为“滚动数组”思想，能将空间复杂度从 $O(n)$ 优化到 $O(1)$。

```java
class Solution {
    public int climbStairs(int n) {
        // base cases: n=1时1种，n=2时2种
        if (n <= 2) {
            return n;
        }
        
        // a 代表 f(i-2), b 代表 f(i-1)
        int a = 1, b = 2;
        
        // 从第 3 阶开始循环计算
        for (int i = 3; i <= n; i++) {
            // c 代表 f(i)，即 f(i-1) + f(i-2)
            int c = a + b;
            // 更新 a 和 b，为下一次计算做准备
            a = b;
            b = c;
        }
        
        // 循环结束后, b 中存储的就是 f(n) 的结果
        return b;
    }
}
```
**复杂度分析**

- 时间复杂度: `O(n)`。我们只需要一个 for 循环，从 3 迭代到 n。
- 空间复杂度: `O(1)`。只使用了常数个变量，与 n 的大小无关。
