---
title: "【快慢指针】LeetCode 283. 移动零"
date: 2025-09-20 14:55:00 +0900
categories: [算法, LeetCode]
tags: [数组, 双指针, 快慢指针]
---

## 题目回顾

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下**原地**对数组进行操作。

**示例 1:**

**输入:** `nums = [0,1,0,3,12]`
**输出:** `[1,3,12,0,0]`

## 核心思路：快慢指针（一次遍历）

这道题有两个核心要求：
1.  将所有 `0` 移动到末尾。
2.  保持所有**非零**元素的相对顺序不变。

第二个要求“保持相对顺序”是解题的关键。它告诉我们，不能简单地像“移除元素”那样，用头尾指针交换元素，因为那样会打乱非零元素的原有顺序。

这个问题的本质可以看作是：**将所有非零元素，按原有的顺序，紧凑地移动到数组的前面，然后将剩余的位置全部填上零**。

这正是**快慢指针**擅长的场景：

1.  **定义指针**：
    * **慢指针 `p` (或 `slow`)**: 这个指针用于标记“下一个非零元素应该被放置的位置”。在 `p` 左边的所有元素（不含 `p`）都是已经处理好的、按序排列的非零元素。
    * **快指针 `q` (或 `fast`)**: 这个指针负责遍历整个数组，去寻找非零元素。

2.  **执行过程**：
    * 初始化 `p` 和 `q` 都指向数组的起始位置 `0`。
    * 快指针 `q` 开始向后遍历数组。
    * 当 `q` 遇到一个**非零**元素时，说明这个元素需要被保留并放到前面。于是，我们执行两个操作：
        1.  将这个非零元素 `nums[q]` 赋值给慢指针 `p` 所在的位置 `nums[p]`。
        2.  将慢指针 `p` 向后移动一位 (`p++`)，为下一个非零元素腾出位置。
    * 如果 `q` 遇到的是 `0`，则慢指针 `p` 保持不动，只有快指针 `q` 继续向后移动。

3.  **填充末尾的零**：
    * 当快指针 `q` 遍历完整个数组后，所有非零元素都已经被紧凑地移动到了数组的前 `p` 个位置。
    * 数组中从索引 `p` 到末尾的所有位置，都应该是 `0`。
    * 因此，我们再进行一次循环，从 `p` 开始，将数组剩余的位置全部赋值为 `0`。

## 代码实现 (Java)
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return;
        }

        // p 是慢指针，q 是快指针
        int p = 0; 
        for (int q = 0; q < n; q++) {
            // 如果快指针指向的不是 0
            if (nums[q] != 0) {
                // 就把它放到慢指针的位置
                nums[p] = nums[q];
                // 然后慢指针前进一步
                p++;
            }
        }

        // 此时，p 指向的位置以及之后的所有位置都应该是 0
        while (p < n) {
            nums[p++] = 0;
        }
    }
}
```
**复杂度分析**

- 时间复杂度: `O(n)`。其中 n 是数组的长度。快指针 q 遍历数组一次，慢指针 p 在第二步中也最多遍历一次。总的操作次数与 n 呈线性关系。

- 空间复杂度: `O(1)`。所有操作都在原数组上进行，没有使用额外的存储空间。


