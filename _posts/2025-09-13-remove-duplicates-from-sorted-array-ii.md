---
title: "【快慢指针】LeetCode 80. 删除有序数组中的重复项 II"
date: 2025-09-14 16:55:00 +0900
categories: [算法, LeetCode]
tags: [数组, 双指针, 快慢指针]
---

## 题目回顾

> 给你一个有序数组 `nums` ，请你 **原地** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在 **原地** 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

**示例：**

**输入：** nums = `[1,1,1,2,2,3]`
**输出：** `5`, nums = `[1,1,2,2,3,_]`
**解释：** 函数应返回 `k = 5`，并且 `nums` 的前五个元素为 `1, 1, 2, 2, 3`。

## 核心思路：快慢指针的通用解法

这道题是 LeetCode 26 的进阶版，规则从“只保留 1 个”变成了“最多保留 2 个”。快慢指针的思路依然适用，我们只需要对写入条件稍作修改。

我们可以定义一个更通用的解法来处理“最多保留 k 个重复项”这类问题。

1.  **定义指针**：
    * **慢指针 `slow`**: 指向下一个可以被覆盖的位置。`[0...slow-1]` 是已处理好的区域。
    * **快指针 `fast`**: 遍历整个数组，寻找符合条件的元素。

2.  **执行过程**：
    * 我们遍历数组，对于快指针 `fast` 指向的当前元素 `nums[fast]`，思考一个问题：**在什么情况下，这个元素应该被保留下来？**
    * 保留的条件是：当前处理好的数组长度 `slow` 小于 2，或者 `nums[fast]` 不等于 `nums[slow - 2]`。
        * `slow < 2`：表示当前是数组最开头的两个位置，无论如何都应该被填充，因为题目允许最多两个重复项。
        * `nums[fast] > nums[slow - 2]`：这是本算法的核心。`nums[slow - 1]` 和 `nums[slow - 2]` 是已处理好的数组的最后两个元素。如果当前快指针的元素 `nums[fast]` 和 `nums[slow - 2]` 相同，说明 `nums[slow-2]`, `nums[slow-1]`, `nums[fast]` 将构成三个或以上的连续重复，此时 `nums[fast]` 不应被保留。反之，则可以保留。

3.  **返回结果**：
    * 遍历结束后，`slow` 的值就是新数组的长度。

这个思路非常巧妙，因为它将判断逻辑统一到了一个简单的条件上，并且可以轻松扩展到“最多保留 k 个”的情况（只需将 `2` 替换为 `k`）。

## 代码实现 (Java)

首先，我们提供一个基于上述通用思路的简洁实现，这通常是面试中的推荐写法。

```java
// 通用解法
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            // 如果 slow < 2，说明还没填满2个，直接放
            // 如果 nums[fast] > nums[slow - 2]，说明和前2个元素不同，也可以放
            if (slow < 2 || nums[fast] > nums[slow - 2]) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```
**复杂度分析**

- 时间复杂度: `O(n)`。快慢指针只对数组进行一次完整的遍历。
- 空间复杂度: `O(1)`。所有操作都在原数组上进行，是原地修改。
